(() => {
  var __defProp = Object.defineProperty;
  var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[Object.keys(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    __markAsModule(target);
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };

  // ../../node_modules/@babel/runtime/helpers/esm/typeof.js
  var init_typeof = __esm({
    "../../node_modules/@babel/runtime/helpers/esm/typeof.js"() {
    }
  });

  // ../../node_modules/@babel/runtime/helpers/esm/toPrimitive.js
  var init_toPrimitive = __esm({
    "../../node_modules/@babel/runtime/helpers/esm/toPrimitive.js"() {
      init_typeof();
    }
  });

  // ../../node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
  var init_toPropertyKey = __esm({
    "../../node_modules/@babel/runtime/helpers/esm/toPropertyKey.js"() {
      init_typeof();
      init_toPrimitive();
    }
  });

  // ../../node_modules/@babel/runtime/helpers/esm/defineProperty.js
  var init_defineProperty = __esm({
    "../../node_modules/@babel/runtime/helpers/esm/defineProperty.js"() {
      init_toPropertyKey();
    }
  });

  // ../../node_modules/@math.gl/polygon/dist/esm/polygon-utils.js
  function getPolygonSignedArea(points, options = {}) {
    const {
      start = 0,
      end = points.length
    } = options;
    const dim = options.size || 2;
    let area2 = 0;
    for (let i = start, j = end - dim; i < end; i += dim) {
      area2 += (points[i] - points[j]) * (points[i + 1] + points[j + 1]);
      j = i;
    }
    return area2 / 2;
  }
  var init_polygon_utils = __esm({
    "../../node_modules/@math.gl/polygon/dist/esm/polygon-utils.js"() {
    }
  });

  // ../../node_modules/@math.gl/polygon/dist/esm/polygon.js
  var init_polygon = __esm({
    "../../node_modules/@math.gl/polygon/dist/esm/polygon.js"() {
      init_defineProperty();
      init_polygon_utils();
    }
  });

  // ../../node_modules/@math.gl/polygon/dist/esm/earcut.js
  function earcut(positions, holeIndices, dim = 2, areas) {
    const hasHoles = holeIndices && holeIndices.length;
    const outerLen = hasHoles ? holeIndices[0] * dim : positions.length;
    let outerNode = linkedList(positions, 0, outerLen, dim, true, areas && areas[0]);
    const triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev)
      return triangles;
    let invSize;
    let maxX;
    let maxY;
    let minX;
    let minY;
    let x;
    let y;
    if (hasHoles)
      outerNode = eliminateHoles(positions, holeIndices, outerNode, dim, areas);
    if (positions.length > 80 * dim) {
      minX = maxX = positions[0];
      minY = maxY = positions[1];
      for (let i = dim; i < outerLen; i += dim) {
        x = positions[i];
        y = positions[i + 1];
        if (x < minX)
          minX = x;
        if (y < minY)
          minY = y;
        if (x > maxX)
          maxX = x;
        if (y > maxY)
          maxY = y;
      }
      invSize = Math.max(maxX - minX, maxY - minY);
      invSize = invSize !== 0 ? 1 / invSize : 0;
    }
    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
    return triangles;
  }
  function linkedList(data, start, end, dim, clockwise, area2) {
    let i;
    let last;
    if (area2 === void 0) {
      area2 = getPolygonSignedArea(data, {
        start,
        end,
        size: dim
      });
    }
    if (clockwise === area2 < 0) {
      for (i = start; i < end; i += dim)
        last = insertNode(i, data[i], data[i + 1], last);
    } else {
      for (i = end - dim; i >= start; i -= dim)
        last = insertNode(i, data[i], data[i + 1], last);
    }
    if (last && equals(last, last.next)) {
      removeNode(last);
      last = last.next;
    }
    return last;
  }
  function filterPoints(start, end) {
    if (!start)
      return start;
    if (!end)
      end = start;
    let p = start;
    let again;
    do {
      again = false;
      if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
        removeNode(p);
        p = end = p.prev;
        if (p === p.next)
          break;
        again = true;
      } else {
        p = p.next;
      }
    } while (again || p !== end);
    return end;
  }
  function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear)
      return;
    if (!pass && invSize)
      indexCurve(ear, minX, minY, invSize);
    let stop = ear;
    let prev;
    let next;
    while (ear.prev !== ear.next) {
      prev = ear.prev;
      next = ear.next;
      if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
        triangles.push(prev.i / dim);
        triangles.push(ear.i / dim);
        triangles.push(next.i / dim);
        removeNode(ear);
        ear = next.next;
        stop = next.next;
        continue;
      }
      ear = next;
      if (ear === stop) {
        if (!pass) {
          earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
        } else if (pass === 1) {
          ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
          earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
        } else if (pass === 2) {
          splitEarcut(ear, triangles, dim, minX, minY, invSize);
        }
        break;
      }
    }
  }
  function isEar(ear) {
    const a = ear.prev;
    const b = ear;
    const c = ear.next;
    if (area(a, b, c) >= 0)
      return false;
    let p = ear.next.next;
    while (p !== ear.prev) {
      if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
        return false;
      p = p.next;
    }
    return true;
  }
  function isEarHashed(ear, minX, minY, invSize) {
    const a = ear.prev;
    const b = ear;
    const c = ear.next;
    if (area(a, b, c) >= 0)
      return false;
    const minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x;
    const minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y;
    const maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x;
    const maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;
    const minZ = zOrder(minTX, minTY, minX, minY, invSize);
    const maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
    let p = ear.prevZ;
    let n = ear.nextZ;
    while (p && p.z >= minZ && n && n.z <= maxZ) {
      if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
        return false;
      p = p.prevZ;
      if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0)
        return false;
      n = n.nextZ;
    }
    while (p && p.z >= minZ) {
      if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
        return false;
      p = p.prevZ;
    }
    while (n && n.z <= maxZ) {
      if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0)
        return false;
      n = n.nextZ;
    }
    return true;
  }
  function cureLocalIntersections(start, triangles, dim) {
    let p = start;
    do {
      const a = p.prev;
      const b = p.next.next;
      if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
        triangles.push(a.i / dim);
        triangles.push(p.i / dim);
        triangles.push(b.i / dim);
        removeNode(p);
        removeNode(p.next);
        p = start = b;
      }
      p = p.next;
    } while (p !== start);
    return filterPoints(p);
  }
  function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    let a = start;
    do {
      let b = a.next.next;
      while (b !== a.prev) {
        if (a.i !== b.i && isValidDiagonal(a, b)) {
          let c = splitPolygon(a, b);
          a = filterPoints(a, a.next);
          c = filterPoints(c, c.next);
          earcutLinked(a, triangles, dim, minX, minY, invSize);
          earcutLinked(c, triangles, dim, minX, minY, invSize);
          return;
        }
        b = b.next;
      }
      a = a.next;
    } while (a !== start);
  }
  function eliminateHoles(data, holeIndices, outerNode, dim, areas) {
    const queue = [];
    let i;
    let len;
    let start;
    let end;
    let list;
    for (i = 0, len = holeIndices.length; i < len; i++) {
      start = holeIndices[i] * dim;
      end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
      list = linkedList(data, start, end, dim, false, areas && areas[i + 1]);
      if (list === list.next)
        list.steiner = true;
      queue.push(getLeftmost(list));
    }
    queue.sort(compareX);
    for (i = 0; i < queue.length; i++) {
      eliminateHole(queue[i], outerNode);
      outerNode = filterPoints(outerNode, outerNode.next);
    }
    return outerNode;
  }
  function compareX(a, b) {
    return a.x - b.x;
  }
  function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);
    if (outerNode) {
      const b = splitPolygon(outerNode, hole);
      filterPoints(outerNode, outerNode.next);
      filterPoints(b, b.next);
    }
  }
  function findHoleBridge(hole, outerNode) {
    let p = outerNode;
    const hx = hole.x;
    const hy = hole.y;
    let qx = -Infinity;
    let m;
    do {
      if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
        const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
        if (x <= hx && x > qx) {
          qx = x;
          if (x === hx) {
            if (hy === p.y)
              return p;
            if (hy === p.next.y)
              return p.next;
          }
          m = p.x < p.next.x ? p : p.next;
        }
      }
      p = p.next;
    } while (p !== outerNode);
    if (!m)
      return null;
    if (hx === qx)
      return m;
    const stop = m;
    const mx = m.x;
    const my = m.y;
    let tanMin = Infinity;
    let tan;
    p = m;
    do {
      if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
        tan = Math.abs(hy - p.y) / (hx - p.x);
        if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
          m = p;
          tanMin = tan;
        }
      }
      p = p.next;
    } while (p !== stop);
    return m;
  }
  function sectorContainsSector(m, p) {
    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
  }
  function indexCurve(start, minX, minY, invSize) {
    let p = start;
    do {
      if (p.z === null)
        p.z = zOrder(p.x, p.y, minX, minY, invSize);
      p.prevZ = p.prev;
      p.nextZ = p.next;
      p = p.next;
    } while (p !== start);
    p.prevZ.nextZ = null;
    p.prevZ = null;
    sortLinked(p);
  }
  function sortLinked(list) {
    let e;
    let i;
    let inSize = 1;
    let numMerges;
    let p;
    let pSize;
    let q;
    let qSize;
    let tail;
    do {
      p = list;
      list = null;
      tail = null;
      numMerges = 0;
      while (p) {
        numMerges++;
        q = p;
        pSize = 0;
        for (i = 0; i < inSize; i++) {
          pSize++;
          q = q.nextZ;
          if (!q)
            break;
        }
        qSize = inSize;
        while (pSize > 0 || qSize > 0 && q) {
          if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
            e = p;
            p = p.nextZ;
            pSize--;
          } else {
            e = q;
            q = q.nextZ;
            qSize--;
          }
          if (tail)
            tail.nextZ = e;
          else
            list = e;
          e.prevZ = tail;
          tail = e;
        }
        p = q;
      }
      tail.nextZ = null;
      inSize *= 2;
    } while (numMerges > 1);
    return list;
  }
  function zOrder(x, y, minX, minY, invSize) {
    x = 32767 * (x - minX) * invSize;
    y = 32767 * (y - minY) * invSize;
    x = (x | x << 8) & 16711935;
    x = (x | x << 4) & 252645135;
    x = (x | x << 2) & 858993459;
    x = (x | x << 1) & 1431655765;
    y = (y | y << 8) & 16711935;
    y = (y | y << 4) & 252645135;
    y = (y | y << 2) & 858993459;
    y = (y | y << 1) & 1431655765;
    return x | y << 1;
  }
  function getLeftmost(start) {
    let p = start;
    let leftmost = start;
    do {
      if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y)
        leftmost = p;
      p = p.next;
    } while (p !== start);
    return leftmost;
  }
  function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
  }
  function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && (area(a.prev, a, b.prev) || area(a, b.prev, b)) || equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0);
  }
  function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
  }
  function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
  }
  function intersects(p1, q1, p2, q2) {
    const o1 = sign(area(p1, q1, p2));
    const o2 = sign(area(p1, q1, q2));
    const o3 = sign(area(p2, q2, p1));
    const o4 = sign(area(p2, q2, q1));
    if (o1 !== o2 && o3 !== o4)
      return true;
    if (o1 === 0 && onSegment(p1, p2, q1))
      return true;
    if (o2 === 0 && onSegment(p1, q2, q1))
      return true;
    if (o3 === 0 && onSegment(p2, p1, q2))
      return true;
    if (o4 === 0 && onSegment(p2, q1, q2))
      return true;
    return false;
  }
  function onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
  }
  function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
  }
  function intersectsPolygon(a, b) {
    let p = a;
    do {
      if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b))
        return true;
      p = p.next;
    } while (p !== a);
    return false;
  }
  function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
  }
  function middleInside(a, b) {
    let p = a;
    let inside = false;
    const px = (a.x + b.x) / 2;
    const py = (a.y + b.y) / 2;
    do {
      if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x)
        inside = !inside;
      p = p.next;
    } while (p !== a);
    return inside;
  }
  function splitPolygon(a, b) {
    const a2 = new Node(a.i, a.x, a.y);
    const b2 = new Node(b.i, b.x, b.y);
    const an = a.next;
    const bp = b.prev;
    a.next = b;
    b.prev = a;
    a2.next = an;
    an.prev = a2;
    b2.next = a2;
    a2.prev = b2;
    bp.next = b2;
    b2.prev = bp;
    return b2;
  }
  function insertNode(i, x, y, last) {
    const p = new Node(i, x, y);
    if (!last) {
      p.prev = p;
      p.next = p;
    } else {
      p.next = last.next;
      p.prev = last;
      last.next.prev = p;
      last.next = p;
    }
    return p;
  }
  function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;
    if (p.prevZ)
      p.prevZ.nextZ = p.nextZ;
    if (p.nextZ)
      p.nextZ.prevZ = p.prevZ;
  }
  function Node(i, x, y) {
    this.i = i;
    this.x = x;
    this.y = y;
    this.prev = null;
    this.next = null;
    this.z = null;
    this.prevZ = null;
    this.nextZ = null;
    this.steiner = false;
  }
  var init_earcut = __esm({
    "../../node_modules/@math.gl/polygon/dist/esm/earcut.js"() {
      init_polygon_utils();
    }
  });

  // ../../node_modules/@math.gl/polygon/dist/esm/utils.js
  var init_utils = __esm({
    "../../node_modules/@math.gl/polygon/dist/esm/utils.js"() {
    }
  });

  // ../../node_modules/@math.gl/polygon/dist/esm/lineclip.js
  var init_lineclip = __esm({
    "../../node_modules/@math.gl/polygon/dist/esm/lineclip.js"() {
      init_utils();
    }
  });

  // ../../node_modules/@math.gl/polygon/dist/esm/cut-by-grid.js
  var init_cut_by_grid = __esm({
    "../../node_modules/@math.gl/polygon/dist/esm/cut-by-grid.js"() {
      init_lineclip();
      init_utils();
    }
  });

  // ../../node_modules/@math.gl/polygon/dist/esm/cut-by-mercator-bounds.js
  var init_cut_by_mercator_bounds = __esm({
    "../../node_modules/@math.gl/polygon/dist/esm/cut-by-mercator-bounds.js"() {
      init_cut_by_grid();
      init_utils();
    }
  });

  // ../../node_modules/@math.gl/polygon/dist/esm/index.js
  var init_esm = __esm({
    "../../node_modules/@math.gl/polygon/dist/esm/index.js"() {
      init_polygon();
      init_polygon_utils();
      init_earcut();
      init_lineclip();
      init_cut_by_grid();
      init_cut_by_mercator_bounds();
      init_polygon();
    }
  });

  // ../gis/src/lib/flat-geojson-to-binary.ts
  function flatGeojsonToBinary(features, geometryInfo, options) {
    const propArrayTypes = extractNumericPropTypes(features);
    const numericPropKeys = Object.keys(propArrayTypes).filter((k) => propArrayTypes[k] !== Array);
    return fillArrays(features, {
      propArrayTypes,
      ...geometryInfo
    }, {
      numericPropKeys: options && options.numericPropKeys || numericPropKeys,
      PositionDataType: options ? options.PositionDataType : Float32Array,
      triangulate: options ? options.triangulate : true
    });
  }
  function extractNumericPropTypes(features) {
    const propArrayTypes = {};
    for (const feature of features) {
      if (feature.properties) {
        for (const key in feature.properties) {
          const val = feature.properties[key];
          propArrayTypes[key] = deduceArrayType(val, propArrayTypes[key]);
        }
      }
    }
    return propArrayTypes;
  }
  function fillArrays(features, geometryInfo, options) {
    const {
      pointPositionsCount,
      pointFeaturesCount,
      linePositionsCount,
      linePathsCount,
      lineFeaturesCount,
      polygonPositionsCount,
      polygonObjectsCount,
      polygonRingsCount,
      polygonFeaturesCount,
      propArrayTypes,
      coordLength
    } = geometryInfo;
    const { numericPropKeys = [], PositionDataType = Float32Array, triangulate = true } = options;
    const hasGlobalId = features[0] && "id" in features[0];
    const GlobalFeatureIdsDataType = features.length > 65535 ? Uint32Array : Uint16Array;
    const points = {
      type: "Point",
      positions: new PositionDataType(pointPositionsCount * coordLength),
      globalFeatureIds: new GlobalFeatureIdsDataType(pointPositionsCount),
      featureIds: pointFeaturesCount > 65535 ? new Uint32Array(pointPositionsCount) : new Uint16Array(pointPositionsCount),
      numericProps: {},
      properties: [],
      fields: []
    };
    const lines = {
      type: "LineString",
      pathIndices: linePositionsCount > 65535 ? new Uint32Array(linePathsCount + 1) : new Uint16Array(linePathsCount + 1),
      positions: new PositionDataType(linePositionsCount * coordLength),
      globalFeatureIds: new GlobalFeatureIdsDataType(linePositionsCount),
      featureIds: lineFeaturesCount > 65535 ? new Uint32Array(linePositionsCount) : new Uint16Array(linePositionsCount),
      numericProps: {},
      properties: [],
      fields: []
    };
    const polygons = {
      type: "Polygon",
      polygonIndices: polygonPositionsCount > 65535 ? new Uint32Array(polygonObjectsCount + 1) : new Uint16Array(polygonObjectsCount + 1),
      primitivePolygonIndices: polygonPositionsCount > 65535 ? new Uint32Array(polygonRingsCount + 1) : new Uint16Array(polygonRingsCount + 1),
      positions: new PositionDataType(polygonPositionsCount * coordLength),
      globalFeatureIds: new GlobalFeatureIdsDataType(polygonPositionsCount),
      featureIds: polygonFeaturesCount > 65535 ? new Uint32Array(polygonPositionsCount) : new Uint16Array(polygonPositionsCount),
      numericProps: {},
      properties: [],
      fields: []
    };
    if (triangulate) {
      polygons.triangles = [];
    }
    for (const object of [points, lines, polygons]) {
      for (const propName of numericPropKeys) {
        const T = propArrayTypes[propName];
        object.numericProps[propName] = new T(object.positions.length / coordLength);
      }
    }
    lines.pathIndices[linePathsCount] = linePositionsCount;
    polygons.polygonIndices[polygonObjectsCount] = polygonPositionsCount;
    polygons.primitivePolygonIndices[polygonRingsCount] = polygonPositionsCount;
    const indexMap = {
      pointPosition: 0,
      pointFeature: 0,
      linePosition: 0,
      linePath: 0,
      lineFeature: 0,
      polygonPosition: 0,
      polygonObject: 0,
      polygonRing: 0,
      polygonFeature: 0,
      feature: 0
    };
    for (const feature of features) {
      const geometry = feature.geometry;
      const properties = feature.properties || {};
      switch (geometry.type) {
        case "Point":
          handlePoint(geometry, points, indexMap, coordLength, properties);
          points.properties.push(keepStringProperties(properties, numericPropKeys));
          if (hasGlobalId) {
            points.fields.push({ id: feature.id });
          }
          indexMap.pointFeature++;
          break;
        case "LineString":
          handleLineString(geometry, lines, indexMap, coordLength, properties);
          lines.properties.push(keepStringProperties(properties, numericPropKeys));
          if (hasGlobalId) {
            lines.fields.push({ id: feature.id });
          }
          indexMap.lineFeature++;
          break;
        case "Polygon":
          handlePolygon(geometry, polygons, indexMap, coordLength, properties);
          polygons.properties.push(keepStringProperties(properties, numericPropKeys));
          if (hasGlobalId) {
            polygons.fields.push({ id: feature.id });
          }
          indexMap.polygonFeature++;
          break;
        default:
          throw new Error("Invalid geometry type");
      }
      indexMap.feature++;
    }
    return makeAccessorObjects(points, lines, polygons, coordLength);
  }
  function handlePoint(geometry, points, indexMap, coordLength, properties) {
    points.positions.set(geometry.data, indexMap.pointPosition * coordLength);
    const nPositions = geometry.data.length / coordLength;
    fillNumericProperties(points, properties, indexMap.pointPosition, nPositions);
    points.globalFeatureIds.fill(indexMap.feature, indexMap.pointPosition, indexMap.pointPosition + nPositions);
    points.featureIds.fill(indexMap.pointFeature, indexMap.pointPosition, indexMap.pointPosition + nPositions);
    indexMap.pointPosition += nPositions;
  }
  function handleLineString(geometry, lines, indexMap, coordLength, properties) {
    lines.positions.set(geometry.data, indexMap.linePosition * coordLength);
    const nPositions = geometry.data.length / coordLength;
    fillNumericProperties(lines, properties, indexMap.linePosition, nPositions);
    lines.globalFeatureIds.fill(indexMap.feature, indexMap.linePosition, indexMap.linePosition + nPositions);
    lines.featureIds.fill(indexMap.lineFeature, indexMap.linePosition, indexMap.linePosition + nPositions);
    for (let i = 0, il = geometry.indices.length; i < il; ++i) {
      const start = geometry.indices[i];
      const end = i === il - 1 ? geometry.data.length : geometry.indices[i + 1];
      lines.pathIndices[indexMap.linePath++] = indexMap.linePosition;
      indexMap.linePosition += (end - start) / coordLength;
    }
  }
  function handlePolygon(geometry, polygons, indexMap, coordLength, properties) {
    polygons.positions.set(geometry.data, indexMap.polygonPosition * coordLength);
    const nPositions = geometry.data.length / coordLength;
    fillNumericProperties(polygons, properties, indexMap.polygonPosition, nPositions);
    polygons.globalFeatureIds.fill(indexMap.feature, indexMap.polygonPosition, indexMap.polygonPosition + nPositions);
    polygons.featureIds.fill(indexMap.polygonFeature, indexMap.polygonPosition, indexMap.polygonPosition + nPositions);
    for (let l = 0, ll = geometry.indices.length; l < ll; ++l) {
      const startPosition = indexMap.polygonPosition;
      polygons.polygonIndices[indexMap.polygonObject++] = startPosition;
      const areas = geometry.areas[l];
      const indices = geometry.indices[l];
      const nextIndices = geometry.indices[l + 1];
      for (let i = 0, il = indices.length; i < il; ++i) {
        const start = indices[i];
        const end = i === il - 1 ? nextIndices === void 0 ? geometry.data.length : nextIndices[0] : indices[i + 1];
        polygons.primitivePolygonIndices[indexMap.polygonRing++] = indexMap.polygonPosition;
        indexMap.polygonPosition += (end - start) / coordLength;
      }
      const endPosition = indexMap.polygonPosition;
      triangulatePolygon(polygons, areas, indices, { startPosition, endPosition, coordLength });
    }
  }
  function triangulatePolygon(polygons, areas, indices, {
    startPosition,
    endPosition,
    coordLength
  }) {
    if (!polygons.triangles) {
      return;
    }
    const start = startPosition * coordLength;
    const end = endPosition * coordLength;
    const polygonPositions = polygons.positions.subarray(start, end);
    const offset = indices[0];
    const holes = indices.slice(1).map((n) => (n - offset) / coordLength);
    const triangles = earcut(polygonPositions, holes, coordLength, areas);
    for (let t = 0, tl = triangles.length; t < tl; ++t) {
      polygons.triangles.push(startPosition + triangles[t]);
    }
  }
  function wrapProps(obj, size) {
    const returnObj = {};
    for (const key in obj) {
      returnObj[key] = { value: obj[key], size };
    }
    return returnObj;
  }
  function makeAccessorObjects(points, lines, polygons, coordLength) {
    const binaryFeatures = {
      points: {
        ...points,
        positions: { value: points.positions, size: coordLength },
        globalFeatureIds: { value: points.globalFeatureIds, size: 1 },
        featureIds: { value: points.featureIds, size: 1 },
        numericProps: wrapProps(points.numericProps, 1)
      },
      lines: {
        ...lines,
        positions: { value: lines.positions, size: coordLength },
        pathIndices: { value: lines.pathIndices, size: 1 },
        globalFeatureIds: { value: lines.globalFeatureIds, size: 1 },
        featureIds: { value: lines.featureIds, size: 1 },
        numericProps: wrapProps(lines.numericProps, 1)
      },
      polygons: {
        ...polygons,
        positions: { value: polygons.positions, size: coordLength },
        polygonIndices: { value: polygons.polygonIndices, size: 1 },
        primitivePolygonIndices: { value: polygons.primitivePolygonIndices, size: 1 },
        globalFeatureIds: { value: polygons.globalFeatureIds, size: 1 },
        featureIds: { value: polygons.featureIds, size: 1 },
        numericProps: wrapProps(polygons.numericProps, 1)
      }
    };
    if (polygons.triangles) {
      binaryFeatures.polygons.triangles = { value: new Uint32Array(polygons.triangles), size: 1 };
    }
    return binaryFeatures;
  }
  function fillNumericProperties(object, properties, index, length) {
    for (const numericPropName in object.numericProps) {
      if (numericPropName in properties) {
        const value = properties[numericPropName];
        object.numericProps[numericPropName].fill(value, index, index + length);
      }
    }
  }
  function keepStringProperties(properties, numericKeys) {
    const props = {};
    for (const key in properties) {
      if (!numericKeys.includes(key)) {
        props[key] = properties[key];
      }
    }
    return props;
  }
  function deduceArrayType(x, constructor) {
    if (constructor === Array || !Number.isFinite(x)) {
      return Array;
    }
    return constructor === Float64Array || Math.fround(x) !== x ? Float64Array : Float32Array;
  }
  var init_flat_geojson_to_binary = __esm({
    "../gis/src/lib/flat-geojson-to-binary.ts"() {
      init_esm();
    }
  });

  // ../gis/src/lib/extract-geometry-info.ts
  function extractGeometryInfo(features) {
    let pointPositionsCount = 0;
    let pointFeaturesCount = 0;
    let linePositionsCount = 0;
    let linePathsCount = 0;
    let lineFeaturesCount = 0;
    let polygonPositionsCount = 0;
    let polygonObjectsCount = 0;
    let polygonRingsCount = 0;
    let polygonFeaturesCount = 0;
    const coordLengths = new Set();
    for (const feature of features) {
      const geometry = feature.geometry;
      switch (geometry.type) {
        case "Point":
          pointFeaturesCount++;
          pointPositionsCount++;
          coordLengths.add(geometry.coordinates.length);
          break;
        case "MultiPoint":
          pointFeaturesCount++;
          pointPositionsCount += geometry.coordinates.length;
          for (const point of geometry.coordinates) {
            coordLengths.add(point.length);
          }
          break;
        case "LineString":
          lineFeaturesCount++;
          linePositionsCount += geometry.coordinates.length;
          linePathsCount++;
          for (const coord2 of geometry.coordinates) {
            coordLengths.add(coord2.length);
          }
          break;
        case "MultiLineString":
          lineFeaturesCount++;
          for (const line of geometry.coordinates) {
            linePositionsCount += line.length;
            linePathsCount++;
            for (const coord2 of line) {
              coordLengths.add(coord2.length);
            }
          }
          break;
        case "Polygon":
          polygonFeaturesCount++;
          polygonObjectsCount++;
          polygonRingsCount += geometry.coordinates.length;
          const flattened = geometry.coordinates.flat();
          polygonPositionsCount += flattened.length;
          for (const coord2 of flattened) {
            coordLengths.add(coord2.length);
          }
          break;
        case "MultiPolygon":
          polygonFeaturesCount++;
          for (const polygon of geometry.coordinates) {
            polygonObjectsCount++;
            polygonRingsCount += polygon.length;
            const flattened2 = polygon.flat();
            polygonPositionsCount += flattened2.length;
            for (const coord2 of flattened2) {
              coordLengths.add(coord2.length);
            }
          }
          break;
        default:
          throw new Error(`Unsupported geometry type: ${geometry.type}`);
      }
    }
    return {
      coordLength: coordLengths.size > 0 ? Math.max(...coordLengths) : 2,
      pointPositionsCount,
      pointFeaturesCount,
      linePositionsCount,
      linePathsCount,
      lineFeaturesCount,
      polygonPositionsCount,
      polygonObjectsCount,
      polygonRingsCount,
      polygonFeaturesCount
    };
  }
  var init_extract_geometry_info = __esm({
    "../gis/src/lib/extract-geometry-info.ts"() {
    }
  });

  // ../gis/src/lib/geojson-to-flat-geojson.ts
  function geojsonToFlatGeojson(features, options = { coordLength: 2, fixRingWinding: true }) {
    return features.map((feature) => flattenFeature(feature, options));
  }
  function flattenPoint(coordinates, data, indices, options) {
    indices.push(data.length);
    data.push(...coordinates);
    for (let i = coordinates.length; i < options.coordLength; i++) {
      data.push(0);
    }
  }
  function flattenLineString(coordinates, data, indices, options) {
    indices.push(data.length);
    for (const c of coordinates) {
      data.push(...c);
      for (let i = c.length; i < options.coordLength; i++) {
        data.push(0);
      }
    }
  }
  function flattenPolygon(coordinates, data, indices, areas, options) {
    let count = 0;
    const ringAreas = [];
    const polygons = [];
    for (const lineString of coordinates) {
      const lineString2d = lineString.map((p) => p.slice(0, 2));
      let area2 = getPolygonSignedArea(lineString2d.flat());
      const ccw = area2 < 0;
      if (options.fixRingWinding && (count === 0 && !ccw || count > 0 && ccw)) {
        lineString.reverse();
        area2 = -area2;
      }
      ringAreas.push(area2);
      flattenLineString(lineString, data, polygons, options);
      count++;
    }
    if (count > 0) {
      areas.push(ringAreas);
      indices.push(polygons);
    }
  }
  function flattenFeature(feature, options) {
    const { geometry } = feature;
    if (geometry.type === "GeometryCollection") {
      throw new Error("GeometryCollection type not supported");
    }
    const data = [];
    const indices = [];
    let areas;
    let type;
    switch (geometry.type) {
      case "Point":
        type = "Point";
        flattenPoint(geometry.coordinates, data, indices, options);
        break;
      case "MultiPoint":
        type = "Point";
        geometry.coordinates.map((c) => flattenPoint(c, data, indices, options));
        break;
      case "LineString":
        type = "LineString";
        flattenLineString(geometry.coordinates, data, indices, options);
        break;
      case "MultiLineString":
        type = "LineString";
        geometry.coordinates.map((c) => flattenLineString(c, data, indices, options));
        break;
      case "Polygon":
        type = "Polygon";
        areas = [];
        flattenPolygon(geometry.coordinates, data, indices, areas, options);
        break;
      case "MultiPolygon":
        type = "Polygon";
        areas = [];
        geometry.coordinates.map((c) => flattenPolygon(c, data, indices, areas, options));
        break;
      default:
        throw new Error(`Unknown type: ${type}`);
    }
    return { ...feature, geometry: { type, indices, data, areas } };
  }
  var init_geojson_to_flat_geojson = __esm({
    "../gis/src/lib/geojson-to-flat-geojson.ts"() {
      init_esm();
    }
  });

  // ../gis/src/lib/geojson-to-binary.ts
  function geojsonToBinary(features, options = { fixRingWinding: true, triangulate: true }) {
    const geometryInfo = extractGeometryInfo(features);
    const coordLength = geometryInfo.coordLength;
    const { fixRingWinding } = options;
    const flatFeatures = geojsonToFlatGeojson(features, { coordLength, fixRingWinding });
    return flatGeojsonToBinary(flatFeatures, geometryInfo, {
      numericPropKeys: options.numericPropKeys,
      PositionDataType: options.PositionDataType || Float32Array,
      triangulate: options.triangulate
    });
  }
  var init_geojson_to_binary = __esm({
    "../gis/src/lib/geojson-to-binary.ts"() {
      init_extract_geometry_info();
      init_geojson_to_flat_geojson();
      init_flat_geojson_to_binary();
    }
  });

  // ../gis/src/index.ts
  var init_src = __esm({
    "../gis/src/index.ts"() {
      init_geojson_to_binary();
    }
  });

  // ../../node_modules/@tmcw/togeojson/dist/togeojson.es.js
  function nodeVal(x) {
    if (x && x.normalize) {
      x.normalize();
    }
    return x && x.textContent || "";
  }
  function get1(x, y) {
    const n = x.getElementsByTagName(y);
    return n.length ? n[0] : null;
  }
  function getLineStyle(extensions) {
    const style = {};
    if (extensions) {
      const lineStyle = get1(extensions, "line");
      if (lineStyle) {
        const color = nodeVal(get1(lineStyle, "color")), opacity = parseFloat(nodeVal(get1(lineStyle, "opacity"))), width = parseFloat(nodeVal(get1(lineStyle, "width")));
        if (color)
          style.stroke = color;
        if (!isNaN(opacity))
          style["stroke-opacity"] = opacity;
        if (!isNaN(width))
          style["stroke-width"] = width * 96 / 25.4;
      }
    }
    return style;
  }
  function getExtensions(node) {
    let values = [];
    if (node !== null) {
      for (let i = 0; i < node.childNodes.length; i++) {
        const child = node.childNodes[i];
        if (child.nodeType !== 1)
          continue;
        const name = ["heart", "gpxtpx:hr", "hr"].includes(child.nodeName) ? "heart" : child.nodeName;
        if (name === "gpxtpx:TrackPointExtension") {
          values = values.concat(getExtensions(child));
        } else {
          const val = nodeVal(child);
          values.push([name, isNaN(val) ? val : parseFloat(val)]);
        }
      }
    }
    return values;
  }
  function getMulti(x, ys) {
    const o = {};
    let n;
    let k;
    for (k = 0; k < ys.length; k++) {
      n = get1(x, ys[k]);
      if (n)
        o[ys[k]] = nodeVal(n);
    }
    return o;
  }
  function getProperties$1(node) {
    const prop = getMulti(node, [
      "name",
      "cmt",
      "desc",
      "type",
      "time",
      "keywords"
    ]);
    const extensions = node.getElementsByTagNameNS("http://www.garmin.com/xmlschemas/GpxExtensions/v3", "*");
    for (let i = 0; i < extensions.length; i++) {
      const extension = extensions[i];
      if (extension.parentNode.parentNode === node) {
        prop[extension.tagName.replace(":", "_")] = nodeVal(extension);
      }
    }
    const links = node.getElementsByTagName("link");
    if (links.length)
      prop.links = [];
    for (let i = 0; i < links.length; i++) {
      prop.links.push(Object.assign({ href: links[i].getAttribute("href") }, getMulti(links[i], ["text", "type"])));
    }
    return prop;
  }
  function coordPair$1(x) {
    const ll = [
      parseFloat(x.getAttribute("lon")),
      parseFloat(x.getAttribute("lat"))
    ];
    const ele = get1(x, "ele");
    const time = get1(x, "time");
    if (ele) {
      const e = parseFloat(nodeVal(ele));
      if (!isNaN(e)) {
        ll.push(e);
      }
    }
    return {
      coordinates: ll,
      time: time ? nodeVal(time) : null,
      extendedValues: getExtensions(get1(x, "extensions"))
    };
  }
  function getRoute(node) {
    const line = getPoints$1(node, "rtept");
    if (!line)
      return;
    return {
      type: "Feature",
      properties: Object.assign(getProperties$1(node), getLineStyle(get1(node, "extensions")), { _gpxType: "rte" }),
      geometry: {
        type: "LineString",
        coordinates: line.line
      }
    };
  }
  function getPoints$1(node, pointname) {
    const pts = node.getElementsByTagName(pointname);
    if (pts.length < 2)
      return;
    const line = [];
    const times = [];
    const extendedValues = {};
    for (let i = 0; i < pts.length; i++) {
      const c = coordPair$1(pts[i]);
      line.push(c.coordinates);
      if (c.time)
        times.push(c.time);
      for (let j = 0; j < c.extendedValues.length; j++) {
        const [name, val] = c.extendedValues[j];
        const plural = name === "heart" ? name : name.replace("gpxtpx:", "") + "s";
        if (!extendedValues[plural]) {
          extendedValues[plural] = Array(pts.length).fill(null);
        }
        extendedValues[plural][i] = val;
      }
    }
    return {
      line,
      times,
      extendedValues
    };
  }
  function getTrack(node) {
    const segments = node.getElementsByTagName("trkseg");
    const track = [];
    const times = [];
    const extractedLines = [];
    for (let i = 0; i < segments.length; i++) {
      const line = getPoints$1(segments[i], "trkpt");
      if (line) {
        extractedLines.push(line);
        if (line.times && line.times.length)
          times.push(line.times);
      }
    }
    if (extractedLines.length === 0)
      return;
    const multi = extractedLines.length > 1;
    const properties = Object.assign(getProperties$1(node), getLineStyle(get1(node, "extensions")), { _gpxType: "trk" }, times.length ? {
      coordinateProperties: {
        times: multi ? times : times[0]
      }
    } : {});
    for (let i = 0; i < extractedLines.length; i++) {
      const line = extractedLines[i];
      track.push(line.line);
      for (const [name, val] of Object.entries(line.extendedValues)) {
        if (!properties.coordinateProperties) {
          properties.coordinateProperties = {};
        }
        const props = properties.coordinateProperties;
        if (multi) {
          if (!props[name])
            props[name] = extractedLines.map((line2) => new Array(line2.line.length).fill(null));
          props[name][i] = val;
        } else {
          props[name] = val;
        }
      }
    }
    return {
      type: "Feature",
      properties,
      geometry: multi ? {
        type: "MultiLineString",
        coordinates: track
      } : {
        type: "LineString",
        coordinates: track[0]
      }
    };
  }
  function getPoint(node) {
    return {
      type: "Feature",
      properties: Object.assign(getProperties$1(node), getMulti(node, ["sym"])),
      geometry: {
        type: "Point",
        coordinates: coordPair$1(node).coordinates
      }
    };
  }
  function* gpxGen(doc) {
    const tracks = doc.getElementsByTagName("trk");
    const routes = doc.getElementsByTagName("rte");
    const waypoints = doc.getElementsByTagName("wpt");
    for (let i = 0; i < tracks.length; i++) {
      const feature = getTrack(tracks[i]);
      if (feature)
        yield feature;
    }
    for (let i = 0; i < routes.length; i++) {
      const feature = getRoute(routes[i]);
      if (feature)
        yield feature;
    }
    for (let i = 0; i < waypoints.length; i++) {
      yield getPoint(waypoints[i]);
    }
  }
  function gpx(doc) {
    return {
      type: "FeatureCollection",
      features: Array.from(gpxGen(doc))
    };
  }
  function fromEntries(arr) {
    const obj = {};
    for (const [key, value] of arr) {
      obj[key] = value;
    }
    return obj;
  }
  function getProperties(node, attributeNames) {
    const properties = [];
    for (const [tag, alias] of attributeNames) {
      let elem = get1(node, tag);
      if (!elem) {
        const elements = node.getElementsByTagNameNS(EXTENSIONS_NS, tag);
        if (elements.length) {
          elem = elements[0];
        }
      }
      const val = parseFloat(nodeVal(elem));
      if (!isNaN(val)) {
        properties.push([alias, val]);
      }
    }
    return properties;
  }
  function coordPair(x) {
    const lon = nodeVal(get1(x, "LongitudeDegrees"));
    const lat = nodeVal(get1(x, "LatitudeDegrees"));
    if (!lon.length || !lat.length) {
      return null;
    }
    const ll = [parseFloat(lon), parseFloat(lat)];
    const alt = get1(x, "AltitudeMeters");
    const heartRate = get1(x, "HeartRateBpm");
    const time = get1(x, "Time");
    let a;
    if (alt) {
      a = parseFloat(nodeVal(alt));
      if (!isNaN(a)) {
        ll.push(a);
      }
    }
    return {
      coordinates: ll,
      time: time ? nodeVal(time) : null,
      heartRate: heartRate ? parseFloat(nodeVal(heartRate)) : null,
      extensions: getProperties(x, TRACKPOINT_ATTRIBUTES)
    };
  }
  function getPoints(node, pointname) {
    const pts = node.getElementsByTagName(pointname);
    const line = [];
    const times = [];
    const heartRates = [];
    if (pts.length < 2)
      return null;
    const result = { extendedProperties: {} };
    for (let i = 0; i < pts.length; i++) {
      const c = coordPair(pts[i]);
      if (c === null)
        continue;
      line.push(c.coordinates);
      if (c.time)
        times.push(c.time);
      if (c.heartRate)
        heartRates.push(c.heartRate);
      for (const [alias, value] of c.extensions) {
        if (!result.extendedProperties[alias]) {
          result.extendedProperties[alias] = Array(pts.length).fill(null);
        }
        result.extendedProperties[alias][i] = value;
      }
    }
    return Object.assign(result, {
      line,
      times,
      heartRates
    });
  }
  function getLap(node) {
    const segments = node.getElementsByTagName("Track");
    const track = [];
    const times = [];
    const heartRates = [];
    const allExtendedProperties = [];
    let line;
    const properties = fromEntries(getProperties(node, LAP_ATTRIBUTES));
    const nameElement = get1(node, "Name");
    if (nameElement) {
      properties.name = nodeVal(nameElement);
    }
    for (let i = 0; i < segments.length; i++) {
      line = getPoints(segments[i], "Trackpoint");
      if (line) {
        track.push(line.line);
        if (line.times.length)
          times.push(line.times);
        if (line.heartRates.length)
          heartRates.push(line.heartRates);
        allExtendedProperties.push(line.extendedProperties);
      }
    }
    for (let i = 0; i < allExtendedProperties.length; i++) {
      const extendedProperties = allExtendedProperties[i];
      for (const property in extendedProperties) {
        if (segments.length === 1) {
          properties[property] = line.extendedProperties[property];
        } else {
          if (!properties[property]) {
            properties[property] = track.map((track2) => Array(track2.length).fill(null));
          }
          properties[property][i] = extendedProperties[property];
        }
      }
    }
    if (track.length === 0)
      return;
    if (times.length || heartRates.length) {
      properties.coordinateProperties = Object.assign(times.length ? {
        times: track.length === 1 ? times[0] : times
      } : {}, heartRates.length ? {
        heart: track.length === 1 ? heartRates[0] : heartRates
      } : {});
    }
    return {
      type: "Feature",
      properties,
      geometry: {
        type: track.length === 1 ? "LineString" : "MultiLineString",
        coordinates: track.length === 1 ? track[0] : track
      }
    };
  }
  function* tcxGen(doc) {
    const laps = doc.getElementsByTagName("Lap");
    for (let i = 0; i < laps.length; i++) {
      const feature = getLap(laps[i]);
      if (feature)
        yield feature;
    }
    const courses = doc.getElementsByTagName("Courses");
    for (let i = 0; i < courses.length; i++) {
      const feature = getLap(courses[i]);
      if (feature)
        yield feature;
    }
  }
  function tcx(doc) {
    return {
      type: "FeatureCollection",
      features: Array.from(tcxGen(doc))
    };
  }
  function okhash(x) {
    if (!x || !x.length)
      return 0;
    let h = 0;
    for (let i = 0; i < x.length; i++) {
      h = (h << 5) - h + x.charCodeAt(i) | 0;
    }
    return h;
  }
  function coord1(v) {
    return v.replace(removeSpace, "").split(",").map(parseFloat);
  }
  function coord(v) {
    return v.replace(trimSpace, "").split(splitSpace).map(coord1);
  }
  function xml2str(node) {
    if (node.xml !== void 0)
      return node.xml;
    if (node.tagName) {
      let output = node.tagName;
      for (let i = 0; i < node.attributes.length; i++) {
        output += node.attributes[i].name + node.attributes[i].value;
      }
      for (let i = 0; i < node.childNodes.length; i++) {
        output += xml2str(node.childNodes[i]);
      }
      return output;
    }
    if (node.nodeName === "#text") {
      return (node.nodeValue || node.value || "").trim();
    }
    if (node.nodeName === "#cdata-section") {
      return node.nodeValue;
    }
    return "";
  }
  function kmlColor(properties, elem, prefix) {
    let v = nodeVal(get1(elem, "color")) || "";
    const colorProp = prefix == "stroke" || prefix === "fill" ? prefix : prefix + "-color";
    if (v.substr(0, 1) === "#") {
      v = v.substr(1);
    }
    if (v.length === 6 || v.length === 3) {
      properties[colorProp] = v;
    } else if (v.length === 8) {
      properties[prefix + "-opacity"] = parseInt(v.substr(0, 2), 16) / 255;
      properties[colorProp] = "#" + v.substr(6, 2) + v.substr(4, 2) + v.substr(2, 2);
    }
  }
  function numericProperty(properties, elem, source, target) {
    const val = parseFloat(nodeVal(get1(elem, source)));
    if (!isNaN(val))
      properties[target] = val;
  }
  function gxCoords(root) {
    let elems = root.getElementsByTagName("coord");
    const coords = [];
    const times = [];
    if (elems.length === 0)
      elems = root.getElementsByTagName("gx:coord");
    for (let i = 0; i < elems.length; i++) {
      coords.push(nodeVal(elems[i]).split(" ").map(parseFloat));
    }
    const timeElems = root.getElementsByTagName("when");
    for (let j = 0; j < timeElems.length; j++)
      times.push(nodeVal(timeElems[j]));
    return {
      coords,
      times
    };
  }
  function getGeometry(root) {
    let geomNode;
    let geomNodes;
    let i;
    let j;
    let k;
    const geoms = [];
    const coordTimes = [];
    if (get1(root, "MultiGeometry")) {
      return getGeometry(get1(root, "MultiGeometry"));
    }
    if (get1(root, "MultiTrack")) {
      return getGeometry(get1(root, "MultiTrack"));
    }
    if (get1(root, "gx:MultiTrack")) {
      return getGeometry(get1(root, "gx:MultiTrack"));
    }
    for (i = 0; i < geotypes.length; i++) {
      geomNodes = root.getElementsByTagName(geotypes[i]);
      if (geomNodes) {
        for (j = 0; j < geomNodes.length; j++) {
          geomNode = geomNodes[j];
          if (geotypes[i] === "Point") {
            geoms.push({
              type: "Point",
              coordinates: coord1(nodeVal(get1(geomNode, "coordinates")))
            });
          } else if (geotypes[i] === "LineString") {
            geoms.push({
              type: "LineString",
              coordinates: coord(nodeVal(get1(geomNode, "coordinates")))
            });
          } else if (geotypes[i] === "Polygon") {
            const rings = geomNode.getElementsByTagName("LinearRing"), coords = [];
            for (k = 0; k < rings.length; k++) {
              coords.push(coord(nodeVal(get1(rings[k], "coordinates"))));
            }
            geoms.push({
              type: "Polygon",
              coordinates: coords
            });
          } else if (geotypes[i] === "Track" || geotypes[i] === "gx:Track") {
            const track = gxCoords(geomNode);
            geoms.push({
              type: "LineString",
              coordinates: track.coords
            });
            if (track.times.length)
              coordTimes.push(track.times);
          }
        }
      }
    }
    return {
      geoms,
      coordTimes
    };
  }
  function getPlacemark(root, styleIndex, styleMapIndex, styleByHash) {
    const geomsAndTimes = getGeometry(root);
    let i;
    const properties = {};
    const name = nodeVal(get1(root, "name"));
    const address = nodeVal(get1(root, "address"));
    let styleUrl = nodeVal(get1(root, "styleUrl"));
    const description = nodeVal(get1(root, "description"));
    const timeSpan = get1(root, "TimeSpan");
    const timeStamp = get1(root, "TimeStamp");
    const extendedData = get1(root, "ExtendedData");
    let iconStyle = get1(root, "IconStyle");
    let labelStyle = get1(root, "LabelStyle");
    let lineStyle = get1(root, "LineStyle");
    let polyStyle = get1(root, "PolyStyle");
    const visibility = get1(root, "visibility");
    if (name)
      properties.name = name;
    if (address)
      properties.address = address;
    if (styleUrl) {
      if (styleUrl[0] !== "#") {
        styleUrl = "#" + styleUrl;
      }
      properties.styleUrl = styleUrl;
      if (styleIndex[styleUrl]) {
        properties.styleHash = styleIndex[styleUrl];
      }
      if (styleMapIndex[styleUrl]) {
        properties.styleMapHash = styleMapIndex[styleUrl];
        properties.styleHash = styleIndex[styleMapIndex[styleUrl].normal];
      }
      const style = styleByHash[properties.styleHash];
      if (style) {
        if (!iconStyle)
          iconStyle = get1(style, "IconStyle");
        if (!labelStyle)
          labelStyle = get1(style, "LabelStyle");
        if (!lineStyle)
          lineStyle = get1(style, "LineStyle");
        if (!polyStyle)
          polyStyle = get1(style, "PolyStyle");
      }
    }
    if (description)
      properties.description = description;
    if (timeSpan) {
      const begin = nodeVal(get1(timeSpan, "begin"));
      const end = nodeVal(get1(timeSpan, "end"));
      properties.timespan = { begin, end };
    }
    if (timeStamp) {
      properties.timestamp = nodeVal(get1(timeStamp, "when"));
    }
    if (iconStyle) {
      kmlColor(properties, iconStyle, "icon");
      numericProperty(properties, iconStyle, "scale", "icon-scale");
      numericProperty(properties, iconStyle, "heading", "icon-heading");
      const hotspot = get1(iconStyle, "hotSpot");
      if (hotspot) {
        const left = parseFloat(hotspot.getAttribute("x"));
        const top = parseFloat(hotspot.getAttribute("y"));
        if (!isNaN(left) && !isNaN(top))
          properties["icon-offset"] = [left, top];
      }
      const icon = get1(iconStyle, "Icon");
      if (icon) {
        const href = nodeVal(get1(icon, "href"));
        if (href)
          properties.icon = href;
      }
    }
    if (labelStyle) {
      kmlColor(properties, labelStyle, "label");
      numericProperty(properties, labelStyle, "scale", "label-scale");
    }
    if (lineStyle) {
      kmlColor(properties, lineStyle, "stroke");
      numericProperty(properties, lineStyle, "width", "stroke-width");
    }
    if (polyStyle) {
      kmlColor(properties, polyStyle, "fill");
      const fill = nodeVal(get1(polyStyle, "fill"));
      const outline = nodeVal(get1(polyStyle, "outline"));
      if (fill)
        properties["fill-opacity"] = fill === "1" ? properties["fill-opacity"] || 1 : 0;
      if (outline)
        properties["stroke-opacity"] = outline === "1" ? properties["stroke-opacity"] || 1 : 0;
    }
    if (extendedData) {
      const datas = extendedData.getElementsByTagName("Data"), simpleDatas = extendedData.getElementsByTagName("SimpleData");
      for (i = 0; i < datas.length; i++) {
        properties[datas[i].getAttribute("name")] = nodeVal(get1(datas[i], "value"));
      }
      for (i = 0; i < simpleDatas.length; i++) {
        properties[simpleDatas[i].getAttribute("name")] = nodeVal(simpleDatas[i]);
      }
    }
    if (visibility) {
      properties.visibility = nodeVal(visibility);
    }
    if (geomsAndTimes.coordTimes.length) {
      properties.coordinateProperties = {
        times: geomsAndTimes.coordTimes.length === 1 ? geomsAndTimes.coordTimes[0] : geomsAndTimes.coordTimes
      };
    }
    const feature = {
      type: "Feature",
      geometry: geomsAndTimes.geoms.length === 0 ? null : geomsAndTimes.geoms.length === 1 ? geomsAndTimes.geoms[0] : {
        type: "GeometryCollection",
        geometries: geomsAndTimes.geoms
      },
      properties
    };
    if (root.getAttribute("id"))
      feature.id = root.getAttribute("id");
    return feature;
  }
  function* kmlGen(doc) {
    const styleIndex = {};
    const styleByHash = {};
    const styleMapIndex = {};
    const placemarks = doc.getElementsByTagName("Placemark");
    const styles = doc.getElementsByTagName("Style");
    const styleMaps = doc.getElementsByTagName("StyleMap");
    for (let k = 0; k < styles.length; k++) {
      const style = styles[k];
      const hash = okhash(xml2str(style)).toString(16);
      let id = style.getAttribute("id");
      if (!id && style.parentNode.tagName.replace("gx:", "") === "CascadingStyle") {
        id = style.parentNode.getAttribute("kml:id") || style.parentNode.getAttribute("id");
      }
      styleIndex["#" + id] = hash;
      styleByHash[hash] = style;
    }
    for (let l = 0; l < styleMaps.length; l++) {
      styleIndex["#" + styleMaps[l].getAttribute("id")] = okhash(xml2str(styleMaps[l])).toString(16);
      const pairs = styleMaps[l].getElementsByTagName("Pair");
      const pairsMap = {};
      for (let m = 0; m < pairs.length; m++) {
        pairsMap[nodeVal(get1(pairs[m], "key"))] = nodeVal(get1(pairs[m], "styleUrl"));
      }
      styleMapIndex["#" + styleMaps[l].getAttribute("id")] = pairsMap;
    }
    for (let j = 0; j < placemarks.length; j++) {
      const feature = getPlacemark(placemarks[j], styleIndex, styleMapIndex, styleByHash);
      if (feature)
        yield feature;
    }
  }
  function kml(doc) {
    return {
      type: "FeatureCollection",
      features: Array.from(kmlGen(doc))
    };
  }
  var EXTENSIONS_NS, TRACKPOINT_ATTRIBUTES, LAP_ATTRIBUTES, removeSpace, trimSpace, splitSpace, geotypes;
  var init_togeojson_es = __esm({
    "../../node_modules/@tmcw/togeojson/dist/togeojson.es.js"() {
      EXTENSIONS_NS = "http://www.garmin.com/xmlschemas/ActivityExtension/v2";
      TRACKPOINT_ATTRIBUTES = [
        ["heartRate", "heartRates"],
        ["Cadence", "cadences"],
        ["Speed", "speeds"],
        ["Watts", "watts"]
      ];
      LAP_ATTRIBUTES = [
        ["TotalTimeSeconds", "totalTimeSeconds"],
        ["DistanceMeters", "distanceMeters"],
        ["MaximumSpeed", "maxSpeed"],
        ["AverageHeartRateBpm", "avgHeartRate"],
        ["MaximumHeartRateBpm", "maxHeartRate"],
        ["AvgSpeed", "avgSpeed"],
        ["AvgWatts", "avgWatts"],
        ["MaxWatts", "maxWatts"]
      ];
      removeSpace = /\s*/g;
      trimSpace = /^\s*|\s*$/g;
      splitSpace = /\s+/;
      geotypes = ["Polygon", "LineString", "Point", "Track", "gx:Track"];
    }
  });

  // src/gpx-loader.ts
  function parseTextSync(text, options) {
    const doc = new DOMParser().parseFromString(text, "text/xml");
    const geojson = gpx(doc);
    const shape = options?.gis?.format || options?.gpx?.type || options?.gpx?.shape;
    switch (shape) {
      case "object-row-table": {
        const table = {
          shape: "object-row-table",
          data: geojson.features
        };
        return table;
      }
      case "geojson-row-table": {
        const table = {
          shape: "geojson-row-table",
          data: geojson.features
        };
        return table;
      }
      case "geojson":
        return geojson;
      case "binary":
        return geojsonToBinary(geojson.features);
      case "raw":
        return doc;
      default:
        return geojson;
    }
  }
  var VERSION, GPX_HEADER, GPXLoader;
  var init_gpx_loader = __esm({
    "src/gpx-loader.ts"() {
      init_src();
      init_togeojson_es();
      VERSION = typeof __VERSION__ !== "undefined" ? __VERSION__ : "latest";
      GPX_HEADER = `<?xml version="1.0" encoding="UTF-8"?>
<gpx`;
      GPXLoader = {
        name: "GPX (GPS exchange format)",
        id: "gpx",
        module: "kml",
        version: VERSION,
        extensions: ["gpx"],
        mimeTypes: ["application/gpx+xml"],
        text: true,
        tests: [GPX_HEADER],
        parse: async (arrayBuffer, options) => parseTextSync(new TextDecoder().decode(arrayBuffer), options),
        parseTextSync,
        options: {
          gpx: {},
          gis: {}
        }
      };
    }
  });

  // src/kml-loader.ts
  function parseTextSync2(text, options) {
    const doc = new DOMParser().parseFromString(text, "text/xml");
    const geojson = kml(doc);
    const shape = options?.gis?.format || options?.kml?.type || options?.kml?.shape;
    switch (shape) {
      case "object-row-table": {
        const table = {
          shape: "object-row-table",
          data: geojson.features
        };
        return table;
      }
      case "geojson-row-table": {
        const table = {
          shape: "geojson-row-table",
          data: geojson.features
        };
        return table;
      }
      case "geojson":
        return geojson;
      case "binary":
        return geojsonToBinary(geojson.features);
      case "raw":
        return doc;
      default:
        return geojson;
    }
  }
  var VERSION2, KML_HEADER, KMLLoader;
  var init_kml_loader = __esm({
    "src/kml-loader.ts"() {
      init_src();
      init_togeojson_es();
      VERSION2 = typeof __VERSION__ !== "undefined" ? __VERSION__ : "latest";
      KML_HEADER = `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">`;
      KMLLoader = {
        name: "KML (Keyhole Markup Language)",
        id: "kml",
        module: "kml",
        version: VERSION2,
        extensions: ["kml"],
        mimeTypes: ["application/vnd.google-earth.kml+xml"],
        text: true,
        tests: [KML_HEADER],
        parse: async (arrayBuffer, options) => parseTextSync2(new TextDecoder().decode(arrayBuffer), options),
        parseTextSync: parseTextSync2,
        options: {
          kml: {},
          gis: {}
        }
      };
    }
  });

  // src/tcx-loader.ts
  function parseTextSync3(text, options) {
    const doc = new DOMParser().parseFromString(text, "text/xml");
    const geojson = tcx(doc);
    const shape = options?.gis?.format || options?.tcx?.type || options?.tcx?.shape;
    switch (shape) {
      case "object-row-table": {
        const table = {
          shape: "object-row-table",
          data: geojson.features
        };
        return table;
      }
      case "geojson-row-table": {
        const table = {
          shape: "geojson-row-table",
          data: geojson.features
        };
        return table;
      }
      case "geojson":
        return geojson;
      case "binary":
        return geojsonToBinary(geojson.features);
      case "raw":
        return doc;
      default:
        return geojson;
    }
  }
  var VERSION3, TCX_HEADER, TCXLoader;
  var init_tcx_loader = __esm({
    "src/tcx-loader.ts"() {
      init_src();
      init_togeojson_es();
      VERSION3 = typeof __VERSION__ !== "undefined" ? __VERSION__ : "latest";
      TCX_HEADER = `<?xml version="1.0" encoding="UTF-8"?>
<TrainingCenterDatabase`;
      TCXLoader = {
        name: "TCX (Training Center XML)",
        id: "tcx",
        module: "kml",
        version: VERSION3,
        extensions: ["tcx"],
        mimeTypes: ["application/vnd.garmin.tcx+xml"],
        text: true,
        tests: [TCX_HEADER],
        parse: async (arrayBuffer, options) => parseTextSync3(new TextDecoder().decode(arrayBuffer), options),
        parseTextSync: parseTextSync3,
        options: {
          tcx: {},
          gis: {}
        }
      };
    }
  });

  // src/index.ts
  var src_exports = {};
  __export(src_exports, {
    GPXLoader: () => GPXLoader,
    KMLLoader: () => KMLLoader,
    TCXLoader: () => TCXLoader
  });
  var init_src2 = __esm({
    "src/index.ts"() {
      init_gpx_loader();
      init_kml_loader();
      init_tcx_loader();
    }
  });

  // src/bundle.ts
  var require_bundle = __commonJS({
    "src/bundle.ts"(exports, module) {
      var moduleExports = (init_src2(), src_exports);
      globalThis.loaders = globalThis.loaders || {};
      module.exports = Object.assign(globalThis.loaders, moduleExports);
    }
  });
  require_bundle();
})();
