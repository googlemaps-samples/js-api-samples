{
  "version": 3,
  "sources": ["../../@loaders.gl/loader-utils/src/lib/env-utils/assert.ts", "../../@loaders.gl/loader-utils/src/lib/env-utils/globals.ts", "../../@loaders.gl/worker-utils/src/lib/env-utils/version.ts", "../../@loaders.gl/worker-utils/src/lib/env-utils/assert.ts", "../../@loaders.gl/worker-utils/src/lib/env-utils/globals.ts", "../../@loaders.gl/worker-utils/src/lib/worker-farm/worker-job.ts", "../../@loaders.gl/worker-utils/src/lib/node/worker_threads-browser.ts", "../../@loaders.gl/worker-utils/src/lib/worker-utils/get-loadable-worker-url.ts", "../../@loaders.gl/worker-utils/src/lib/worker-utils/get-transfer-list.ts", "../../@loaders.gl/worker-utils/src/lib/worker-farm/worker-thread.ts", "../../@loaders.gl/worker-utils/src/lib/worker-farm/worker-pool.ts", "../../@loaders.gl/worker-utils/src/lib/worker-farm/worker-farm.ts", "../../@loaders.gl/worker-utils/src/lib/worker-farm/worker-body.ts", "../../@loaders.gl/worker-utils/src/lib/worker-api/get-worker-url.ts", "../../@loaders.gl/worker-utils/src/lib/worker-api/process-on-worker.ts", "../../@loaders.gl/worker-utils/src/lib/async-queue/async-queue.ts", "../../@loaders.gl/worker-utils/src/lib/worker-api/validate-worker-version.ts", "../../@loaders.gl/worker-utils/src/index.ts", "../../@loaders.gl/loader-utils/src/lib/worker-loader-utils/parse-with-worker.ts", "../../@loaders.gl/loader-utils/src/lib/worker-loader-utils/encode-with-worker.ts", "../../@loaders.gl/loader-utils/src/lib/binary-utils/array-buffer-utils.ts", "../../@loaders.gl/loader-utils/src/lib/iterators/text-iterators.ts", "../../@loaders.gl/loader-utils/src/lib/iterators/async-iteration.ts", "../../@probe.gl/stats/src/utils/hi-res-timestamp.ts", "../../@probe.gl/stats/src/lib/stat.ts", "../../@probe.gl/stats/src/lib/stats.ts", "../../@loaders.gl/loader-utils/src/lib/request-utils/request-scheduler.ts", "../../@loaders.gl/loader-utils/src/lib/path-utils/file-aliases.ts", "../../@loaders.gl/loader-utils/src/json-loader.ts", "../../@loaders.gl/loader-utils/src/lib/node/buffer.browser.ts", "../../@loaders.gl/loader-utils/src/lib/binary-utils/memory-conversion-utils.ts", "../../@loaders.gl/loader-utils/src/lib/path-utils/path.ts", "../../@loaders.gl/loader-utils/src/lib/path-utils/get-cwd.ts", "../../@loaders.gl/loader-utils/src/lib/node/fs.browser.ts", "../../@loaders.gl/core/src/javascript-utils/is-type.ts", "../../@loaders.gl/core/src/lib/utils/mime-type-utils.ts", "../../@loaders.gl/core/src/lib/utils/url-utils.ts", "../../@loaders.gl/core/src/lib/utils/resource-utils.ts", "../../@loaders.gl/core/src/lib/utils/response-utils.ts", "../../@loaders.gl/core/src/lib/fetch/fetch-file.ts", "../../@loaders.gl/core/src/lib/fetch/read-array-buffer.ts", "../../@loaders.gl/core/src/lib/fetch/read-file.ts", "../../@loaders.gl/core/src/lib/fetch/write-file.ts", "../../@probe.gl/env/src/lib/is-electron.ts", "../../@probe.gl/env/src/lib/is-browser.ts", "../../@probe.gl/env/src/lib/globals.ts", "../../@probe.gl/env/src/utils/globals.ts", "../../@probe.gl/env/src/lib/get-browser.ts", "../../@probe.gl/log/src/utils/local-storage.ts", "../../@probe.gl/log/src/utils/formatters.ts", "../../@probe.gl/log/src/utils/color.ts", "../../@probe.gl/log/src/utils/autobind.ts", "../../@probe.gl/log/src/utils/assert.ts", "../../@probe.gl/log/src/utils/hi-res-timestamp.ts", "../../@probe.gl/log/src/log.ts", "../../@probe.gl/log/src/init.js", "../../@probe.gl/log/src/index.ts", "../../@loaders.gl/core/src/lib/loader-utils/loggers.ts", "../../@loaders.gl/core/src/lib/loader-utils/option-defaults.ts", "../../@loaders.gl/core/src/lib/loader-utils/option-utils.ts", "../../@loaders.gl/core/src/lib/loader-utils/normalize-loader.ts", "../../@loaders.gl/core/src/lib/api/register-loaders.ts", "../../@loaders.gl/core/src/lib/utils/log.ts", "../../@loaders.gl/core/src/lib/api/select-loader.ts", "../../@loaders.gl/core/src/iterators/make-iterator/make-string-iterator.ts", "../../@loaders.gl/core/src/iterators/make-iterator/make-array-buffer-iterator.ts", "../../@loaders.gl/core/src/iterators/make-iterator/make-blob-iterator.ts", "../../@loaders.gl/core/src/iterators/make-iterator/make-stream-iterator.ts", "../../@loaders.gl/core/src/iterators/make-iterator/make-iterator.ts", "../../@loaders.gl/core/src/lib/loader-utils/get-data.ts", "../../@loaders.gl/core/src/lib/loader-utils/get-fetch-function.ts", "../../@loaders.gl/core/src/lib/loader-utils/loader-context.ts", "../../@loaders.gl/core/src/lib/api/parse.ts", "../../@loaders.gl/core/src/lib/api/parse-sync.ts", "../../@loaders.gl/core/src/lib/api/parse-in-batches.ts", "../../@loaders.gl/core/src/lib/api/load.ts", "../../@loaders.gl/core/src/lib/api/load-in-batches.ts", "../../@loaders.gl/core/src/lib/api/encode.ts", "../../@loaders.gl/core/src/lib/api/save.ts", "../../@loaders.gl/core/src/iterators/make-stream/make-dom-stream.ts", "../../@loaders.gl/core/src/null-loader.ts", "../../@loaders.gl/core/src/lib/progress/fetch-progress.ts", "../../@loaders.gl/core/src/lib/filesystems/browser-filesystem.ts"],
  "sourcesContent": ["/**\n * Throws an `Error` with the optional `message` if `condition` is falsy\n * @note Replacement for the external assert method to reduce bundle size\n */\nexport function assert(condition: any, message?: string): void {\n  if (!condition) {\n    throw new Error(message || 'loader assertion failed.');\n  }\n}\n", "// Purpose: include this in your module to avoid\n// dependencies on micro modules like 'global' and 'is-browser';\n\n/* eslint-disable no-restricted-globals */\nconst globals = {\n  self: typeof self !== 'undefined' && self,\n  window: typeof window !== 'undefined' && window,\n  global: typeof global !== 'undefined' && global,\n  document: typeof document !== 'undefined' && document\n};\n\ntype obj = {[key: string]: any};\nconst self_: obj = globals.self || globals.window || globals.global || {};\nconst window_: obj = globals.window || globals.self || globals.global || {};\nconst global_: obj = globals.global || globals.self || globals.window || {};\nconst document_: obj = globals.document || {};\n\nexport {self_ as self, window_ as window, global_ as global, document_ as document};\n\n/** true if running in a browser */\nexport const isBrowser: boolean =\n  // @ts-ignore process does not exist on browser\n  Boolean(typeof process !== 'object' || String(process) !== '[object process]' || process.browser);\n\n/** true if running in a worker thread */\nexport const isWorker: boolean = typeof importScripts === 'function';\n\n// Extract node major version\nconst matches =\n  typeof process !== 'undefined' && process.version && /v([0-9]*)/.exec(process.version);\n/** Major Node version (as a number) */\nexport const nodeVersion: number = (matches && parseFloat(matches[1])) || 0;\n", "// Version constant cannot be imported, it needs to correspond to the build version of **this** module.\n// __VERSION__ is injected by babel-plugin-version-inline\n\n// Change to `latest` on production branches\nconst DEFAULT_VERSION = 'latest';\ndeclare let __VERSION__: string;\nexport const VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : DEFAULT_VERSION;\nif (typeof __VERSION__ === 'undefined') {\n  // eslint-disable-next-line\n  console.error(\n    'loaders.gl: The __VERSION__ variable is not injected using babel plugin. Latest unstable workers would be fetched from the CDN.'\n  );\n}\n", "// Replacement for the external assert method to reduce bundle size\n// Note: We don't use the second \"message\" argument in calling code,\n// so no need to support it here\n\n/** Throws an `Error` with the optional `message` if `condition` is falsy */\nexport function assert(condition: any, message?: string): void {\n  if (!condition) {\n    throw new Error(message || 'loaders.gl assertion failed.');\n  }\n}\n", "// Purpose: include this in your module to avoids adding dependencies on\n// micro modules like 'global' and 'is-browser';\n\n/* eslint-disable no-restricted-globals */\nconst globals = {\n  self: typeof self !== 'undefined' && self,\n  window: typeof window !== 'undefined' && window,\n  global: typeof global !== 'undefined' && global,\n  document: typeof document !== 'undefined' && document\n};\n\nconst self_: {[key: string]: any} = globals.self || globals.window || globals.global || {};\nconst window_: {[key: string]: any} = globals.window || globals.self || globals.global || {};\nconst global_: {[key: string]: any} = globals.global || globals.self || globals.window || {};\nconst document_: {[key: string]: any} = globals.document || {};\n\nexport {self_ as self, window_ as window, global_ as global, document_ as document};\n\n/** true if running in the browser, false if running in Node.js */\nexport const isBrowser: boolean =\n  // @ts-ignore process.browser\n  typeof process !== 'object' || String(process) !== '[object process]' || process.browser;\n\n/** true if running on a worker thread */\nexport const isWorker: boolean = typeof importScripts === 'function';\n\n/** true if running on a mobile device */\nexport const isMobile: boolean =\n  typeof window !== 'undefined' && typeof window.orientation !== 'undefined';\n\n// Extract node major version\nconst matches =\n  typeof process !== 'undefined' && process.version && /v([0-9]*)/.exec(process.version);\n\n/** Version of Node.js if running under Node, otherwise 0 */\nexport const nodeVersion: number = (matches && parseFloat(matches[1])) || 0;\n", "import type {WorkerMessageType, WorkerMessagePayload} from '../../types';\nimport WorkerThread from './worker-thread';\nimport {assert} from '../env-utils/assert';\n\n/**\n * Represents one Job handled by a WorkerPool or WorkerFarm\n */\nexport default class WorkerJob {\n  readonly name: string;\n  readonly workerThread: WorkerThread;\n  isRunning: boolean = true;\n  /** Promise that resolves when Job is done */\n  readonly result: Promise<any>;\n\n  private _resolve: (value: any) => void = () => {};\n  private _reject: (reason?: any) => void = () => {};\n\n  constructor(jobName: string, workerThread: WorkerThread) {\n    this.name = jobName;\n    this.workerThread = workerThread;\n    this.result = new Promise((resolve, reject) => {\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n  }\n\n  /**\n   * Send a message to the job's worker thread\n   * @param data any data structure, ideally consisting mostly of transferrable objects\n   */\n  postMessage(type: WorkerMessageType, payload: WorkerMessagePayload): void {\n    this.workerThread.postMessage({\n      source: 'loaders.gl', // Lets worker ignore unrelated messages\n      type,\n      payload\n    });\n  }\n\n  /**\n   * Call to resolve the `result` Promise with the supplied value\n   */\n  done(value: any): void {\n    assert(this.isRunning);\n    this.isRunning = false;\n    this._resolve(value);\n  }\n\n  /**\n   * Call to reject the `result` Promise with the supplied error\n   */\n  error(error: Error): void {\n    assert(this.isRunning);\n    this.isRunning = false;\n    this._reject(error);\n  }\n}\n", "// Browser fills for Node.js built-in `worker_threads` module.\n// These fills are non-functional, and just intended to ensure that\n// `import 'worker_threads` doesn't break browser builds.\n// The replacement is done in package.json browser field\nexport class Worker {\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  terminate() {}\n}\n\nexport {Worker as NodeWorker};\nexport {Worker as NodeWorkerType};\n\nexport const parentPort = null;\n", "import {assert} from '../env-utils/assert';\n\nconst workerURLCache = new Map();\n\n/**\n * Creates a loadable URL from worker source or URL\n * that can be used to create `Worker` instances.\n * Due to CORS issues it may be necessary to wrap a URL in a small importScripts\n * @param props\n * @param props.source Worker source\n * @param props.url Worker URL\n * @returns loadable url\n */\nexport function getLoadableWorkerURL(props: {source?: string; url?: string}) {\n  assert((props.source && !props.url) || (!props.source && props.url)); // Either source or url must be defined\n\n  let workerURL = workerURLCache.get(props.source || props.url);\n  if (!workerURL) {\n    // Differentiate worker urls from worker source code\n    if (props.url) {\n      workerURL = getLoadableWorkerURLFromURL(props.url);\n      workerURLCache.set(props.url, workerURL);\n    }\n\n    if (props.source) {\n      workerURL = getLoadableWorkerURLFromSource(props.source);\n      workerURLCache.set(props.source, workerURL);\n    }\n  }\n\n  assert(workerURL);\n  return workerURL;\n}\n\n/**\n * Build a loadable worker URL from worker URL\n * @param url\n * @returns loadable URL\n */\nfunction getLoadableWorkerURLFromURL(url: string): string {\n  // A local script url, we can use it to initialize a Worker directly\n  if (!url.startsWith('http')) {\n    return url;\n  }\n\n  // A remote script, we need to use `importScripts` to load from different origin\n  const workerSource = buildScriptSource(url);\n  return getLoadableWorkerURLFromSource(workerSource);\n}\n\n/**\n * Build a loadable worker URL from worker source\n * @param workerSource\n * @returns loadable url\n */\nfunction getLoadableWorkerURLFromSource(workerSource: string): string {\n  const blob = new Blob([workerSource], {type: 'application/javascript'});\n  return URL.createObjectURL(blob);\n}\n\n/**\n * Per spec, worker cannot be initialized with a script from a different origin\n * However a local worker script can still import scripts from other origins,\n * so we simply build a wrapper script.\n *\n * @param workerUrl\n * @returns source\n */\nfunction buildScriptSource(workerUrl: string): string {\n  return `\\\ntry {\n  importScripts('${workerUrl}');\n} catch (error) {\n  console.error(error);\n  throw error;\n}`;\n}\n", "// NOTE - there is a copy of this function is both in core and loader-utils\n// core does not need all the utils in loader-utils, just this one.\n\n/**\n * Returns an array of Transferrable objects that can be used with postMessage\n * https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage\n * @param object data to be sent via postMessage\n * @param recursive - not for application use\n * @param transfers - not for application use\n * @returns a transfer list that can be passed to postMessage\n */\nexport function getTransferList(\n  object: any,\n  recursive: boolean = true,\n  transfers?: Set<any>\n): Transferable[] {\n  // Make sure that items in the transfer list is unique\n  const transfersSet = transfers || new Set();\n\n  if (!object) {\n    // ignore\n  } else if (isTransferable(object)) {\n    transfersSet.add(object);\n  } else if (isTransferable(object.buffer)) {\n    // Typed array\n    transfersSet.add(object.buffer);\n  } else if (ArrayBuffer.isView(object)) {\n    // object is a TypeArray viewing into a SharedArrayBuffer (not transferable)\n    // Do not iterate through the content in this case\n  } else if (recursive && typeof object === 'object') {\n    for (const key in object) {\n      // Avoid perf hit - only go one level deep\n      getTransferList(object[key], recursive, transfersSet);\n    }\n  }\n\n  // If transfers is defined, is internal recursive call\n  // Otherwise it's called by the user\n  return transfers === undefined ? Array.from(transfersSet) : [];\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/API/Transferable\nfunction isTransferable(object: unknown) {\n  if (!object) {\n    return false;\n  }\n  if (object instanceof ArrayBuffer) {\n    return true;\n  }\n  if (typeof MessagePort !== 'undefined' && object instanceof MessagePort) {\n    return true;\n  }\n  if (typeof ImageBitmap !== 'undefined' && object instanceof ImageBitmap) {\n    return true;\n  }\n  // @ts-ignore\n  if (typeof OffscreenCanvas !== 'undefined' && object instanceof OffscreenCanvas) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Recursively drop non serializable values like functions and regexps.\n * @param object\n */\nexport function getTransferListForWriter(object: object | null): object {\n  if (object === null) {\n    return {};\n  }\n  const clone = Object.assign({}, object);\n\n  Object.keys(clone).forEach((key) => {\n    // Typed Arrays and Arrays are passed with no change\n    if (\n      typeof object[key] === 'object' &&\n      !ArrayBuffer.isView(object[key]) &&\n      !(object[key] instanceof Array)\n    ) {\n      clone[key] = getTransferListForWriter(object[key]);\n    } else if (typeof clone[key] === 'function' || clone[key] instanceof RegExp) {\n      clone[key] = {};\n    } else {\n      clone[key] = object[key];\n    }\n  });\n\n  return clone;\n}\n", "// loaders.gl, MIT license\n\nimport {NodeWorker, NodeWorkerType} from '../node/worker_threads';\nimport {isBrowser} from '../env-utils/globals';\nimport {assert} from '../env-utils/assert';\nimport {getLoadableWorkerURL} from '../worker-utils/get-loadable-worker-url';\nimport {getTransferList} from '../worker-utils/get-transfer-list';\n\nconst NOOP = () => {};\n\nexport type WorkerThreadProps = {\n  name: string;\n  source?: string;\n  url?: string;\n};\n\n/**\n * Represents one worker thread\n */\nexport default class WorkerThread {\n  readonly name: string;\n  readonly source: string | undefined;\n  readonly url: string | undefined;\n  terminated: boolean = false;\n  worker: Worker | NodeWorkerType;\n  onMessage: (message: any) => void;\n  onError: (error: Error) => void;\n\n  private _loadableURL: string = '';\n\n  /** Checks if workers are supported on this platform */\n  static isSupported(): boolean {\n    return (\n      (typeof Worker !== 'undefined' && isBrowser) ||\n      (typeof NodeWorker !== 'undefined' && !isBrowser)\n    );\n  }\n\n  constructor(props: WorkerThreadProps) {\n    const {name, source, url} = props;\n    assert(source || url); // Either source or url must be defined\n    this.name = name;\n    this.source = source;\n    this.url = url;\n    this.onMessage = NOOP;\n    this.onError = (error) => console.log(error); // eslint-disable-line\n\n    this.worker = isBrowser ? this._createBrowserWorker() : this._createNodeWorker();\n  }\n\n  /**\n   * Terminate this worker thread\n   * @note Can free up significant memory\n   */\n  destroy(): void {\n    this.onMessage = NOOP;\n    this.onError = NOOP;\n    this.worker.terminate(); // eslint-disable-line @typescript-eslint/no-floating-promises\n    this.terminated = true;\n  }\n\n  get isRunning() {\n    return Boolean(this.onMessage);\n  }\n\n  /**\n   * Send a message to this worker thread\n   * @param data any data structure, ideally consisting mostly of transferrable objects\n   * @param transferList If not supplied, calculated automatically by traversing data\n   */\n  postMessage(data: any, transferList?: any[]): void {\n    transferList = transferList || getTransferList(data);\n    // @ts-ignore\n    this.worker.postMessage(data, transferList);\n  }\n\n  // PRIVATE\n\n  /**\n   * Generate a standard Error from an ErrorEvent\n   * @param event\n   */\n  _getErrorFromErrorEvent(event: ErrorEvent): Error {\n    // Note Error object does not have the expected fields if loading failed completely\n    // https://developer.mozilla.org/en-US/docs/Web/API/Worker#Event_handlers\n    // https://developer.mozilla.org/en-US/docs/Web/API/ErrorEvent\n    let message = 'Failed to load ';\n    message += `worker ${this.name} from ${this.url}. `;\n    if (event.message) {\n      message += `${event.message} in `;\n    }\n    // const hasFilename = event.filename && !event.filename.startsWith('blob:');\n    // message += hasFilename ? event.filename : this.source.slice(0, 100);\n    if (event.lineno) {\n      message += `:${event.lineno}:${event.colno}`;\n    }\n    return new Error(message);\n  }\n\n  /**\n   * Creates a worker thread on the browser\n   */\n  _createBrowserWorker(): Worker {\n    this._loadableURL = getLoadableWorkerURL({source: this.source, url: this.url});\n    const worker = new Worker(this._loadableURL, {name: this.name});\n\n    worker.onmessage = (event) => {\n      if (!event.data) {\n        this.onError(new Error('No data received'));\n      } else {\n        this.onMessage(event.data);\n      }\n    };\n    // This callback represents an uncaught exception in the worker thread\n    worker.onerror = (error: ErrorEvent): void => {\n      this.onError(this._getErrorFromErrorEvent(error));\n      this.terminated = true;\n    };\n    // TODO - not clear when this would be called, for now just log in case it happens\n    worker.onmessageerror = (event) => console.error(event); // eslint-disable-line\n\n    return worker;\n  }\n\n  /**\n   * Creates a worker thread in node.js\n   * @todo https://nodejs.org/api/async_hooks.html#async-resource-worker-pool\n   */\n  _createNodeWorker(): NodeWorkerType {\n    let worker: NodeWorkerType;\n    if (this.url) {\n      // Make sure relative URLs start with './'\n      const absolute = this.url.includes(':/') || this.url.startsWith('/');\n      const url = absolute ? this.url : `./${this.url}`;\n      // console.log('Starting work from', url);\n      worker = new NodeWorker(url, {eval: false});\n    } else if (this.source) {\n      worker = new NodeWorker(this.source, {eval: true});\n    } else {\n      throw new Error('no worker');\n    }\n    worker.on('message', (data) => {\n      // console.error('message', data);\n      this.onMessage(data);\n    });\n    worker.on('error', (error) => {\n      // console.error('error', error);\n      this.onError(error);\n    });\n    worker.on('exit', (code) => {\n      // console.error('exit', code);\n    });\n    return worker;\n  }\n}\n", "import type {WorkerMessageType, WorkerMessagePayload} from '../../types';\nimport {isMobile} from '../env-utils/globals';\nimport WorkerThread from './worker-thread';\nimport WorkerJob from './worker-job';\n\n/** WorkerPool onDebug Callback Parameters */\ntype OnDebugParameters = {\n  message: string;\n  worker: string;\n  name: string;\n  job: string;\n  backlog: number;\n  workerThread: WorkerThread;\n};\n\n/** WorkerPool Properties */\nexport type WorkerPoolProps = {\n  name?: string;\n  source?: string; // | Function;\n  url?: string;\n  maxConcurrency?: number;\n  maxMobileConcurrency?: number;\n  onDebug?: (options: OnDebugParameters) => any;\n  reuseWorkers?: boolean;\n};\n\n/** Private helper types */\ntype OnMessage = (job: WorkerJob, type: WorkerMessageType, payload: WorkerMessagePayload) => void;\ntype OnError = (job: WorkerJob, error: Error) => void;\n\ntype QueuedJob = {\n  name: string;\n  onMessage: OnMessage;\n  onError: OnError;\n  onStart: (value: any) => void; // Resolve job start promise\n};\n\n/**\n * Process multiple data messages with small pool of identical workers\n */\nexport default class WorkerPool {\n  name: string = 'unnamed';\n  source?: string; // | Function;\n  url?: string;\n  maxConcurrency: number = 1;\n  maxMobileConcurrency: number = 1;\n  onDebug: (options: OnDebugParameters) => any = () => {};\n  reuseWorkers: boolean = true;\n\n  private props: WorkerPoolProps = {};\n  private jobQueue: QueuedJob[] = [];\n  private idleQueue: WorkerThread[] = [];\n  private count = 0;\n  private isDestroyed = false;\n\n  /** Checks if workers are supported on this platform */\n  static isSupported(): boolean {\n    return WorkerThread.isSupported();\n  }\n\n  /**\n   * @param processor - worker function\n   * @param maxConcurrency - max count of workers\n   */\n  constructor(props: WorkerPoolProps) {\n    this.source = props.source;\n    this.url = props.url;\n    this.setProps(props);\n  }\n\n  /**\n   * Terminates all workers in the pool\n   * @note Can free up significant memory\n   */\n  destroy(): void {\n    // Destroy idle workers, active Workers will be destroyed on completion\n    this.idleQueue.forEach((worker) => worker.destroy());\n    this.isDestroyed = true;\n  }\n\n  setProps(props: WorkerPoolProps) {\n    this.props = {...this.props, ...props};\n\n    if (props.name !== undefined) {\n      this.name = props.name;\n    }\n    if (props.maxConcurrency !== undefined) {\n      this.maxConcurrency = props.maxConcurrency;\n    }\n    if (props.maxMobileConcurrency !== undefined) {\n      this.maxMobileConcurrency = props.maxMobileConcurrency;\n    }\n    if (props.reuseWorkers !== undefined) {\n      this.reuseWorkers = props.reuseWorkers;\n    }\n    if (props.onDebug !== undefined) {\n      this.onDebug = props.onDebug;\n    }\n  }\n\n  async startJob(\n    name: string,\n    onMessage: OnMessage = (job, type, data) => job.done(data),\n    onError: OnError = (job, error) => job.error(error)\n  ): Promise<WorkerJob> {\n    // Promise resolves when thread starts working on this job\n    const startPromise = new Promise<WorkerJob>((onStart) => {\n      // Promise resolves when thread completes or fails working on this job\n      this.jobQueue.push({name, onMessage, onError, onStart});\n      return this;\n    });\n    this._startQueuedJob(); // eslint-disable-line @typescript-eslint/no-floating-promises\n    return await startPromise;\n  }\n\n  // PRIVATE\n\n  /**\n   * Starts first queued job if worker is available or can be created\n   * Called when job is started and whenever a worker returns to the idleQueue\n   */\n  async _startQueuedJob(): Promise<void> {\n    if (!this.jobQueue.length) {\n      return;\n    }\n\n    const workerThread = this._getAvailableWorker();\n    if (!workerThread) {\n      return;\n    }\n\n    // We have a worker, dequeue and start the job\n    const queuedJob = this.jobQueue.shift();\n    if (queuedJob) {\n      // Emit a debug event\n      // @ts-ignore\n      this.onDebug({\n        message: 'Starting job',\n        name: queuedJob.name,\n        workerThread,\n        backlog: this.jobQueue.length\n      });\n\n      // Create a worker job to let the app access thread and manage job completion\n      const job = new WorkerJob(queuedJob.name, workerThread);\n\n      // Set the worker thread's message handlers\n      workerThread.onMessage = (data) => queuedJob.onMessage(job, data.type, data.payload);\n      workerThread.onError = (error) => queuedJob.onError(job, error);\n\n      // Resolve the start promise so that the app can start sending messages to worker\n      queuedJob.onStart(job);\n\n      // Wait for the app to signal that the job is complete, then return worker to queue\n      try {\n        await job.result;\n      } finally {\n        this.returnWorkerToQueue(workerThread);\n      }\n    }\n  }\n\n  /**\n   * Returns a worker to the idle queue\n   * Destroys the worker if\n   *  - pool is destroyed\n   *  - if this pool doesn't reuse workers\n   *  - if maxConcurrency has been lowered\n   * @param worker\n   */\n  returnWorkerToQueue(worker: WorkerThread) {\n    const shouldDestroyWorker =\n      this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency();\n\n    if (shouldDestroyWorker) {\n      worker.destroy();\n      this.count--;\n    } else {\n      this.idleQueue.push(worker);\n    }\n\n    if (!this.isDestroyed) {\n      this._startQueuedJob(); // eslint-disable-line @typescript-eslint/no-floating-promises\n    }\n  }\n\n  /**\n   * Returns idle worker or creates new worker if maxConcurrency has not been reached\n   */\n  _getAvailableWorker(): WorkerThread | null {\n    // If a worker has completed and returned to the queue, it can be used\n    if (this.idleQueue.length > 0) {\n      return this.idleQueue.shift() || null;\n    }\n\n    // Create fresh worker if we haven't yet created the max amount of worker threads for this worker source\n    if (this.count < this._getMaxConcurrency()) {\n      this.count++;\n      const name = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;\n      return new WorkerThread({name, source: this.source, url: this.url});\n    }\n\n    // No worker available, have to wait\n    return null;\n  }\n\n  _getMaxConcurrency() {\n    return isMobile ? this.maxMobileConcurrency : this.maxConcurrency;\n  }\n}\n", "import WorkerPool from './worker-pool';\nimport WorkerThread from './worker-thread';\n\n/**\n * @param maxConcurrency - max count of workers\n * @param maxMobileConcurrency - max count of workers on mobile\n * @param maxConcurrency - max count of workers\n * @param reuseWorkers - if false, destroys workers when task is completed\n * @param onDebug - callback intended to allow application to log worker pool activity\n */\nexport type WorkerFarmProps = {\n  maxConcurrency?: number;\n  maxMobileConcurrency?: number;\n  reuseWorkers?: boolean;\n  onDebug?: () => void;\n};\n\nconst DEFAULT_PROPS: Required<WorkerFarmProps> = {\n  maxConcurrency: 3,\n  maxMobileConcurrency: 1,\n  reuseWorkers: true,\n  onDebug: () => {}\n};\n\n/**\n * Process multiple jobs with a \"farm\" of different workers in worker pools.\n */\nexport default class WorkerFarm {\n  private props: WorkerFarmProps;\n  private workerPools = new Map<string, WorkerPool>();\n  // singleton\n  private static _workerFarm?: WorkerFarm;\n\n  /** Checks if workers are supported on this platform */\n  static isSupported(): boolean {\n    return WorkerThread.isSupported();\n  }\n\n  /** Get the singleton instance of the global worker farm */\n  static getWorkerFarm(props: WorkerFarmProps = {}): WorkerFarm {\n    WorkerFarm._workerFarm = WorkerFarm._workerFarm || new WorkerFarm({});\n    WorkerFarm._workerFarm.setProps(props);\n    return WorkerFarm._workerFarm;\n  }\n\n  /** get global instance with WorkerFarm.getWorkerFarm() */\n  private constructor(props: WorkerFarmProps) {\n    this.props = {...DEFAULT_PROPS};\n    this.setProps(props);\n    /** @type Map<string, WorkerPool>} */\n    this.workerPools = new Map();\n  }\n\n  /**\n   * Terminate all workers in the farm\n   * @note Can free up significant memory\n   */\n  destroy(): void {\n    for (const workerPool of this.workerPools.values()) {\n      workerPool.destroy();\n    }\n    this.workerPools = new Map<string, WorkerPool>();\n  }\n\n  /**\n   * Set props used when initializing worker pools\n   * @param props\n   */\n  setProps(props: WorkerFarmProps): void {\n    this.props = {...this.props, ...props};\n    // Update worker pool props\n    for (const workerPool of this.workerPools.values()) {\n      workerPool.setProps(this._getWorkerPoolProps());\n    }\n  }\n\n  /**\n   * Returns a worker pool for the specified worker\n   * @param options - only used first time for a specific worker name\n   * @param options.name - the name of the worker - used to identify worker pool\n   * @param options.url -\n   * @param options.source -\n   * @example\n   *   const job = WorkerFarm.getWorkerFarm().getWorkerPool({name, url}).startJob(...);\n   */\n  getWorkerPool(options: {name: string; source?: string; url?: string}): WorkerPool {\n    const {name, source, url} = options;\n    let workerPool = this.workerPools.get(name);\n    if (!workerPool) {\n      workerPool = new WorkerPool({\n        name,\n        source,\n        url\n      });\n      workerPool.setProps(this._getWorkerPoolProps());\n      this.workerPools.set(name, workerPool);\n    }\n    return workerPool;\n  }\n\n  _getWorkerPoolProps() {\n    return {\n      maxConcurrency: this.props.maxConcurrency,\n      maxMobileConcurrency: this.props.maxMobileConcurrency,\n      reuseWorkers: this.props.reuseWorkers,\n      onDebug: this.props.onDebug\n    };\n  }\n}\n", "import type {WorkerMessageData, WorkerMessageType, WorkerMessagePayload} from '../../types';\nimport {getTransferList} from '../worker-utils/get-transfer-list';\n\n/** Vile hack to defeat over-zealous bundlers from stripping out the require */\nfunction getParentPort() {\n  // const isNode = globalThis.process;\n  let parentPort;\n  try {\n    // prettier-ignore\n    eval('globalThis.parentPort = require(\\'worker_threads\\').parentPort'); // eslint-disable-line no-eval\n    parentPort = globalThis.parentPort;\n    // eslint-disable-next-line no-empty\n  } catch {}\n  return parentPort;\n}\n\nconst onMessageWrapperMap = new Map();\n\n/**\n * Type safe wrapper for worker code\n */\nexport default class WorkerBody {\n  /** Check that we are actually in a worker thread */\n  static inWorkerThread(): boolean {\n    return typeof self !== 'undefined' || Boolean(getParentPort());\n  }\n\n  /*\n   * (type: WorkerMessageType, payload: WorkerMessagePayload) => any\n   */\n  static set onmessage(onMessage: (type: WorkerMessageType, payload: WorkerMessagePayload) => any) {\n    function handleMessage(message) {\n      // Confusingly the message itself also has a 'type' field which is always set to 'message'\n      const parentPort = getParentPort();\n      const {type, payload} = parentPort ? message : message.data;\n      // if (!isKnownMessage(message)) {\n      //   return;\n      // }\n      onMessage(type, payload);\n    }\n\n    const parentPort = getParentPort();\n    if (parentPort) {\n      parentPort.on('message', handleMessage);\n      // if (message == 'exit') { parentPort.unref(); }\n      // eslint-disable-next-line\n      parentPort.on('exit', () => console.debug('Node worker closing'));\n    } else {\n      // eslint-disable-next-line no-restricted-globals\n      globalThis.onmessage = handleMessage;\n    }\n  }\n\n  static addEventListener(\n    onMessage: (type: WorkerMessageType, payload: WorkerMessagePayload) => any\n  ) {\n    let onMessageWrapper = onMessageWrapperMap.get(onMessage);\n\n    if (!onMessageWrapper) {\n      onMessageWrapper = (message: MessageEvent<any>) => {\n        if (!isKnownMessage(message)) {\n          return;\n        }\n\n        // Confusingly in the browser, the message itself also has a 'type' field which is always set to 'message'\n        const parentPort = getParentPort();\n        const {type, payload} = parentPort ? message : message.data;\n        onMessage(type, payload);\n      };\n    }\n\n    const parentPort = getParentPort();\n    if (parentPort) {\n      console.error('not implemented'); // eslint-disable-line\n    } else {\n      globalThis.addEventListener('message', onMessageWrapper);\n    }\n  }\n\n  static removeEventListener(\n    onMessage: (type: WorkerMessageType, payload: WorkerMessagePayload) => any\n  ) {\n    const onMessageWrapper = onMessageWrapperMap.get(onMessage);\n    onMessageWrapperMap.delete(onMessage);\n    const parentPort = getParentPort();\n    if (parentPort) {\n      console.error('not implemented'); // eslint-disable-line\n    } else {\n      globalThis.removeEventListener('message', onMessageWrapper);\n    }\n  }\n\n  /**\n   * Send a message from a worker to creating thread (main thread)\n   * @param type\n   * @param payload\n   */\n  static postMessage(type: WorkerMessageType, payload: WorkerMessagePayload): void {\n    const data: WorkerMessageData = {source: 'loaders.gl', type, payload};\n    // console.log('posting message', data);\n    const transferList = getTransferList(payload);\n\n    const parentPort = getParentPort();\n    if (parentPort) {\n      parentPort.postMessage(data, transferList);\n      // console.log('posted message', data);\n    } else {\n      // @ts-ignore\n      globalThis.postMessage(data, transferList);\n    }\n  }\n}\n\n// Filter out noise messages sent to workers\nfunction isKnownMessage(message: MessageEvent<any>) {\n  const {type, data} = message;\n  return (\n    type === 'message' &&\n    data &&\n    typeof data.source === 'string' &&\n    data.source.startsWith('loaders.gl')\n  );\n}\n", "// loaders.gl, MIT license\n\nimport type {WorkerObject, WorkerOptions} from '../../types';\nimport {assert} from '../env-utils/assert';\nimport {VERSION as __VERSION__} from '../env-utils/version';\n\nconst NPM_TAG = 'latest'; // 'beta', or 'latest' on release-branch\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : NPM_TAG;\n\n/**\n * Gets worker object's name (for debugging in Chrome thread inspector window)\n */\nexport function getWorkerName(worker: WorkerObject): string {\n  const warning = worker.version !== VERSION ? ` (worker-utils@${VERSION})` : '';\n  return `${worker.name}@${worker.version}${warning}`;\n}\n\n/**\n * Generate a worker URL based on worker object and options\n * @returns A URL to one of the following:\n * - a published worker on unpkg CDN\n * - a local test worker\n * - a URL provided by the user in options\n */\nexport function getWorkerURL(worker: WorkerObject, options: WorkerOptions = {}): string {\n  const workerOptions = options[worker.id] || {};\n\n  const workerFile = `${worker.id}-worker.js`;\n\n  let url = workerOptions.workerUrl;\n\n  // HACK: Allow for non-nested workerUrl for the CompressionWorker.\n  // For the compression worker, workerOptions is currently not nested correctly. For most loaders,\n  // you'd have options within an object, i.e. `{mvt: {coordinates: ...}}` but the CompressionWorker\n  // puts options at the top level, not within a `compression` key (its `id`). For this reason, the\n  // above `workerOptions` will always be a string (i.e. `'gzip'`) for the CompressionWorker. To not\n  // break backwards compatibility, we allow the CompressionWorker to have options at the top level.\n  if (!url && worker.id === 'compression') {\n    url = options.workerUrl;\n  }\n\n  // If URL is test, generate local loaders.gl url\n  // @ts-ignore _workerType\n  if (options._workerType === 'test') {\n    url = `modules/${worker.module}/dist/${workerFile}`;\n  }\n\n  // If url override is not provided, generate a URL to published version on npm CDN unpkg.com\n  if (!url) {\n    // GENERATE\n    let version = worker.version;\n    // On master we need to load npm alpha releases published with the `beta` tag\n    if (version === 'latest') {\n      // throw new Error('latest worker version specified');\n      version = NPM_TAG;\n    }\n    const versionTag = version ? `@${version}` : '';\n    url = `https://unpkg.com/@loaders.gl/${worker.module}${versionTag}/dist/${workerFile}`;\n  }\n\n  assert(url);\n\n  // Allow user to override location\n  return url;\n}\n", "import type {\n  WorkerObject,\n  WorkerOptions,\n  WorkerContext,\n  WorkerMessageType,\n  WorkerMessagePayload\n} from '../../types';\nimport type WorkerJob from '../worker-farm/worker-job';\nimport WorkerFarm from '../worker-farm/worker-farm';\nimport {getWorkerURL, getWorkerName} from './get-worker-url';\nimport {getTransferListForWriter} from '../worker-utils/get-transfer-list';\n\ntype ProcessOnWorkerOptions = WorkerOptions & {\n  jobName?: string;\n  [key: string]: any;\n};\n\n/**\n * Determines if we can parse with worker\n * @param loader\n * @param data\n * @param options\n */\nexport function canProcessOnWorker(worker: WorkerObject, options?: WorkerOptions) {\n  if (!WorkerFarm.isSupported()) {\n    return false;\n  }\n\n  return worker.worker && options?.worker;\n}\n\n/**\n * This function expects that the worker thread sends certain messages,\n * Creating such a worker can be automated if the worker is wrapper by a call to\n * createWorker in @loaders.gl/worker-utils.\n */\nexport async function processOnWorker(\n  worker: WorkerObject,\n  data: any,\n  options: ProcessOnWorkerOptions = {},\n  context: WorkerContext = {}\n): Promise<any> {\n  const name = getWorkerName(worker);\n\n  const workerFarm = WorkerFarm.getWorkerFarm(options);\n  const {source} = options;\n  const workerPoolProps: {name: string; source?: string; url?: string} = {name, source};\n  if (!source) {\n    workerPoolProps.url = getWorkerURL(worker, options);\n  }\n  const workerPool = workerFarm.getWorkerPool(workerPoolProps);\n\n  const jobName = options.jobName || worker.name;\n  const job = await workerPool.startJob(\n    jobName,\n    // eslint-disable-next-line\n    onMessage.bind(null, context)\n  );\n\n  // Kick off the processing in the worker\n  const transferableOptions = getTransferListForWriter(options);\n  job.postMessage('process', {input: data, options: transferableOptions});\n\n  const result = await job.result;\n  return result.result;\n}\n\n/**\n * Job completes when we receive the result\n * @param job\n * @param message\n */\nasync function onMessage(\n  context: WorkerContext,\n  job: WorkerJob,\n  type: WorkerMessageType,\n  payload: WorkerMessagePayload\n) {\n  switch (type) {\n    case 'done':\n      // Worker is done\n      job.done(payload);\n      break;\n\n    case 'error':\n      // Worker encountered an error\n      job.error(new Error(payload.error));\n      break;\n\n    case 'process':\n      // Worker is asking for us (main thread) to process something\n      const {id, input, options} = payload;\n      try {\n        if (!context.process) {\n          job.postMessage('error', {id, error: 'Worker not set up to process on main thread'});\n          return;\n        }\n        const result = await context.process(input, options);\n        job.postMessage('done', {id, result});\n      } catch (error) {\n        const message = error instanceof Error ? error.message : 'unknown error';\n        job.postMessage('error', {id, error: message});\n      }\n      break;\n\n    default:\n      // eslint-disable-next-line\n      console.warn(`process-on-worker: unknown message ${type}`);\n  }\n}\n", "// From https://github.com/rauschma/async-iter-demo/tree/master/src under MIT license\n// http://2ality.com/2016/10/asynchronous-iteration.html\n\n/**\n * Async Queue\n * - AsyncIterable: An async iterator can be\n * - Values can be pushed onto the queue\n * @example\n *   const asyncQueue = new AsyncQueue();\n *   setTimeout(() => asyncQueue.enqueue('tick'), 1000);\n *   setTimeout(() => asyncQueue.enqueue(new Error('done')), 10000);\n *   for await (const value of asyncQueue) {\n *     console.log(value); // tick\n *   }\n */\nexport default class AsyncQueue<T> {\n  private _values: any[];\n  private _settlers: any[];\n  private _closed: boolean;\n\n  constructor() {\n    this._values = []; // enqueues > dequeues\n    this._settlers = []; // dequeues > enqueues\n    this._closed = false;\n  }\n\n  /** Return an async iterator for this queue */\n  [Symbol.asyncIterator](): AsyncIterator<T> {\n    return this;\n  }\n\n  /** Push a new value - the async iterator will yield a promise resolved to this value */\n  push(value: T): void {\n    return this.enqueue(value);\n  }\n\n  /**\n   * Push a new value - the async iterator will yield a promise resolved to this value\n   * Add an error - the async iterator will yield a promise rejected with this value\n   */\n  enqueue(value: T | Error): void {\n    if (this._closed) {\n      throw new Error('Closed');\n    }\n\n    if (this._settlers.length > 0) {\n      if (this._values.length > 0) {\n        throw new Error('Illegal internal state');\n      }\n      const settler = this._settlers.shift();\n      if (value instanceof Error) {\n        settler.reject(value);\n      } else {\n        settler.resolve({value});\n      }\n    } else {\n      this._values.push(value);\n    }\n  }\n\n  /** Indicate that we not waiting for more values - The async iterator will be done */\n  close(): void {\n    while (this._settlers.length > 0) {\n      const settler = this._settlers.shift();\n      settler.resolve({done: true});\n    }\n    this._closed = true;\n  }\n\n  // ITERATOR IMPLEMENTATION\n\n  /** @returns a Promise for an IteratorResult */\n  next(): Promise<IteratorResult<T, any>> {\n    // If values in queue, yield the first value\n    if (this._values.length > 0) {\n      const value = this._values.shift();\n      if (value instanceof Error) {\n        return Promise.reject(value);\n      }\n      return Promise.resolve({done: false, value});\n    }\n\n    // If queue is closed, the iterator is done\n    if (this._closed) {\n      if (this._settlers.length > 0) {\n        throw new Error('Illegal internal state');\n      }\n      return Promise.resolve({done: true, value: undefined});\n    }\n\n    // Yield a promise that waits for new values to be enqueued\n    return new Promise((resolve, reject) => {\n      this._settlers.push({resolve, reject});\n    });\n  }\n}\n", "import type {WorkerObject} from '../../types';\nimport {assert} from '../env-utils/assert';\nimport {VERSION} from '../env-utils/version';\n\n/**\n * Check if worker is compatible with this library version\n * @param worker\n * @param libVersion\n * @returns `true` if the two versions are compatible\n */\nexport function validateWorkerVersion(\n  worker: WorkerObject,\n  coreVersion: string = VERSION\n): boolean {\n  assert(worker, 'no worker provided');\n\n  const workerVersion = worker.version;\n  if (!coreVersion || !workerVersion) {\n    return false;\n  }\n\n  // TODO enable when fix the __version__ injection\n  // const coreVersions = parseVersion(coreVersion);\n  // const workerVersions = parseVersion(workerVersion);\n  // assert(\n  //   coreVersion.major === workerVersion.major && coreVersion.minor <= workerVersion.minor,\n  //   `worker: ${worker.name} is not compatible. ${coreVersion.major}.${\n  //     coreVersion.minor\n  //   }+ is required.`\n  // );\n\n  return true;\n}\n\n// @ts-ignore\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction parseVersion(version) {\n  const parts = version.split('.').map(Number);\n  return {major: parts[0], minor: parts[1]};\n}\n", "import type {WorkerObject} from './types';\nimport {VERSION} from './lib/env-utils/version';\n\n// TYPES\nexport type {\n  WorkerObject,\n  WorkerOptions,\n  // Protocol\n  WorkerMessage,\n  WorkerMessageType,\n  WorkerMessageData,\n  WorkerMessagePayload\n} from './types';\n\n// GENERAL UTILS\nexport {assert} from './lib/env-utils/assert';\nexport {isBrowser, isWorker} from './lib/env-utils/globals';\n\n// WORKER UTILS - TYPES\nexport {default as WorkerJob} from './lib/worker-farm/worker-job';\nexport {default as WorkerThread} from './lib/worker-farm/worker-thread';\n\n// WORKER FARMS\nexport {default as WorkerFarm} from './lib/worker-farm/worker-farm';\nexport {default as WorkerPool} from './lib/worker-farm/worker-pool';\nexport {default as WorkerBody} from './lib/worker-farm/worker-body';\n\nexport {processOnWorker, canProcessOnWorker} from './lib/worker-api/process-on-worker';\nexport {createWorker} from './lib/worker-api/create-worker';\n\n// WORKER UTILS - EXPORTS\nexport {getWorkerURL} from './lib/worker-api/get-worker-url';\nexport {validateWorkerVersion} from './lib/worker-api/validate-worker-version';\nexport {getTransferList, getTransferListForWriter} from './lib/worker-utils/get-transfer-list';\n\n// LIBRARY UTILS\nexport {getLibraryUrl, loadLibrary} from './lib/library-utils/library-utils';\n\n// PARSER UTILS\nexport {default as AsyncQueue} from './lib/async-queue/async-queue';\n\n// PROCESS UTILS\nexport {default as ChildProcessProxy} from './lib/process-utils/child-process-proxy';\n\n// WORKER OBJECTS\n\n/** A null worker to test that worker processing is functional */\nexport const NullWorker: WorkerObject = {\n  id: 'null',\n  name: 'null',\n  module: 'worker-utils',\n  version: VERSION,\n  options: {\n    null: {}\n  }\n};\n", "import {\n  WorkerJob,\n  WorkerMessageType,\n  WorkerMessagePayload,\n  isBrowser\n} from '@loaders.gl/worker-utils';\nimport type {Loader, LoaderOptions, LoaderContext} from '../../types';\nimport {WorkerFarm, getWorkerURL} from '@loaders.gl/worker-utils';\n\n/**\n * Determines if a loader can parse with worker\n * @param loader\n * @param options\n */\nexport function canParseWithWorker(loader: Loader, options?: LoaderOptions) {\n  if (!WorkerFarm.isSupported()) {\n    return false;\n  }\n\n  // Node workers are still experimental\n  if (!isBrowser && !options?._nodeWorkers) {\n    return false;\n  }\n\n  return loader.worker && options?.worker;\n}\n\n/**\n * this function expects that the worker function sends certain messages,\n * this can be automated if the worker is wrapper by a call to createLoaderWorker in @loaders.gl/loader-utils.\n */\nexport async function parseWithWorker(\n  loader: Loader,\n  data: any,\n  options?: LoaderOptions,\n  context?: LoaderContext,\n  parseOnMainThread?: (arrayBuffer: ArrayBuffer, options: {[key: string]: any}) => Promise<void>\n) {\n  const name = loader.id; // TODO\n  const url = getWorkerURL(loader, options);\n\n  const workerFarm = WorkerFarm.getWorkerFarm(options);\n  const workerPool = workerFarm.getWorkerPool({name, url});\n\n  // options.log object contains functions which cannot be transferred\n  // context.fetch & context.parse functions cannot be transferred\n  // TODO - decide how to handle logging on workers\n  options = JSON.parse(JSON.stringify(options));\n  context = JSON.parse(JSON.stringify(context || {}));\n\n  const job = await workerPool.startJob(\n    'process-on-worker',\n    // @ts-expect-error\n    onMessage.bind(null, parseOnMainThread) // eslint-disable-line @typescript-eslint/no-misused-promises\n  );\n\n  job.postMessage('process', {\n    // @ts-ignore\n    input: data,\n    options,\n    context\n  });\n\n  const result = await job.result;\n  // TODO - what is going on here?\n  return await result.result;\n}\n\n/**\n * Handle worker's responses to the main thread\n * @param job\n * @param type\n * @param payload\n */\nasync function onMessage(\n  parseOnMainThread: (arrayBuffer: ArrayBuffer, options?: {[key: string]: any}) => Promise<void>,\n  job: WorkerJob,\n  type: WorkerMessageType,\n  payload: WorkerMessagePayload\n) {\n  switch (type) {\n    case 'done':\n      job.done(payload);\n      break;\n\n    case 'error':\n      job.error(new Error(payload.error));\n      break;\n\n    case 'process':\n      // Worker is asking for main thread to parseO\n      const {id, input, options} = payload;\n      try {\n        const result = await parseOnMainThread(input, options);\n        job.postMessage('done', {id, result});\n      } catch (error) {\n        const message = error instanceof Error ? error.message : 'unknown error';\n        job.postMessage('error', {id, error: message});\n      }\n      break;\n\n    default:\n      // eslint-disable-next-line\n      console.warn(`parse-with-worker unknown message ${type}`);\n  }\n}\n", "import {WorkerFarm} from '@loaders.gl/worker-utils';\nimport {Writer, WriterOptions} from '../../types';\nimport {isBrowser} from '../env-utils/globals';\n\n/**\n * Determines if a loader can parse with worker\n * @param loader\n * @param options\n */\nexport function canEncodeWithWorker(writer: Writer, options?: WriterOptions) {\n  if (!WorkerFarm.isSupported()) {\n    return false;\n  }\n\n  // Node workers are still experimental\n  if (!isBrowser && !options?._nodeWorkers) {\n    return false;\n  }\n\n  return writer.worker && options?.worker;\n}\n", "import {TypedArray} from '../../types';\n\n/**\n * compare two binary arrays for equality\n * @param a\n * @param b\n * @param byteLength\n */\nexport function compareArrayBuffers(\n  arrayBuffer1: ArrayBuffer,\n  arrayBuffer2: ArrayBuffer,\n  byteLength?: number\n): boolean {\n  byteLength = byteLength || arrayBuffer1.byteLength;\n  if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) {\n    return false;\n  }\n  const array1 = new Uint8Array(arrayBuffer1);\n  const array2 = new Uint8Array(arrayBuffer2);\n  for (let i = 0; i < array1.length; ++i) {\n    if (array1[i] !== array2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Concatenate a sequence of ArrayBuffers\n * @return A concatenated ArrayBuffer\n */\nexport function concatenateArrayBuffers(...sources: (ArrayBuffer | Uint8Array)[]): ArrayBuffer {\n  // Make sure all inputs are wrapped in typed arrays\n  const sourceArrays = sources.map((source2) =>\n    source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2\n  );\n\n  // Get length of all inputs\n  const byteLength = sourceArrays.reduce((length, typedArray) => length + typedArray.byteLength, 0);\n\n  // Allocate array with space for all inputs\n  const result = new Uint8Array(byteLength);\n\n  // Copy the subarrays\n  let offset = 0;\n  for (const sourceArray of sourceArrays) {\n    result.set(sourceArray, offset);\n    offset += sourceArray.byteLength;\n  }\n\n  // We work with ArrayBuffers, discard the typed array wrapper\n  return result.buffer;\n}\n\n/**\n * Concatenate arbitrary count of typed arrays\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays\n * @param - list of arrays. All arrays should be the same type\n * @return A concatenated TypedArray\n */\nexport function concatenateTypedArrays<T>(...typedArrays: T[]): T {\n  // @ts-ignore\n  const arrays = typedArrays as TypedArray[];\n  // @ts-ignore\n  const TypedArrayConstructor = (arrays && arrays.length > 1 && arrays[0].constructor) || null;\n  if (!TypedArrayConstructor) {\n    throw new Error(\n      '\"concatenateTypedArrays\" - incorrect quantity of arguments or arguments have incompatible data types'\n    );\n  }\n\n  const sumLength = arrays.reduce((acc, value) => acc + value.length, 0);\n  // @ts-ignore typescript does not like dynamic constructors\n  const result = new TypedArrayConstructor(sumLength);\n  let offset = 0;\n  for (const array of arrays) {\n    result.set(array, offset);\n    offset += array.length;\n  }\n  return result;\n}\n\n/**\n * Copy a view of an ArrayBuffer into new ArrayBuffer with byteOffset = 0\n * @param arrayBuffer\n * @param byteOffset\n * @param byteLength\n */\nexport function sliceArrayBuffer(\n  arrayBuffer: ArrayBuffer,\n  byteOffset: number,\n  byteLength?: number\n): ArrayBuffer {\n  const subArray =\n    byteLength !== undefined\n      ? new Uint8Array(arrayBuffer).subarray(byteOffset, byteOffset + byteLength)\n      : new Uint8Array(arrayBuffer).subarray(byteOffset);\n  const arrayCopy = new Uint8Array(subArray);\n  return arrayCopy.buffer;\n}\n", "// TextDecoder iterators\n// TextDecoder will keep any partial undecoded bytes between calls to `decode`\n\nexport async function* makeTextDecoderIterator(\n  arrayBufferIterator: AsyncIterable<ArrayBuffer> | Iterable<ArrayBuffer>,\n  options: TextDecoderOptions = {}\n): AsyncIterable<string> {\n  const textDecoder = new TextDecoder(undefined, options);\n  for await (const arrayBuffer of arrayBufferIterator) {\n    yield typeof arrayBuffer === 'string'\n      ? arrayBuffer\n      : textDecoder.decode(arrayBuffer, {stream: true});\n  }\n}\n\n// TextEncoder iterator\n// TODO - this is not useful unless min chunk size is given\n// TextEncoder will keep any partial undecoded bytes between calls to `encode`\n// If iterator does not yield strings, assume arrayBuffer and return unencoded\n\nexport async function* makeTextEncoderIterator(\n  textIterator: AsyncIterable<string> | Iterable<ArrayBuffer>\n): AsyncIterable<ArrayBuffer> {\n  const textEncoder = new TextEncoder();\n  for await (const text of textIterator) {\n    yield typeof text === 'string' ? textEncoder.encode(text) : text;\n  }\n}\n\n/**\n * @param textIterator async iterable yielding strings\n * @returns an async iterable over lines\n * See http://2ality.com/2018/04/async-iter-nodejs.html\n */\n\nexport async function* makeLineIterator(\n  textIterator: AsyncIterable<string>\n): AsyncIterable<string> {\n  let previous = '';\n  for await (const textChunk of textIterator) {\n    previous += textChunk;\n    let eolIndex;\n    while ((eolIndex = previous.indexOf('\\n')) >= 0) {\n      // line includes the EOL\n      const line = previous.slice(0, eolIndex + 1);\n      previous = previous.slice(eolIndex + 1);\n      yield line;\n    }\n  }\n\n  if (previous.length > 0) {\n    yield previous;\n  }\n}\n\n/**\n * @param lineIterator async iterable yielding lines\n * @returns async iterable yielding numbered lines\n *\n * See http://2ality.com/2018/04/async-iter-nodejs.html\n */\nexport async function* makeNumberedLineIterator(\n  lineIterator: AsyncIterable<string>\n): AsyncIterable<{counter: number; line: string}> {\n  let counter = 1;\n  for await (const line of lineIterator) {\n    yield {counter, line};\n    counter++;\n  }\n}\n", "import {concatenateArrayBuffers} from '../binary-utils/array-buffer-utils';\n\n// GENERAL UTILITIES\n\n/**\n * Iterate over async iterator, without resetting iterator if end is not reached\n * - forEach intentionally does not reset iterator if exiting loop prematurely\n *   so that iteration can continue in a second loop\n * - It is recommended to use a standard for-await as last loop to ensure\n *   iterator gets properly reset\n *\n * TODO - optimize using sync iteration if argument is an Iterable?\n *\n * @param iterator\n * @param visitor\n */\nexport async function forEach(iterator, visitor) {\n  // eslint-disable-next-line\n  while (true) {\n    const {done, value} = await iterator.next();\n    if (done) {\n      iterator.return();\n      return;\n    }\n    const cancel = visitor(value);\n    if (cancel) {\n      return;\n    }\n  }\n}\n\n// Breaking big data into iterable chunks, concatenating iterable chunks into big data objects\n\n/**\n * Concatenates all data chunks yielded by an (async) iterator\n * This function can e.g. be used to enable atomic parsers to work on (async) iterator inputs\n */\n\nexport async function concatenateArrayBuffersAsync(\n  asyncIterator: AsyncIterable<ArrayBuffer> | Iterable<ArrayBuffer>\n): Promise<ArrayBuffer> {\n  const arrayBuffers: ArrayBuffer[] = [];\n  for await (const chunk of asyncIterator) {\n    arrayBuffers.push(chunk);\n  }\n  return concatenateArrayBuffers(...arrayBuffers);\n}\n\nexport async function concatenateStringsAsync(\n  asyncIterator: AsyncIterable<string> | Iterable<string>\n): Promise<string> {\n  const strings: string[] = [];\n  for await (const chunk of asyncIterator) {\n    strings.push(chunk);\n  }\n  return strings.join('');\n}\n", "// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport default function getHiResTimestamp(): number {\n  let timestamp;\n  // Get best timer available.\n  if (typeof window !== 'undefined' && window.performance) {\n    timestamp = window.performance.now();\n  } else if (typeof process !== 'undefined' && process.hrtime) {\n    const timeParts = process.hrtime();\n    timestamp = timeParts[0] * 1000 + timeParts[1] / 1e6;\n  } else {\n    timestamp = Date.now();\n  }\n\n  return timestamp;\n}\n", "import getHiResTimestamp from '../utils/hi-res-timestamp';\n\nexport default class Stat {\n  readonly name: string;\n  readonly type: string;\n  sampleSize: number = 1;\n  time: number;\n  count: number;\n  samples: number;\n  lastTiming: number;\n  lastSampleTime: number;\n  lastSampleCount: number;\n\n  _count: number = 0;\n  _time: number = 0;\n  _samples: number = 0;\n  _startTime: number = 0;\n  _timerPending: boolean = false;\n\n  constructor(name: string, type?: string) {\n    this.name = name;\n    this.type = type;\n    this.reset();\n  }\n\n  setSampleSize(samples: number): this {\n    this.sampleSize = samples;\n    return this;\n  }\n\n  /** Call to increment count (+1) */\n  incrementCount(): this {\n    this.addCount(1);\n\n    return this;\n  }\n\n  /** Call to decrement count (-1) */\n  decrementCount(): this {\n    this.subtractCount(1);\n\n    return this;\n  }\n\n  /** Increase count */\n  addCount(value: number): this {\n    this._count += value;\n    this._samples++;\n    this._checkSampling();\n\n    return this;\n  }\n\n  /** Decrease count */\n  subtractCount(value: number): this {\n    this._count -= value;\n    this._samples++;\n    this._checkSampling();\n\n    return this;\n  }\n\n  /** Add an arbitrary timing and bump the count */\n  addTime(time: number): this {\n    this._time += time;\n    this.lastTiming = time;\n    this._samples++;\n    this._checkSampling();\n\n    return this;\n  }\n\n  /** Start a timer */\n  timeStart(): this {\n    this._startTime = getHiResTimestamp();\n    this._timerPending = true;\n\n    return this;\n  }\n\n  /** End a timer. Adds to time and bumps the timing count. */\n  timeEnd(): this {\n    if (!this._timerPending) {\n      return this;\n    }\n    this.addTime(getHiResTimestamp() - this._startTime);\n    this._timerPending = false;\n    this._checkSampling();\n\n    return this;\n  }\n\n  getSampleAverageCount(): number {\n    return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;\n  }\n\n  /** Calculate average time / count for the previous window */\n  getSampleAverageTime(): number {\n    return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;\n  }\n\n  /** Calculate counts per second for the previous window */\n  getSampleHz(): number {\n    return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1000) : 0;\n  }\n\n  getAverageCount(): number {\n    return this.samples > 0 ? this.count / this.samples : 0;\n  }\n\n  /** Calculate average time / count */\n  getAverageTime(): number {\n    return this.samples > 0 ? this.time / this.samples : 0;\n  }\n\n  /** Calculate counts per second */\n  getHz(): number {\n    return this.time > 0 ? this.samples / (this.time / 1000) : 0;\n  }\n\n  reset(): this {\n    this.time = 0;\n    this.count = 0;\n    this.samples = 0;\n    this.lastTiming = 0;\n    this.lastSampleTime = 0;\n    this.lastSampleCount = 0;\n    this._count = 0;\n    this._time = 0;\n    this._samples = 0;\n    this._startTime = 0;\n    this._timerPending = false;\n\n    return this;\n  }\n\n  _checkSampling(): void {\n    if (this._samples === this.sampleSize) {\n      this.lastSampleTime = this._time;\n      this.lastSampleCount = this._count;\n      this.count += this._count;\n      this.time += this._time;\n      this.samples += this._samples;\n      this._time = 0;\n      this._count = 0;\n      this._samples = 0;\n    }\n  }\n}\n", "import Stat from './stat';\n\n/** A \"bag\" of `Stat` objects, can be visualized using `StatsWidget` */\nexport default class Stats {\n  readonly id: string;\n  readonly stats: Record<string, Stat> = {};\n\n  constructor(options: {id: string; stats?: Stats | Stat[] | {name: string; type?: string}[]}) {\n    this.id = options.id;\n    this.stats = {};\n\n    this._initializeStats(options.stats);\n\n    Object.seal(this);\n  }\n\n  /** Acquire a stat. Create if it doesn't exist. */\n  get(name: string, type: string = 'count'): Stat {\n    return this._getOrCreate({name, type});\n  }\n\n  get size(): number {\n    return Object.keys(this.stats).length;\n  }\n\n  /** Reset all stats */\n  reset(): this {\n    for (const key in this.stats) {\n      this.stats[key].reset();\n    }\n\n    return this;\n  }\n\n  forEach(fn: (stat: Stat) => void): void {\n    for (const key in this.stats) {\n      fn(this.stats[key]);\n    }\n  }\n\n  getTable(): Record<\n    string,\n    {\n      time: number;\n      count: number;\n      average: number;\n      hz: number;\n    }\n    > {\n    const table = {};\n    this.forEach(stat => {\n      table[stat.name] = {\n        time: stat.time || 0,\n        count: stat.count || 0,\n        average: stat.getAverageTime() || 0,\n        hz: stat.getHz() || 0\n      };\n    });\n\n    return table;\n  }\n\n  _initializeStats(stats: Stats | Stat[] | {name: string; type?: string}[] = []): void {\n    stats.forEach(stat => this._getOrCreate(stat));\n  }\n\n  _getOrCreate(stat): Stat {\n    if (!stat || !stat.name) {\n      return null;\n    }\n\n    const {name, type} = stat;\n    if (!this.stats[name]) {\n      if (stat instanceof Stat) {\n        this.stats[name] = stat;\n      } else {\n        this.stats[name] = new Stat(name, type);\n      }\n    }\n    return this.stats[name];\n  }\n}\n", "import {Stats} from '@probe.gl/stats';\n\ntype Handle = any;\ntype DoneFunction = () => any;\ntype GetPriorityFunction = () => number;\ntype RequestResult = {\n  done: DoneFunction;\n} | null;\n\n/** RequestScheduler Options */\nexport type RequestSchedulerProps = {\n  id?: string;\n  throttleRequests?: boolean;\n  maxRequests?: number;\n};\n\nconst STAT_QUEUED_REQUESTS = 'Queued Requests';\nconst STAT_ACTIVE_REQUESTS = 'Active Requests';\nconst STAT_CANCELLED_REQUESTS = 'Cancelled Requests';\nconst STAT_QUEUED_REQUESTS_EVER = 'Queued Requests Ever';\nconst STAT_ACTIVE_REQUESTS_EVER = 'Active Requests Ever';\n\nconst DEFAULT_PROPS: Required<RequestSchedulerProps> = {\n  id: 'request-scheduler',\n  // Specifies if the request scheduler should throttle incoming requests, mainly for comparative testing\n  throttleRequests: true,\n  // The maximum number of simultaneous active requests. Un-throttled requests do not observe this limit.\n  maxRequests: 6\n};\n\n/** Tracks one request */\ntype Request = {\n  handle: Handle;\n  priority: number;\n  getPriority: GetPriorityFunction;\n  resolve?: (value: any) => any;\n};\n\n/**\n * Used to issue a request, without having them \"deeply queued\" by the browser.\n * @todo - Track requests globally, across multiple servers\n */\nexport default class RequestScheduler {\n  readonly props: Required<RequestSchedulerProps>;\n  readonly stats: Stats;\n  activeRequestCount: number = 0;\n\n  /** Tracks the number of active requests and prioritizes/cancels queued requests. */\n  private requestQueue: Request[] = [];\n  private requestMap: Map<Handle, Promise<RequestResult>> = new Map();\n  private deferredUpdate: any = null;\n\n  constructor(props: RequestSchedulerProps = {}) {\n    this.props = {...DEFAULT_PROPS, ...props};\n\n    // Returns the statistics used by the request scheduler.\n    this.stats = new Stats({id: this.props.id});\n    this.stats.get(STAT_QUEUED_REQUESTS);\n    this.stats.get(STAT_ACTIVE_REQUESTS);\n    this.stats.get(STAT_CANCELLED_REQUESTS);\n    this.stats.get(STAT_QUEUED_REQUESTS_EVER);\n    this.stats.get(STAT_ACTIVE_REQUESTS_EVER);\n  }\n\n  /**\n   * Called by an application that wants to issue a request, without having it deeply queued by the browser\n   *\n   * When the returned promise resolved, it is OK for the application to issue a request.\n   * The promise resolves to an object that contains a `done` method.\n   * When the application's request has completed (or failed), the application must call the `done` function\n   *\n   * @param handle\n   * @param getPriority will be called when request \"slots\" open up,\n   *    allowing the caller to update priority or cancel the request\n   *    Highest priority executes first, priority < 0 cancels the request\n   * @returns a promise\n   *   - resolves to a object (with a `done` field) when the request can be issued without queueing,\n   *   - resolves to `null` if the request has been cancelled (by the callback return < 0).\n   *     In this case the application should not issue the request\n   */\n  scheduleRequest(\n    handle: Handle,\n    getPriority: GetPriorityFunction = () => 0\n  ): Promise<RequestResult> {\n    // Allows throttling to be disabled\n    if (!this.props.throttleRequests) {\n      return Promise.resolve({done: () => {}});\n    }\n\n    // dedupe\n    if (this.requestMap.has(handle)) {\n      return this.requestMap.get(handle) as Promise<any>;\n    }\n\n    const request: Request = {handle, priority: 0, getPriority};\n    const promise = new Promise<RequestResult>((resolve) => {\n      // @ts-ignore\n      request.resolve = resolve;\n      return request;\n    });\n\n    this.requestQueue.push(request);\n    this.requestMap.set(handle, promise);\n    this._issueNewRequests();\n    return promise;\n  }\n\n  // PRIVATE\n\n  _issueRequest(request: Request): Promise<any> {\n    const {handle, resolve} = request;\n    let isDone = false;\n\n    const done = () => {\n      // can only be called once\n      if (!isDone) {\n        isDone = true;\n\n        // Stop tracking a request - it has completed, failed, cancelled etc\n        this.requestMap.delete(handle);\n        this.activeRequestCount--;\n        // A slot just freed up, see if any queued requests are waiting\n        this._issueNewRequests();\n      }\n    };\n\n    // Track this request\n    this.activeRequestCount++;\n\n    return resolve ? resolve({done}) : Promise.resolve({done});\n  }\n\n  /** We check requests asynchronously, to prevent multiple updates */\n  _issueNewRequests(): void {\n    if (!this.deferredUpdate) {\n      this.deferredUpdate = setTimeout(() => this._issueNewRequestsAsync(), 0);\n    }\n  }\n\n  /** Refresh all requests  */\n  _issueNewRequestsAsync() {\n    // TODO - shouldn't we clear the timeout?\n    this.deferredUpdate = null;\n\n    const freeSlots = Math.max(this.props.maxRequests - this.activeRequestCount, 0);\n\n    if (freeSlots === 0) {\n      return;\n    }\n\n    this._updateAllRequests();\n\n    // Resolve pending promises for the top-priority requests\n    for (let i = 0; i < freeSlots; ++i) {\n      const request = this.requestQueue.shift();\n      if (request) {\n        this._issueRequest(request); // eslint-disable-line @typescript-eslint/no-floating-promises\n      }\n    }\n\n    // Uncomment to debug\n    // console.log(`${freeSlots} free slots, ${this.requestQueue.length} queued requests`);\n  }\n\n  /** Ensure all requests have updated priorities, and that no longer valid requests are cancelled */\n  _updateAllRequests() {\n    const requestQueue = this.requestQueue;\n    for (let i = 0; i < requestQueue.length; ++i) {\n      const request = requestQueue[i];\n      if (!this._updateRequest(request)) {\n        // Remove the element and make sure to adjust the counter to account for shortened array\n        requestQueue.splice(i, 1);\n        this.requestMap.delete(request.handle);\n        i--;\n      }\n    }\n\n    // Sort the remaining requests based on priority\n    requestQueue.sort((a, b) => a.priority - b.priority);\n  }\n\n  /** Update a single request by calling the callback */\n  _updateRequest(request) {\n    request.priority = request.getPriority(request.handle); // eslint-disable-line callback-return\n\n    // by returning a negative priority, the callback cancels the request\n    if (request.priority < 0) {\n      request.resolve(null);\n      return false;\n    }\n    return true;\n  }\n}\n", "// Simple file alias mechanisms for tests.\n\nlet pathPrefix = '';\nconst fileAliases: {[aliasPath: string]: string} = {};\n\n/*\n * Set a relative path prefix\n */\nexport function setPathPrefix(prefix: string): void {\n  pathPrefix = prefix;\n}\n\n/*\n * Get the relative path prefix\n */\nexport function getPathPrefix(): string {\n  return pathPrefix;\n}\n\n/**\n *\n * @param aliases\n *\n * Note: addAliases are an experimental export, they are only for testing of loaders.gl loaders\n * not intended as a generic aliasing mechanism\n */\nexport function addAliases(aliases: {[aliasPath: string]: string}): void {\n  Object.assign(fileAliases, aliases);\n}\n\n/**\n * Resolves aliases and adds path-prefix to paths\n */\nexport function resolvePath(filename: string): string {\n  for (const alias in fileAliases) {\n    if (filename.startsWith(alias)) {\n      const replacement = fileAliases[alias];\n      filename = filename.replace(alias, replacement);\n    }\n  }\n  if (!filename.startsWith('http://') && !filename.startsWith('https://')) {\n    filename = `${pathPrefix}${filename}`;\n  }\n  return filename;\n}\n", "import type {LoaderWithParser} from './types';\n\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\n\n/**\n * A JSON Micro loader (minimal bundle size)\n * Alternative to `@loaders.gl/json`\n */\nexport const JSONLoader = {\n  name: 'JSON',\n  id: 'json',\n  module: 'json',\n  version: VERSION,\n  extensions: ['json', 'geojson'],\n  mimeTypes: ['application/json'],\n  category: 'json',\n  text: true,\n  parseTextSync,\n  parse: async (arrayBuffer) => parseTextSync(new TextDecoder().decode(arrayBuffer)),\n  options: {}\n};\n\n// TODO - deprecated\nfunction parseTextSync(text) {\n  return JSON.parse(text);\n}\n\nexport const _typecheckJSONLoader: LoaderWithParser = JSONLoader;\n", "// loaders.gl, MIT license\n\n// Isolates Buffer references to ensure they are only bundled under Node.js (avoids big webpack polyfill)\n// this file is selected by the package.json \"browser\" field).\n\n/**\n * Convert Buffer to ArrayBuffer\n * Converts Node.js `Buffer` to `ArrayBuffer` (without triggering bundler to include Buffer polyfill on browser)\n * @todo better data type\n */\nexport function toArrayBuffer(buffer) {\n  return buffer;\n}\n\n/**\n * Convert (copy) ArrayBuffer to Buffer\n */\nexport function toBuffer(binaryData: ArrayBuffer | ArrayBuffer | Buffer): Buffer {\n  throw new Error('Buffer not supported in browser');\n}\n", "// loaders.gl, MIT license\n\nimport * as node from '../node/buffer';\n\n/**\n * Check for Node.js `Buffer` (without triggering bundler to include Buffer polyfill on browser)\n */\nexport function isBuffer(value: any): boolean {\n  return value && typeof value === 'object' && value.isBuffer;\n}\n\n/**\n * Converts to Node.js `Buffer` (without triggering bundler to include Buffer polyfill on browser)\n * @todo better data type\n */\nexport function toBuffer(data: any): Buffer {\n  return node.toBuffer ? node.toBuffer(data) : data;\n}\n\n/**\n * Convert an object to an array buffer\n */\nexport function toArrayBuffer(data: unknown): ArrayBuffer {\n  // Note: Should be called first, Buffers can trigger other detections below\n  if (isBuffer(data)) {\n    return node.toArrayBuffer(data);\n  }\n\n  if (data instanceof ArrayBuffer) {\n    return data;\n  }\n\n  // Careful - Node Buffers look like Uint8Arrays (keep after isBuffer)\n  if (ArrayBuffer.isView(data)) {\n    if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {\n      return data.buffer;\n    }\n    return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);\n  }\n\n  if (typeof data === 'string') {\n    const text = data;\n    const uint8Array = new TextEncoder().encode(text);\n    return uint8Array.buffer;\n  }\n\n  // HACK to support Blob polyfill\n  if (data && typeof data === 'object' && (data as any)._toArrayBuffer) {\n    return (data as any)._toArrayBuffer();\n  }\n\n  throw new Error('toArrayBuffer');\n}\n", "// Beginning of a minimal implementation of the Node.js path API, that doesn't pull in big polyfills.\n\nimport {getCWD} from './get-cwd';\n\n/**\n * Replacement for Node.js path.filename\n * @param url\n */\nexport function filename(url: string): string {\n  const slashIndex = url ? url.lastIndexOf('/') : -1;\n  return slashIndex >= 0 ? url.substr(slashIndex + 1) : '';\n}\n\n/**\n * Replacement for Node.js path.dirname\n * @param url\n */\nexport function dirname(url: string): string {\n  const slashIndex = url ? url.lastIndexOf('/') : -1;\n  return slashIndex >= 0 ? url.substr(0, slashIndex) : '';\n}\n\n/**\n * Replacement for Node.js path.join\n * @param parts\n */\nexport function join(...parts: string[]): string {\n  const separator = '/';\n  parts = parts.map((part, index) => {\n    if (index) {\n      part = part.replace(new RegExp(`^${separator}`), '');\n    }\n    if (index !== parts.length - 1) {\n      part = part.replace(new RegExp(`${separator}$`), '');\n    }\n    return part;\n  });\n  return parts.join(separator);\n}\n\n/* eslint-disable no-continue */\n\n/**\n * https://nodejs.org/api/path.html#path_path_resolve_paths\n * @param paths A sequence of paths or path segments.\n * @return resolved path\n * Forked from BTOdell/path-resolve under MIT license\n * @see https://github.com/BTOdell/path-resolve/blob/master/LICENSE\n */\nexport function resolve(...components: string[]): string {\n  const paths: string[] = [];\n  for (let _i = 0; _i < components.length; _i++) {\n    paths[_i] = components[_i];\n  }\n  let resolvedPath = '';\n  let resolvedAbsolute = false;\n  let cwd: string | undefined;\n  for (let i = paths.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    let path: string | undefined;\n    if (i >= 0) {\n      path = paths[i];\n    } else {\n      if (cwd === undefined) {\n        cwd = getCWD();\n      }\n      path = cwd;\n    }\n    // Skip empty entries\n    if (path.length === 0) {\n      continue;\n    }\n    resolvedPath = `${path}/${resolvedPath}`;\n    resolvedAbsolute = path.charCodeAt(0) === SLASH;\n  }\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n  // Normalize the path (removes leading slash)\n  resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n  if (resolvedAbsolute) {\n    return `/${resolvedPath}`;\n  } else if (resolvedPath.length > 0) {\n    return resolvedPath;\n  }\n  return '.';\n}\n\nconst SLASH = 47;\nconst DOT = 46;\n\n/**\n * Resolves . and .. elements in a path with directory names\n * Forked from BTOdell/path-resolve under MIT license\n * @see https://github.com/BTOdell/path-resolve/blob/master/LICENSE\n */\n/* eslint-disable max-depth */\n// eslint-disable-next-line complexity, max-statements\nfunction normalizeStringPosix(path: string, allowAboveRoot: boolean): string {\n  let res = '';\n  let lastSlash = -1;\n  let dots = 0;\n  let code: number | undefined;\n  let isAboveRoot = false;\n\n  for (let i = 0; i <= path.length; ++i) {\n    if (i < path.length) {\n      code = path.charCodeAt(i);\n    } else if (code === SLASH) {\n      break;\n    } else {\n      code = SLASH;\n    }\n    if (code === SLASH) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (\n          res.length < 2 ||\n          !isAboveRoot ||\n          res.charCodeAt(res.length - 1) !== DOT ||\n          res.charCodeAt(res.length - 2) !== DOT\n        ) {\n          if (res.length > 2) {\n            const start = res.length - 1;\n            let j = start;\n            for (; j >= 0; --j) {\n              if (res.charCodeAt(j) === SLASH) {\n                break;\n              }\n            }\n            if (j !== start) {\n              res = j === -1 ? '' : res.slice(0, j);\n              lastSlash = i;\n              dots = 0;\n              isAboveRoot = false;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSlash = i;\n            dots = 0;\n            isAboveRoot = false;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0) {\n            res += '/..';\n          } else {\n            res = '..';\n          }\n          isAboveRoot = true;\n        }\n      } else {\n        const slice = path.slice(lastSlash + 1, i);\n        if (res.length > 0) {\n          res += `/${slice}`;\n        } else {\n          res = slice;\n        }\n        isAboveRoot = false;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === DOT && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n", "// loaders.gl MIT license\n\nexport function getCWD() {\n  if (typeof process !== 'undefined' && typeof process.cwd !== 'undefined') {\n    return process.cwd();\n  }\n  const pathname = window.location?.pathname;\n  return pathname?.slice(0, pathname.lastIndexOf('/') + 1) || '';\n}\n", "export const readdir = null;\nexport const stat = null;\nexport const readFile = null;\nexport const readFileSync = null;\nexport const writeFile = null;\nexport const writeFileSync = null;\nexport const open = null;\nexport const close = null;\nexport const read = null;\nexport const fstat = null;\nexport const createWriteStream = null;\nexport const _readToArrayBuffer = null;\n\nexport const isSupported = false;\n", "import type {Readable} from 'stream';\n\n/** A DOM or Node readable stream */\nexport type ReadableStreamType = ReadableStream | Readable;\n\nconst isBoolean: (x: any) => boolean = (x) => typeof x === 'boolean';\nconst isFunction: (x: any) => boolean = (x) => typeof x === 'function';\n\nexport const isObject: (x: any) => boolean = (x) => x !== null && typeof x === 'object';\nexport const isPureObject: (x: any) => boolean = (x) =>\n  isObject(x) && x.constructor === {}.constructor;\nexport const isPromise: (x: any) => boolean = (x) => isObject(x) && isFunction(x.then);\n\nexport const isIterable: (x: any) => boolean = (x) => x && typeof x[Symbol.iterator] === 'function';\nexport const isAsyncIterable: (x: any) => boolean = (x) =>\n  x && typeof x[Symbol.asyncIterator] === 'function';\nexport const isIterator: (x: any) => boolean = (x) => x && isFunction(x.next);\n\nexport const isResponse: (x: any) => boolean = (x) =>\n  (typeof Response !== 'undefined' && x instanceof Response) ||\n  (x && x.arrayBuffer && x.text && x.json);\n\nexport const isFile: (x: any) => boolean = (x) => typeof File !== 'undefined' && x instanceof File;\nexport const isBlob: (x: any) => boolean = (x) => typeof Blob !== 'undefined' && x instanceof Blob;\n\n/** Check for Node.js `Buffer` without triggering bundler to include buffer polyfill */\nexport const isBuffer: (x: any) => boolean = (x) => x && typeof x === 'object' && x.isBuffer;\n\nexport const isWritableDOMStream: (x: any) => boolean = (x) =>\n  isObject(x) && isFunction(x.abort) && isFunction(x.getWriter);\n\nexport const isReadableDOMStream: (x: any) => boolean = (x) =>\n  (typeof ReadableStream !== 'undefined' && x instanceof ReadableStream) ||\n  (isObject(x) && isFunction(x.tee) && isFunction(x.cancel) && isFunction(x.getReader));\n// Not implemented in Firefox: && isFunction(x.pipeTo)\n\nexport const isWritableNodeStream: (x: any) => boolean = (x) =>\n  isObject(x) && isFunction(x.end) && isFunction(x.write) && isBoolean(x.writable);\nexport const isReadableNodeStream: (x: any) => boolean = (x) =>\n  isObject(x) && isFunction(x.read) && isFunction(x.pipe) && isBoolean(x.readable);\nexport const isReadableStream: (x: any) => boolean = (x) =>\n  isReadableDOMStream(x) || isReadableNodeStream(x);\nexport const isWritableStream: (x: any) => boolean = (x) =>\n  isWritableDOMStream(x) || isWritableNodeStream(x);\n", "// TODO - build/integrate proper MIME type parsing\n// https://mimesniff.spec.whatwg.org/\n\nconst DATA_URL_PATTERN = /^data:([-\\w.]+\\/[-\\w.+]+)(;|,)/;\nconst MIME_TYPE_PATTERN = /^([-\\w.]+\\/[-\\w.+]+)/;\n\n/**\n * Remove extra data like `charset` from MIME types\n * @param mimeString\n * @returns A clean MIME type, or an empty string\n *\n * @todo - handle more advanced MIMETYpes, multiple types\n * @todo - extract charset etc\n */\nexport function parseMIMEType(mimeString: string): string {\n  // If resource is a data url, extract any embedded mime type\n  const matches = MIME_TYPE_PATTERN.exec(mimeString);\n  if (matches) {\n    return matches[1];\n  }\n  return mimeString;\n}\n\n/**\n * Extract MIME type from data URL\n *\n * @param mimeString\n * @returns A clean MIME type, or an empty string\n *\n * @todo - handle more advanced MIMETYpes, multiple types\n * @todo - extract charset etc\n */\nexport function parseMIMETypeFromURL(url: string): string {\n  // If resource is a data URL, extract any embedded mime type\n  const matches = DATA_URL_PATTERN.exec(url);\n  if (matches) {\n    return matches[1];\n  }\n  return '';\n}\n", "// loaders.gl, MIT license\n\nconst QUERY_STRING_PATTERN = /\\?.*/;\n\nexport function extractQueryString(url): string {\n  const matches = url.match(QUERY_STRING_PATTERN);\n  return matches && matches[0];\n}\n\nexport function stripQueryString(url): string {\n  return url.replace(QUERY_STRING_PATTERN, '');\n}\n", "// loaders.gl, MIT license\n\nimport {isResponse, isBlob} from '../../javascript-utils/is-type';\nimport {parseMIMEType, parseMIMETypeFromURL} from './mime-type-utils';\nimport {stripQueryString} from './url-utils';\n\n/**\n * A loadable resource. Includes:\n * `Response`, `Blob` (`File` is a subclass), string URLs and data URLs\n */\nexport type Resource = Response | Blob | string;\n\n/**\n * Returns the URL associated with this resource.\n * The returned value may include a query string and need further processing.\n * If it cannot determine url, the corresponding value will be an empty string\n *\n * @todo string parameters are assumed to be URLs\n */\nexport function getResourceUrl(resource: unknown): string {\n  // If resource is a `Response`, it contains the information directly as a field\n  if (isResponse(resource)) {\n    const response = resource as Response;\n    return response.url;\n  }\n\n  // If the resource is a Blob or a File (subclass of Blob)\n  if (isBlob(resource)) {\n    const blob = resource as Blob;\n    // File objects have a \"name\" property. Blob objects don't have any\n    // url (name) information\n    return blob.name || '';\n  }\n\n  if (typeof resource === 'string') {\n    return resource;\n  }\n\n  // Unknown\n  return '';\n}\n\n/**\n * Returns the URL associated with this resource.\n * The returned value may include a query string and need further processing.\n * If it cannot determine url, the corresponding value will be an empty string\n *\n * @todo string parameters are assumed to be URLs\n */\nexport function getResourceMIMEType(resource: unknown): string {\n  // If resource is a response, it contains the information directly\n  if (isResponse(resource)) {\n    const response = resource as Response;\n    const contentTypeHeader = response.headers.get('content-type') || '';\n    const noQueryUrl = stripQueryString(response.url);\n    return parseMIMEType(contentTypeHeader) || parseMIMETypeFromURL(noQueryUrl);\n  }\n\n  // If the resource is a Blob or a File (subclass of Blob)\n  if (isBlob(resource)) {\n    const blob = resource as Blob;\n    return blob.type || '';\n  }\n\n  if (typeof resource === 'string') {\n    return parseMIMETypeFromURL(resource);\n  }\n\n  // Unknown\n  return '';\n}\n\n/**\n  * Returns (approximate) content length for a resource if it can be determined.\n  * Returns -1 if content length cannot be determined.\n  * @param resource\n\n  * @note string parameters are NOT assumed to be URLs\n  */\nexport function getResourceContentLength(resource: unknown): number {\n  if (isResponse(resource)) {\n    const response = resource as Response;\n    return response.headers['content-length'] || -1;\n  }\n  if (isBlob(resource)) {\n    const blob = resource as Blob;\n    return blob.size;\n  }\n  if (typeof resource === 'string') {\n    // TODO - handle data URL?\n    return resource.length;\n  }\n  if (resource instanceof ArrayBuffer) {\n    return resource.byteLength;\n  }\n  if (ArrayBuffer.isView(resource)) {\n    return resource.byteLength;\n  }\n  return -1;\n}\n", "import {isResponse} from '../../javascript-utils/is-type';\nimport {getResourceContentLength, getResourceUrl, getResourceMIMEType} from './resource-utils';\n\n/**\n * Returns a Response object\n * Adds content-length header when possible\n *\n * @param resource\n */\nexport async function makeResponse(resource: any): Promise<Response> {\n  if (isResponse(resource)) {\n    return resource;\n  }\n\n  // Add content-length header if possible\n  const headers: {[header: string]: string} = {};\n\n  const contentLength = getResourceContentLength(resource);\n  if (contentLength >= 0) {\n    headers['content-length'] = String(contentLength);\n  }\n\n  // `new Response(File)` does not preserve content-type and URL\n  // so we add them here\n  const url = getResourceUrl(resource);\n  const type = getResourceMIMEType(resource);\n  if (type) {\n    headers['content-type'] = type;\n  }\n\n  // Add a custom header with initial bytes if available\n  const initialDataUrl = await getInitialDataUrl(resource);\n  if (initialDataUrl) {\n    headers['x-first-bytes'] = initialDataUrl;\n  }\n\n  // TODO - is this the best way of handling strings?\n  // Maybe package as data URL instead?\n  if (typeof resource === 'string') {\n    // Convert to ArrayBuffer to avoid Response treating it as a URL\n    resource = new TextEncoder().encode(resource);\n  }\n\n  // Attempt to create a Response from the resource, adding headers and setting url\n  const response = new Response(resource, {headers});\n  // We can't control `Response.url` via constructor, use a property override to record URL.\n  Object.defineProperty(response, 'url', {value: url});\n  return response;\n}\n\n/**\n * Checks response status (async) and throws a helpful error message if status is not OK.\n * @param response\n */\nexport async function checkResponse(response: Response): Promise<void> {\n  if (!response.ok) {\n    const message = await getResponseError(response);\n    throw new Error(message);\n  }\n}\n\n/**\n * Checks response status (sync) and throws a helpful error message if status is not OK.\n * @param response\n */\nexport function checkResponseSync(response: Response): void {\n  if (!response.ok) {\n    let message = `${response.status} ${response.statusText}`;\n    message = message.length > 60 ? `${message.slice(0, 60)}...` : message;\n    throw new Error(message);\n  }\n}\n\n// HELPERS\n\nasync function getResponseError(response): Promise<string> {\n  let message = `Failed to fetch resource ${response.url} (${response.status}): `;\n  try {\n    const contentType = response.headers.get('Content-Type');\n    let text = response.statusText;\n    if (contentType.includes('application/json')) {\n      text += ` ${await response.text()}`;\n    }\n    message += text;\n    message = message.length > 60 ? `${message.slice(0, 60)}...` : message;\n  } catch (error) {\n    // eslint forbids return in a finally statement, so we just catch here\n  }\n  return message;\n}\n\nasync function getInitialDataUrl(resource): Promise<string | null> {\n  const INITIAL_DATA_LENGTH = 5;\n  if (typeof resource === 'string') {\n    return `data:,${resource.slice(0, INITIAL_DATA_LENGTH)}`;\n  }\n  if (resource instanceof Blob) {\n    const blobSlice = resource.slice(0, 5);\n    return await new Promise((resolve) => {\n      const reader = new FileReader();\n      reader.onload = (event) => resolve(event?.target?.result as string);\n      reader.readAsDataURL(blobSlice);\n    });\n  }\n  if (resource instanceof ArrayBuffer) {\n    const slice = resource.slice(0, INITIAL_DATA_LENGTH);\n    const base64 = arrayBufferToBase64(slice);\n    return `data:base64,${base64}`;\n  }\n  return null;\n}\n\n// https://stackoverflow.com/questions/9267899/arraybuffer-to-base64-encoded-string\nfunction arrayBufferToBase64(buffer) {\n  let binary = '';\n  const bytes = new Uint8Array(buffer);\n  for (let i = 0; i < bytes.byteLength; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return btoa(binary);\n}\n", "import {resolvePath} from '@loaders.gl/loader-utils';\nimport {makeResponse} from '../utils/response-utils';\n// import {getErrorMessageFromResponse} from './fetch-error-message';\n\n/**\n * fetch compatible function\n * Reads file data from:\n * - http/http urls\n * - data urls\n * - File/Blob objects\n * Leverages `@loaders.gl/polyfills` for Node.js support\n * Respects pathPrefix and file aliases\n */\nexport async function fetchFile(\n  url: string | Blob,\n  options?: RequestInit & {fetch?: RequestInit | Function}\n): Promise<Response> {\n  if (typeof url === 'string') {\n    url = resolvePath(url);\n\n    let fetchOptions: RequestInit = options as RequestInit;\n    if (options?.fetch && typeof options?.fetch !== 'function') {\n      fetchOptions = options.fetch;\n    }\n\n    return await fetch(url, fetchOptions);\n  }\n\n  return await makeResponse(url);\n}\n", "//\nimport {fs} from '@loaders.gl/loader-utils';\n\n/**\n * Reads a chunk from a random access file\n * @param file\n * @param start\n * @param length\n * @returns\n */\nexport async function readArrayBuffer(\n  file: Blob | ArrayBuffer | string | number,\n  start: number,\n  length: number\n): Promise<ArrayBuffer> {\n  if (typeof file === 'number') {\n    return await fs._readToArrayBuffer(file, start, length);\n  }\n  // TODO - we can do better for ArrayBuffer and string\n  if (!(file instanceof Blob)) {\n    file = new Blob([file]);\n  }\n  const slice = file.slice(start, start + length);\n  return await readBlob(slice);\n}\n\n/**\n * Read a slice of a Blob or File, without loading the entire file into memory\n * The trick when reading File objects is to read successive \"slices\" of the File\n * Per spec https://w3c.github.io/FileAPI/, slicing a File only updates the start and end fields\n * Actually reading from file happens in `readAsArrayBuffer`\n * @param blob to read\n */\nexport async function readBlob(blob: Blob): Promise<ArrayBuffer> {\n  return await new Promise((resolve, reject) => {\n    const fileReader = new FileReader();\n    fileReader.onload = (event: ProgressEvent<FileReader>) =>\n      resolve(event?.target?.result as ArrayBuffer);\n    // TODO - reject with a proper Error\n    fileReader.onerror = (error: ProgressEvent<FileReader>) => reject(error);\n    fileReader.readAsArrayBuffer(blob);\n  });\n}\n", "// File read\nimport {isBrowser, resolvePath, fs, toArrayBuffer} from '@loaders.gl/loader-utils';\nimport {assert} from '@loaders.gl/loader-utils';\n\n// TODO - this is not tested\n// const isDataURL = (url) => url.startsWith('data:');\n\n/**\n * In a few cases (data URIs, node.js) \"files\" can be read synchronously\n */\nexport function readFileSync(url: string, options: object = {}) {\n  url = resolvePath(url);\n\n  // Only support this if we can also support sync data URL decoding in browser\n  // if (isDataURL(url)) {\n  //   return decodeDataUri(url);\n  // }\n\n  if (!isBrowser) {\n    const buffer = fs.readFileSync(url, options);\n    return typeof buffer !== 'string' ? toArrayBuffer(buffer) : buffer;\n  }\n\n  // @ts-ignore\n  if (!options.nothrow) {\n    // throw new Error('Cant load URI synchronously');\n    assert(false);\n  }\n\n  return null;\n}\n", "// file write\nimport {isBrowser, assert, resolvePath} from '@loaders.gl/loader-utils';\nimport {fs, toBuffer} from '@loaders.gl/loader-utils';\n\nexport async function writeFile(\n  filePath: string,\n  arrayBufferOrString: ArrayBuffer | string,\n  options?\n): Promise<void> {\n  filePath = resolvePath(filePath);\n  if (!isBrowser) {\n    await fs.writeFile(filePath, toBuffer(arrayBufferOrString), {flag: 'w'});\n  }\n  assert(false);\n}\n\nexport function writeFileSync(\n  filePath: string,\n  arrayBufferOrString: ArrayBuffer | string,\n  options?\n): void {\n  filePath = resolvePath(filePath);\n  if (!isBrowser) {\n    fs.writeFileSync(filePath, toBuffer(arrayBufferOrString), {flag: 'w'});\n  }\n  assert(false);\n}\n", "// based on https://github.com/cheton/is-electron\n// https://github.com/electron/electron/issues/2288\n/* eslint-disable complexity */\nexport default function isElectron(mockUserAgent?: string): boolean {\n  // Renderer process\n  if (\n    typeof window !== 'undefined' &&\n    typeof window.process === 'object' &&\n    // @ts-expect-error\n    window.process.type === 'renderer'\n  ) {\n    return true;\n  }\n  // Main process\n  if (\n    typeof process !== 'undefined' &&\n    typeof process.versions === 'object' &&\n    // eslint-disable-next-line\n    Boolean(process.versions['electron'])\n  ) {\n    return true;\n  }\n  // Detect the user agent when the `nodeIntegration` option is set to true\n  const realUserAgent =\n    typeof navigator === 'object' && typeof navigator.userAgent === 'string' && navigator.userAgent;\n  const userAgent = mockUserAgent || realUserAgent;\n  if (userAgent && userAgent.indexOf('Electron') >= 0) {\n    return true;\n  }\n  return false;\n}\n", "// This function is needed in initialization stages,\n// make sure it can be imported in isolation\n\nimport isElectron from './is-electron';\n\nexport default function isBrowser(): boolean {\n  // Check if in browser by duck-typing Node context\n  const isNode =\n    // @ts-expect-error\n    typeof process === 'object' && String(process) === '[object process]' && !process.browser;\n\n  return !isNode || isElectron();\n}\n\n// document does not exist on worker thread\nexport function isBrowserMainThread(): boolean {\n  return isBrowser() && typeof document !== 'undefined';\n}\n", "/* eslint-disable no-restricted-globals */\nconst globals = {\n  self: typeof self !== 'undefined' && self,\n  window: typeof window !== 'undefined' && window,\n  global: typeof global !== 'undefined' && global,\n  document: typeof document !== 'undefined' && document,\n  process: typeof process === 'object' && process\n};\n\nconst global_ = globalThis;\nconst self_ = globals.self || globals.window || globals.global;\nconst window_ = globals.window || globals.self || globals.global;\nconst document_ = globals.document || {};\nconst process_ = globals.process || {};\nconst console_ = console;\n\nexport {\n  self_ as self,\n  window_ as window,\n  global_ as global,\n  document_ as document,\n  process_ as process,\n  console_ as console\n};\n", "import checkIfBrowser from '../lib/is-browser';\n\nexport {self, window, global, document, process, console} from '../lib/globals';\n\n// Extract injected version from package.json (injected by babel plugin)\n// @ts-expect-error\nexport const VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'untranspiled source';\n\nexport const isBrowser = checkIfBrowser();\n", "// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// This function is needed in initialization stages,\n// make sure it can be imported in isolation\n\nimport isBrowser from './is-browser';\nimport isElectron from './is-electron';\n\nconst window = globalThis;\n\nexport function isMobile(): boolean {\n  return typeof window.orientation !== 'undefined';\n}\n\n// Simple browser detection\n// `mockUserAgent` parameter allows user agent to be overridden for testing\n/* eslint-disable complexity */\nexport default function getBrowser(\n  mockUserAgent?: string\n): 'Node' | 'Electron' | 'Chrome' | 'Firefox' | 'Safari' | 'Edge' | 'IE' | 'Unknown' {\n  if (!mockUserAgent && !isBrowser()) {\n    return 'Node';\n  }\n\n  if (isElectron(mockUserAgent)) {\n    return 'Electron';\n  }\n\n  const navigator_ = typeof navigator !== 'undefined' ? navigator : {};\n  // @ts-expect-error\n  const userAgent = mockUserAgent || navigator_.userAgent || '';\n  // const appVersion = navigator_.appVersion || '';\n\n  // NOTE: Order of tests matter, as many agents list Chrome etc.\n  if (userAgent.indexOf('Edge') > -1) {\n    return 'Edge';\n  }\n  const isMSIE = userAgent.indexOf('MSIE ') !== -1;\n  const isTrident = userAgent.indexOf('Trident/') !== -1;\n  if (isMSIE || isTrident) {\n    return 'IE';\n  }\n  if (window.chrome) {\n    return 'Chrome';\n  }\n  if (window.safari) {\n    return 'Safari';\n  }\n  if (window.mozInnerScreenX) {\n    return 'Firefox';\n  }\n  return 'Unknown';\n}\n", "// probe.gl, MIT license\n\nfunction getStorage(type): Storage {\n  try {\n    // @ts-expect-error\n    const storage: Storage = window[type];\n    const x = '__storage_test__';\n    storage.setItem(x, x);\n    storage.removeItem(x);\n    return storage;\n  } catch (e) {\n    return null;\n  }\n}\n\n// Store keys in local storage via simple interface\nexport class LocalStorage<Configuration extends {}> {\n  storage: Storage;\n  id: string;\n  config: Required<Configuration>;\n\n  constructor(id: string, defaultConfig: Required<Configuration>, type = 'sessionStorage') {\n    this.storage = getStorage(type);\n    this.id = id;\n    this.config = defaultConfig;\n    this._loadConfiguration();\n  }\n\n  getConfiguration(): Required<Configuration> {\n    return this.config;\n  }\n\n  setConfiguration(configuration: Configuration): void {\n    Object.assign(this.config, configuration);\n    if (this.storage) {\n      const serialized = JSON.stringify(this.config);\n      this.storage.setItem(this.id, serialized);\n    }\n  }\n\n  // Get config from persistent store, if available\n  _loadConfiguration() {\n    let configuration = {};\n    if (this.storage) {\n      const serializedConfiguration = this.storage.getItem(this.id);\n      configuration = serializedConfiguration ? JSON.parse(serializedConfiguration) : {};\n    }\n    Object.assign(this.config, configuration);\n    return this;\n  }\n}\n", "// TODO: Currently unused, keeping in case we want it later for log formatting\nexport function formatTime(ms: number): string {\n  let formatted;\n  if (ms < 10) {\n    formatted = `${ms.toFixed(2)}ms`;\n  } else if (ms < 100) {\n    formatted = `${ms.toFixed(1)}ms`;\n  } else if (ms < 1000) {\n    formatted = `${ms.toFixed(0)}ms`;\n  } else {\n    formatted = `${(ms / 1000).toFixed(2)}s`;\n  }\n  return formatted;\n}\n\nexport function leftPad(string: string, length: number = 8): string {\n  const padLength = Math.max(length - string.length, 0);\n  return `${' '.repeat(padLength)}${string}`;\n}\n\nexport function rightPad(string: string, length: number = 8): string {\n  const padLength = Math.max(length - string.length, 0);\n  return `${string}${' '.repeat(padLength)}`;\n}\n\nexport function formatValue(v: unknown, opts: {isInteger?: boolean} = {}): string {\n  const EPSILON = 1e-16;\n  const {isInteger = false} = opts;\n  if (Array.isArray(v) || ArrayBuffer.isView(v)) {\n    return formatArrayValue(v, opts);\n  }\n  if (!Number.isFinite(v)) {\n    return String(v);\n  }\n  // @ts-expect-error\n  if (Math.abs(v) < EPSILON) {\n    return isInteger ? '0' : '0.';\n  }\n  if (isInteger) {\n    // @ts-expect-error\n    return v.toFixed(0);\n  }\n  // @ts-expect-error\n  if (Math.abs(v) > 100 && Math.abs(v) < 10000) {\n    // @ts-expect-error\n    return v.toFixed(0);\n  }\n  // @ts-expect-error\n  const string = v.toPrecision(2);\n  const decimal = string.indexOf('.0');\n  return decimal === string.length - 2 ? string.slice(0, -1) : string;\n}\n\n/** Helper to formatValue */\nfunction formatArrayValue(v, opts) {\n  const {maxElts = 16, size = 1} = opts;\n  let string = '[';\n  for (let i = 0; i < v.length && i < maxElts; ++i) {\n    if (i > 0) {\n      string += `,${i % size === 0 ? ' ' : ''}`;\n    }\n    string += formatValue(v[i], opts);\n  }\n  const terminator = v.length > maxElts ? '...' : ']';\n  return `${string}${terminator}`;\n}\n\n/** Inspired by https://github.com/hughsk/console-image (MIT license) */\nexport function formatImage(image, message, scale, maxWidth = 600) {\n  const imageUrl = image.src.replace(/\\(/g, '%28').replace(/\\)/g, '%29');\n\n  if (image.width > maxWidth) {\n    scale = Math.min(scale, maxWidth / image.width);\n  }\n\n  const width = image.width * scale;\n  const height = image.height * scale;\n\n  const style = [\n    'font-size:1px;',\n    `padding:${Math.floor(height / 2)}px ${Math.floor(width / 2)}px;`,\n    `line-height:${height}px;`,\n    `background:url(${imageUrl});`,\n    `background-size:${width}px ${height}px;`,\n    'color:transparent;'\n  ].join('');\n\n  return [`${message} %c+`, style];\n}\n", "import {isBrowser} from '@probe.gl/env';\n\nexport enum COLOR {\n  BLACK = 30,\n  RED = 31,\n  GREEN = 32,\n  YELLOW = 33,\n  BLUE = 34,\n  MAGENTA = 35,\n  CYAN = 36,\n  WHITE = 37,\n\n  BRIGHT_BLACK = 90,\n  BRIGHT_RED = 91,\n  BRIGHT_GREEN = 92,\n  BRIGHT_YELLOW = 93,\n  BRIGHT_BLUE = 94,\n  BRIGHT_MAGENTA = 95,\n  BRIGHT_CYAN = 96,\n  BRIGHT_WHITE = 97\n}\n\nfunction getColor(color): number {\n  return typeof color === 'string' ? COLOR[color.toUpperCase()] || COLOR.WHITE : color;\n}\n\nexport function addColor(string, color, background?): string {\n  if (!isBrowser && typeof string === 'string') {\n    if (color) {\n      color = getColor(color);\n      string = `\\u001b[${color}m${string}\\u001b[39m`;\n    }\n    if (background) {\n      // background colors values are +10\n      color = getColor(background);\n      string = `\\u001b[${background + 10}m${string}\\u001b[49m`;\n    }\n  }\n  return string;\n}\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/**\n * Binds the \"this\" argument of all functions on a class instance to the instance\n * @param obj - class instance (typically a react component)\n */\nexport function autobind(obj: object, predefined = ['constructor']): void {\n  const proto = Object.getPrototypeOf(obj);\n  const propNames = Object.getOwnPropertyNames(proto);\n  for (const key of propNames) {\n    if (typeof obj[key] === 'function') {\n      if (!predefined.find(name => key === name)) {\n        obj[key] = obj[key].bind(obj);\n      }\n    }\n  }\n}\n", "export default function assert(condition: unknown, message?: string): asserts condition {\n  if (!condition) {\n    throw new Error(message || 'Assertion failed');\n  }\n}\n", "// probe.gl, MIT license\n\nimport {window, process, isBrowser} from '@probe.gl/env';\n\n/** Get best timer available. */\nexport function getHiResTimestamp() {\n  let timestamp;\n  if (isBrowser && 'performance' in window) {\n    timestamp = window?.performance?.now?.();\n  } else if ('hrtime' in process) {\n    // @ts-ignore\n    const timeParts = process?.hrtime?.();\n    timestamp = timeParts[0] * 1000 + timeParts[1] / 1e6;\n  } else {\n    timestamp = Date.now();\n  }\n\n  return timestamp;\n}\n", "// probe.gl, MIT license\n\n/* eslint-disable no-console */\nimport {VERSION, isBrowser} from '@probe.gl/env';\nimport {LocalStorage} from './utils/local-storage';\nimport {formatImage, formatTime, leftPad} from './utils/formatters';\nimport {addColor} from './utils/color';\nimport {autobind} from './utils/autobind';\nimport assert from './utils/assert';\nimport {getHiResTimestamp} from './utils/hi-res-timestamp';\n\n// Instrumentation in other packages may override console methods, so preserve them here\nconst originalConsole = {\n  debug: isBrowser ? console.debug || console.log : console.log,\n  log: console.log,\n  info: console.info,\n  warn: console.warn,\n  error: console.error\n};\n\ntype Table = Record<string, any>;\n\ntype LogFunction = () => void;\n\ntype LogOptions = {\n  method?;\n  time?;\n  total?: number;\n  delta?: number;\n  tag?: string;\n  message?: string;\n  once?: boolean;\n  nothrottle?: boolean;\n  args?: any;\n};\n\ntype LogSettings = {\n  enabled?: boolean;\n  level?: number;\n  [key: string]: any;\n};\n\nconst DEFAULT_SETTINGS: Required<LogSettings> = {\n  enabled: true,\n  level: 0\n};\n\nfunction noop() {} // eslint-disable-line @typescript-eslint/no-empty-function\n\nconst cache = {};\nconst ONCE = {once: true};\n\ntype LogConfiguration = {\n  enabled?: boolean;\n  level?: number;\n};\n\n/** A console wrapper */\n\nexport class Log {\n  static VERSION = VERSION;\n\n  id: string;\n  VERSION: string = VERSION;\n  _startTs: number = getHiResTimestamp();\n  _deltaTs: number = getHiResTimestamp();\n  _storage: LocalStorage<LogConfiguration>;\n  userData = {};\n\n  // TODO - fix support from throttling groups\n  LOG_THROTTLE_TIMEOUT: number = 0; // Time before throttled messages are logged again\n\n  constructor({id} = {id: ''}) {\n    this.id = id;\n    this.userData = {};\n    this._storage = new LocalStorage<LogConfiguration>(`__probe-${this.id}__`, DEFAULT_SETTINGS);\n\n    this.timeStamp(`${this.id} started`);\n\n    autobind(this);\n    Object.seal(this);\n  }\n\n  set level(newLevel: number) {\n    this.setLevel(newLevel);\n  }\n\n  get level(): number {\n    return this.getLevel();\n  }\n\n  isEnabled(): boolean {\n    return this._storage.config.enabled;\n  }\n\n  getLevel(): number {\n    return this._storage.config.level;\n  }\n\n  /** @return milliseconds, with fractions */\n  getTotal(): number {\n    return Number((getHiResTimestamp() - this._startTs).toPrecision(10));\n  }\n\n  /** @return milliseconds, with fractions */\n  getDelta(): number {\n    return Number((getHiResTimestamp() - this._deltaTs).toPrecision(10));\n  }\n\n  /** @deprecated use logLevel */\n  set priority(newPriority: number) {\n    this.level = newPriority;\n  }\n\n  /** @deprecated use logLevel */\n  get priority(): number {\n    return this.level;\n  }\n\n  /** @deprecated use logLevel */\n  getPriority(): number {\n    return this.level;\n  }\n\n  // Configure\n\n  enable(enabled: boolean = true): this {\n    this._storage.setConfiguration({enabled});\n    return this;\n  }\n\n  setLevel(level: number): this {\n    this._storage.setConfiguration({level});\n    return this;\n  }\n\n  /** return the current status of the setting */\n  get(setting: string): any {\n    return this._storage.config[setting];\n  }\n\n  // update the status of the setting\n  set(setting: string, value: any): void {\n    this._storage.setConfiguration({[setting]: value});\n  }\n\n  /** Logs the current settings as a table */\n  settings(): void {\n    if (console.table) {\n      console.table(this._storage.config);\n    } else {\n      console.log(this._storage.config);\n    }\n  }\n\n  // Unconditional logging\n\n  assert(condition: unknown, message?: string): asserts condition {\n    assert(condition, message);\n  }\n\n  /** Warn, but only once, no console flooding */\n  warn(message: string, ...args): LogFunction;\n  warn(message: string): LogFunction {\n    return this._getLogFunction(0, message, originalConsole.warn, arguments, ONCE);\n  }\n\n  /** Print an error */\n  error(message: string, ...args): LogFunction;\n  error(message: string): LogFunction {\n    return this._getLogFunction(0, message, originalConsole.error, arguments);\n  }\n\n  /** Print a deprecation warning */\n  deprecated(oldUsage: string, newUsage: string): LogFunction {\n    return this.warn(`\\`${oldUsage}\\` is deprecated and will be removed \\\nin a later version. Use \\`${newUsage}\\` instead`);\n  }\n\n  /** Print a removal warning */\n  removed(oldUsage: string, newUsage: string): LogFunction {\n    return this.error(`\\`${oldUsage}\\` has been removed. Use \\`${newUsage}\\` instead`);\n  }\n\n  // Conditional logging\n\n  /** Log to a group */\n  probe(logLevel, message?, ...args): LogFunction;\n  probe(logLevel, message?): LogFunction {\n    return this._getLogFunction(logLevel, message, originalConsole.log, arguments, {\n      time: true,\n      once: true\n    });\n  }\n\n  /** Log a debug message */\n  log(logLevel, message?, ...args): LogFunction;\n  log(logLevel, message?): LogFunction {\n    return this._getLogFunction(logLevel, message, originalConsole.debug, arguments);\n  }\n\n  /** Log a normal message */\n  info(logLevel, message?, ...args): LogFunction;\n  info(logLevel, message?): LogFunction {\n    return this._getLogFunction(logLevel, message, console.info, arguments);\n  }\n\n  /** Log a normal message, but only once, no console flooding */\n  once(logLevel, message?, ...args): LogFunction;\n  once(logLevel, message?, ...args) {\n    return this._getLogFunction(\n      logLevel,\n      message,\n      originalConsole.debug || originalConsole.info,\n      arguments,\n      ONCE\n    );\n  }\n\n  /** Logs an object as a table */\n  table(logLevel, table?, columns?): LogFunction {\n    if (table) {\n      // @ts-expect-error Not clear how this works, columns being passed as arguments\n      return this._getLogFunction(logLevel, table, console.table || noop, columns && [columns], {\n        tag: getTableHeader(table)\n      });\n    }\n    return noop;\n  }\n\n  /** logs an image under Chrome */\n  image({logLevel, priority, image, message = '', scale = 1}): LogFunction {\n    if (!this._shouldLog(logLevel || priority)) {\n      return noop;\n    }\n    return isBrowser\n      ? logImageInBrowser({image, message, scale})\n      : logImageInNode({image, message, scale});\n  }\n\n  time(logLevel, message) {\n    return this._getLogFunction(logLevel, message, console.time ? console.time : console.info);\n  }\n\n  timeEnd(logLevel, message) {\n    return this._getLogFunction(\n      logLevel,\n      message,\n      console.timeEnd ? console.timeEnd : console.info\n    );\n  }\n\n  timeStamp(logLevel, message?) {\n    return this._getLogFunction(logLevel, message, console.timeStamp || noop);\n  }\n\n  group(logLevel, message, opts = {collapsed: false}) {\n    const options = normalizeArguments({logLevel, message, opts});\n    const {collapsed} = opts;\n    // @ts-expect-error\n    options.method = (collapsed ? console.groupCollapsed : console.group) || console.info;\n\n    return this._getLogFunction(options);\n  }\n\n  groupCollapsed(logLevel, message, opts = {}) {\n    return this.group(logLevel, message, Object.assign({}, opts, {collapsed: true}));\n  }\n\n  groupEnd(logLevel) {\n    return this._getLogFunction(logLevel, '', console.groupEnd || noop);\n  }\n\n  // EXPERIMENTAL\n\n  withGroup(logLevel: number, message: string, func: Function): void {\n    this.group(logLevel, message)();\n\n    try {\n      func();\n    } finally {\n      this.groupEnd(logLevel)();\n    }\n  }\n\n  trace(): void {\n    if (console.trace) {\n      console.trace();\n    }\n  }\n\n  // PRIVATE METHODS\n\n  /** Deduces log level from a variety of arguments */\n  _shouldLog(logLevel: unknown): boolean {\n    return this.isEnabled() && this.getLevel() >= normalizeLogLevel(logLevel);\n  }\n\n  _getLogFunction(\n    logLevel: unknown,\n    message?: unknown,\n    method?: Function,\n    args?: IArguments,\n    opts?: LogOptions\n  ): LogFunction {\n    if (this._shouldLog(logLevel)) {\n      // normalized opts + timings\n      opts = normalizeArguments({logLevel, message, args, opts});\n      method = method || opts.method;\n      assert(method);\n\n      opts.total = this.getTotal();\n      opts.delta = this.getDelta();\n      // reset delta timer\n      this._deltaTs = getHiResTimestamp();\n\n      const tag = opts.tag || opts.message;\n\n      if (opts.once) {\n        if (!cache[tag]) {\n          cache[tag] = getHiResTimestamp();\n        } else {\n          return noop;\n        }\n      }\n\n      // TODO - Make throttling work with groups\n      // if (opts.nothrottle || !throttle(tag, this.LOG_THROTTLE_TIMEOUT)) {\n      //   return noop;\n      // }\n\n      message = decorateMessage(this.id, opts.message, opts);\n\n      // Bind console function so that it can be called after being returned\n      return method.bind(console, message, ...opts.args);\n    }\n    return noop;\n  }\n}\n\n/**\n * Get logLevel from first argument:\n * - log(logLevel, message, args) => logLevel\n * - log(message, args) => 0\n * - log({logLevel, ...}, message, args) => logLevel\n * - log({logLevel, message, args}) => logLevel\n */\nfunction normalizeLogLevel(logLevel: unknown): number {\n  if (!logLevel) {\n    return 0;\n  }\n  let resolvedLevel;\n\n  switch (typeof logLevel) {\n    case 'number':\n      resolvedLevel = logLevel;\n      break;\n\n    case 'object':\n      // Backward compatibility\n      // TODO - deprecate `priority`\n      // @ts-expect-error\n      resolvedLevel = logLevel.logLevel || logLevel.priority || 0;\n      break;\n\n    default:\n      return 0;\n  }\n  // 'log level must be a number'\n  assert(Number.isFinite(resolvedLevel) && resolvedLevel >= 0);\n\n  return resolvedLevel;\n}\n\n/**\n * \"Normalizes\" the various argument patterns into an object with known types\n * - log(logLevel, message, args) => {logLevel, message, args}\n * - log(message, args) => {logLevel: 0, message, args}\n * - log({logLevel, ...}, message, args) => {logLevel, message, args}\n * - log({logLevel, message, args}) => {logLevel, message, args}\n */\nexport function normalizeArguments(opts: {\n  logLevel;\n  message;\n  collapsed?: boolean;\n  args?: IArguments;\n  opts?;\n}): {\n  logLevel: number;\n  message: string;\n  args: any[];\n} {\n  const {logLevel, message} = opts;\n  opts.logLevel = normalizeLogLevel(logLevel);\n\n  // We use `arguments` instead of rest parameters (...args) because IE\n  // does not support the syntax. Rest parameters is transpiled to code with\n  // perf impact. Doing it here instead avoids constructing args when logging is\n  // disabled.\n  // TODO - remove when/if IE support is dropped\n  const args: any[] = opts.args ? Array.from(opts.args) : [];\n  // args should only contain arguments that appear after `message`\n  // eslint-disable-next-line no-empty\n  while (args.length && args.shift() !== message) {}\n\n  switch (typeof logLevel) {\n    case 'string':\n    case 'function':\n      if (message !== undefined) {\n        args.unshift(message);\n      }\n      opts.message = logLevel;\n      break;\n\n    case 'object':\n      Object.assign(opts, logLevel);\n      break;\n\n    default:\n  }\n\n  // Resolve functions into strings by calling them\n  if (typeof opts.message === 'function') {\n    opts.message = opts.message();\n  }\n  const messageType = typeof opts.message;\n  // 'log message must be a string' or object\n  assert(messageType === 'string' || messageType === 'object');\n\n  // original opts + normalized opts + opts arg + fixed up message\n  return Object.assign(opts, {args}, opts.opts);\n}\n\nfunction decorateMessage(id, message, opts) {\n  if (typeof message === 'string') {\n    const time = opts.time ? leftPad(formatTime(opts.total)) : '';\n    message = opts.time ? `${id}: ${time}  ${message}` : `${id}: ${message}`;\n    message = addColor(message, opts.color, opts.background);\n  }\n  return message;\n}\n\n/** @deprecated Function removed */\nfunction logImageInNode({image, message = '', scale = 1}) {\n  console.warn('removed');\n  return noop;\n}\n\nfunction logImageInBrowser({image, message = '', scale = 1}) {\n  if (typeof image === 'string') {\n    const img = new Image();\n    img.onload = () => {\n      const args = formatImage(img, message, scale);\n      console.log(...args);\n    };\n    img.src = image;\n    return noop;\n  }\n  const element = image.nodeName || '';\n  if (element.toLowerCase() === 'img') {\n    console.log(...formatImage(image, message, scale));\n    return noop;\n  }\n  if (element.toLowerCase() === 'canvas') {\n    const img = new Image();\n    img.onload = () => console.log(...formatImage(img, message, scale));\n    img.src = image.toDataURL();\n    return noop;\n  }\n  return noop;\n}\n\nfunction getTableHeader(table: Table): string {\n  for (const key in table) {\n    for (const title in table[key]) {\n      return title || 'untitled';\n    }\n  }\n  return 'empty';\n}\n", "// @ts-nocheck\n/* eslint-disable */\nglobalThis.probe = {};\n", "import {Log} from './log';\n\n// DEFAULT EXPORT IS A LOG INSTANCE\nexport default new Log({id: '@probe.gl/log'});\n\n// LOGGING\nexport {Log} from './log';\nexport {COLOR} from './utils/color';\n\n// UTILITIES\nexport {addColor} from './utils/color';\nexport {leftPad, rightPad} from './utils/formatters';\nexport {autobind} from './utils/autobind';\nexport {LocalStorage} from './utils/local-storage';\nexport {getHiResTimestamp} from './utils/hi-res-timestamp';\n\nimport './init';\n", "// probe.gl Log compatible loggers\nimport {Log} from '@probe.gl/log';\n\nexport const probeLog = new Log({id: 'loaders.gl'});\n\n// Logs nothing\nexport class NullLog {\n  log() {\n    return () => {};\n  }\n  info() {\n    return () => {};\n  }\n  warn() {\n    return () => {};\n  }\n  error() {\n    return () => {};\n  }\n}\n\n// Logs to console\nexport class ConsoleLog {\n  console;\n\n  constructor() {\n    this.console = console; // eslint-disable-line\n  }\n  log(...args) {\n    return this.console.log.bind(this.console, ...args);\n  }\n  info(...args) {\n    return this.console.info.bind(this.console, ...args);\n  }\n  warn(...args) {\n    return this.console.warn.bind(this.console, ...args);\n  }\n  error(...args) {\n    return this.console.error.bind(this.console, ...args);\n  }\n}\n", "import type {LoaderOptions} from '@loaders.gl/loader-utils';\nimport {isBrowser} from '@loaders.gl/loader-utils';\nimport {ConsoleLog} from './loggers';\n\nexport const DEFAULT_LOADER_OPTIONS: LoaderOptions = {\n  // baseUri\n  fetch: null,\n  mimeType: undefined,\n  nothrow: false,\n  log: new ConsoleLog(), // A probe.gl compatible (`log.log()()` syntax) that just logs to console\n\n  CDN: 'https://unpkg.com/@loaders.gl',\n  worker: true, // By default, use worker if provided by loader.\n  maxConcurrency: 3, // How many worker instances should be created for each loader.\n  maxMobileConcurrency: 1, // How many worker instances should be created for each loader on mobile devices.\n  reuseWorkers: isBrowser, // By default reuse workers in browser (Node.js refuses to terminate if browsers are running)\n  _nodeWorkers: false, // By default do not support node workers\n  _workerType: '', // 'test' to use locally generated workers\n\n  limit: 0,\n  _limitMB: 0,\n  batchSize: 'auto',\n  batchDebounceMs: 0,\n  metadata: false, // TODO - currently only implemented for parseInBatches, adds initial metadata batch,\n  transforms: []\n};\n\nexport const REMOVED_LOADER_OPTIONS = {\n  throws: 'nothrow',\n  dataType: '(no longer used)',\n  uri: 'baseUri',\n  // Warn if fetch options are used on top-level\n  method: 'fetch.method',\n  headers: 'fetch.headers',\n  body: 'fetch.body',\n  mode: 'fetch.mode',\n  credentials: 'fetch.credentials',\n  cache: 'fetch.cache',\n  redirect: 'fetch.redirect',\n  referrer: 'fetch.referrer',\n  referrerPolicy: 'fetch.referrerPolicy',\n  integrity: 'fetch.integrity',\n  keepalive: 'fetch.keepalive',\n  signal: 'fetch.signal'\n};\n", "// loaders.gl, MIT license\n\nimport type {Loader, LoaderOptions} from '@loaders.gl/loader-utils';\nimport {isPureObject, isObject} from '../../javascript-utils/is-type';\nimport {probeLog, NullLog} from './loggers';\nimport {DEFAULT_LOADER_OPTIONS, REMOVED_LOADER_OPTIONS} from './option-defaults';\n\n/**\n * Global state for loaders.gl. Stored on `global.loaders._state`\n */\ntype GlobalLoaderState = {\n  loaderRegistry: Loader[];\n  globalOptions: LoaderOptions;\n};\n\n/**\n * Helper for safely accessing global loaders.gl variables\n * Wraps initialization of global variable in function to defeat overly aggressive tree-shakers\n */\nexport function getGlobalLoaderState(): GlobalLoaderState {\n  // @ts-ignore\n  globalThis.loaders = globalThis.loaders || {};\n  // @ts-ignore\n  const {loaders} = globalThis;\n\n  // Add _state object to keep separate from modules added to globalThis.loaders\n  loaders._state = loaders._state || {};\n  return loaders._state;\n}\n\n/**\n * Store global loader options on the global object to increase chances of cross loaders-version interoperability\n * NOTE: This use case is not reliable but can help when testing new versions of loaders.gl with existing frameworks\n * @returns global loader options merged with default loader options\n */\nexport const getGlobalLoaderOptions = (): LoaderOptions => {\n  const state = getGlobalLoaderState();\n  // Ensure all default loader options from this library are mentioned\n  state.globalOptions = state.globalOptions || {...DEFAULT_LOADER_OPTIONS};\n  return state.globalOptions;\n};\n\n/**\n * Set global loader options\n * @param options\n */\nexport function setGlobalOptions(options: LoaderOptions): void {\n  const state = getGlobalLoaderState();\n  const globalOptions = getGlobalLoaderOptions();\n  state.globalOptions = normalizeOptionsInternal(globalOptions, options);\n}\n\n/**\n * Merges options with global opts and loader defaults, also injects baseUri\n * @param options\n * @param loader\n * @param loaders\n * @param url\n */\nexport function normalizeOptions(\n  options: LoaderOptions,\n  loader: Loader,\n  loaders?: Loader[],\n  url?: string\n): LoaderOptions {\n  loaders = loaders || [];\n  loaders = Array.isArray(loaders) ? loaders : [loaders];\n\n  validateOptions(options, loaders);\n  return normalizeOptionsInternal(loader, options, url);\n}\n\n// VALIDATE OPTIONS\n\n/**\n * Warn for unsupported options\n * @param options\n * @param loaders\n */\nfunction validateOptions(options: LoaderOptions, loaders: Loader[]) {\n  // Check top level options\n  validateOptionsObject(options, null, DEFAULT_LOADER_OPTIONS, REMOVED_LOADER_OPTIONS, loaders);\n  for (const loader of loaders) {\n    // Get the scoped, loader specific options from the user supplied options\n    const idOptions = (options && options[loader.id]) || {};\n\n    // Get scoped, loader specific default and deprecated options from the selected loader\n    const loaderOptions = (loader.options && loader.options[loader.id]) || {};\n    const deprecatedOptions =\n      (loader.deprecatedOptions && loader.deprecatedOptions[loader.id]) || {};\n\n    // Validate loader specific options\n    validateOptionsObject(idOptions, loader.id, loaderOptions, deprecatedOptions, loaders);\n  }\n}\n\n// eslint-disable-next-line max-params, complexity\nfunction validateOptionsObject(\n  options,\n  id: string | null,\n  defaultOptions,\n  deprecatedOptions,\n  loaders: Loader[]\n) {\n  const loaderName = id || 'Top level';\n  const prefix = id ? `${id}.` : '';\n\n  for (const key in options) {\n    // If top level option value is an object it could options for a loader, so ignore\n    const isSubOptions = !id && isObject(options[key]);\n    const isBaseUriOption = key === 'baseUri' && !id;\n    const isWorkerUrlOption = key === 'workerUrl' && id;\n    // <loader>.workerUrl requires special handling as it is now auto-generated and no longer specified as a default option.\n    if (!(key in defaultOptions) && !isBaseUriOption && !isWorkerUrlOption) {\n      // Issue deprecation warnings\n      if (key in deprecatedOptions) {\n        probeLog.warn(\n          `${loaderName} loader option \\'${prefix}${key}\\' no longer supported, use \\'${deprecatedOptions[key]}\\'`\n        )();\n      } else if (!isSubOptions) {\n        const suggestion = findSimilarOption(key, loaders);\n        probeLog.warn(\n          `${loaderName} loader option \\'${prefix}${key}\\' not recognized. ${suggestion}`\n        )();\n      }\n    }\n  }\n}\n\nfunction findSimilarOption(optionKey, loaders) {\n  const lowerCaseOptionKey = optionKey.toLowerCase();\n  let bestSuggestion = '';\n  for (const loader of loaders) {\n    for (const key in loader.options) {\n      if (optionKey === key) {\n        return `Did you mean \\'${loader.id}.${key}\\'?`;\n      }\n      const lowerCaseKey = key.toLowerCase();\n      const isPartialMatch =\n        lowerCaseOptionKey.startsWith(lowerCaseKey) || lowerCaseKey.startsWith(lowerCaseOptionKey);\n      if (isPartialMatch) {\n        bestSuggestion = bestSuggestion || `Did you mean \\'${loader.id}.${key}\\'?`;\n      }\n    }\n  }\n  return bestSuggestion;\n}\n\nfunction normalizeOptionsInternal(loader, options, url?: string) {\n  const loaderDefaultOptions = loader.options || {};\n\n  const mergedOptions = {...loaderDefaultOptions};\n\n  addUrlOptions(mergedOptions, url);\n\n  // LOGGING: options.log can be set to `null` to defeat logging\n  if (mergedOptions.log === null) {\n    mergedOptions.log = new NullLog();\n  }\n\n  mergeNestedFields(mergedOptions, getGlobalLoaderOptions());\n  mergeNestedFields(mergedOptions, options);\n\n  return mergedOptions;\n}\n\n// Merge nested options objects\nfunction mergeNestedFields(mergedOptions, options) {\n  for (const key in options) {\n    // Check for nested options\n    // object in options => either no key in defaultOptions or object in defaultOptions\n    if (key in options) {\n      const value = options[key];\n      if (isPureObject(value) && isPureObject(mergedOptions[key])) {\n        mergedOptions[key] = {\n          ...mergedOptions[key],\n          ...options[key]\n        };\n      } else {\n        mergedOptions[key] = options[key];\n      }\n    }\n    // else: No need to merge nested opts, and the initial merge already copied over the nested options\n  }\n}\n\n/**\n * Harvest information from the url\n * @deprecated This is mainly there to support a hack in the GLTFLoader\n * TODO - baseUri should be a directory, i.e. remove file component from baseUri\n * TODO - extract extension?\n * TODO - extract query parameters?\n * TODO - should these be injected on context instead of options?\n */\nfunction addUrlOptions(options, url?: string) {\n  if (url && !('baseUri' in options)) {\n    options.baseUri = url;\n  }\n}\n", "import type {Loader} from '@loaders.gl/loader-utils';\nimport {assert} from '@loaders.gl/loader-utils';\n\nexport function isLoaderObject(loader?: any): boolean {\n  if (!loader) {\n    return false;\n  }\n\n  if (Array.isArray(loader)) {\n    loader = loader[0];\n  }\n\n  const hasExtensions = Array.isArray(loader?.extensions);\n\n  /* Now handled by types and worker loaders do not have these\n  let hasParser =\n    loader.parseTextSync ||\n    loader.parseSync ||\n    loader.parse ||\n    loader.parseStream || // TODO Remove, Replace with parseInBatches\n    loader.parseInBatches;\n  */\n\n  return hasExtensions;\n}\n\nexport function normalizeLoader(loader: Loader): Loader {\n  // This error is fairly easy to trigger by mixing up import statements etc\n  // So we make an exception and add a developer error message for this case\n  // To help new users from getting stuck here\n  assert(loader, 'null loader');\n  assert(isLoaderObject(loader), 'invalid loader');\n\n  // NORMALIZE [LOADER, OPTIONS] => LOADER\n\n  // If [loader, options], create a new loaders object with options merged in\n  let options;\n  if (Array.isArray(loader)) {\n    options = loader[1];\n    loader = loader[0];\n    loader = {\n      ...loader,\n      options: {...loader.options, ...options}\n    };\n  }\n\n  // NORMALIZE text and binary flags\n  // Ensure at least one of text/binary flags are properly set\n\n  // @ts-expect-error\n  if (loader?.parseTextSync || loader?.parseText) {\n    loader.text = true;\n  }\n\n  if (!loader.text) {\n    loader.binary = true;\n  }\n\n  return loader;\n}\n", "import {Loader} from '@loaders.gl/loader-utils';\nimport {normalizeLoader} from '../loader-utils/normalize-loader';\nimport {getGlobalLoaderState} from '../loader-utils/option-utils';\n\n// Store global registered loaders on the global object to increase chances of cross loaders-version interoperability\n// This use case is not reliable but can help when testing new versions of loaders.gl with existing frameworks\nconst getGlobalLoaderRegistry = () => {\n  const state = getGlobalLoaderState();\n  state.loaderRegistry = state.loaderRegistry || [];\n  return state.loaderRegistry;\n};\n\n/** Register a list of global loaders */\nexport function registerLoaders(loaders: Loader[] | Loader) {\n  const loaderRegistry = getGlobalLoaderRegistry();\n\n  loaders = Array.isArray(loaders) ? loaders : [loaders];\n\n  for (const loader of loaders) {\n    const normalizedLoader = normalizeLoader(loader);\n    if (!loaderRegistry.find((registeredLoader) => normalizedLoader === registeredLoader)) {\n      // add to the beginning of the loaderRegistry, so the last registeredLoader get picked\n      loaderRegistry.unshift(normalizedLoader);\n    }\n  }\n}\n\nexport function getRegisteredLoaders(): Loader[] {\n  return getGlobalLoaderRegistry();\n}\n\n/** @deprecated For testing only  */\nexport function _unregisterLoaders() {\n  const state = getGlobalLoaderState();\n  state.loaderRegistry = [];\n}\n", "// loaders.gl, MIT license\nimport {Log} from '@probe.gl/log';\n\nexport const log = new Log({id: 'loaders.gl'});\n", "import type {LoaderContext, LoaderOptions, Loader} from '@loaders.gl/loader-utils';\nimport {compareArrayBuffers, path} from '@loaders.gl/loader-utils';\nimport {normalizeLoader} from '../loader-utils/normalize-loader';\nimport {log} from '../utils/log';\nimport {getResourceUrl, getResourceMIMEType} from '../utils/resource-utils';\nimport {getRegisteredLoaders} from './register-loaders';\nimport {isBlob} from '../../javascript-utils/is-type';\nimport {stripQueryString} from '../utils/url-utils';\n\nconst EXT_PATTERN = /\\.([^.]+)$/;\n\n// TODO - Need a variant that peeks at streams for parseInBatches\n// TODO - Detect multiple matching loaders? Use heuristics to grade matches?\n// TODO - Allow apps to pass context to disambiguate between multiple matches (e.g. multiple .json formats)?\n\n/**\n * Find a loader that matches file extension and/or initial file content\n * Search the loaders array argument for a loader that matches url extension or initial data\n * Returns: a normalized loader\n * @param data data to assist\n * @param loaders\n * @param options\n * @param context used internally, applications should not provide this parameter\n */\nexport async function selectLoader(\n  data: Response | Blob | ArrayBuffer | string,\n  loaders: Loader[] | Loader = [],\n  options?: LoaderOptions,\n  context?: LoaderContext\n): Promise<Loader | null> {\n  if (!validHTTPResponse(data)) {\n    return null;\n  }\n\n  // First make a sync attempt, disabling exceptions\n  let loader = selectLoaderSync(data, loaders, {...options, nothrow: true}, context);\n  if (loader) {\n    return loader;\n  }\n\n  // For Blobs and Files, try to asynchronously read a small initial slice and test again with that\n  // to see if we can detect by initial content\n  if (isBlob(data)) {\n    data = await (data as Blob).slice(0, 10).arrayBuffer();\n    loader = selectLoaderSync(data, loaders, options, context);\n  }\n\n  // no loader available\n  if (!loader && !options?.nothrow) {\n    throw new Error(getNoValidLoaderMessage(data));\n  }\n\n  return loader;\n}\n\n/**\n * Find a loader that matches file extension and/or initial file content\n * Search the loaders array argument for a loader that matches url extension or initial data\n * Returns: a normalized loader\n * @param data data to assist\n * @param loaders\n * @param options\n * @param context used internally, applications should not provide this parameter\n */\nexport function selectLoaderSync(\n  data: Response | Blob | ArrayBuffer | string,\n  loaders: Loader[] | Loader = [],\n  options?: LoaderOptions,\n  context?: LoaderContext\n): Loader | null {\n  if (!validHTTPResponse(data)) {\n    return null;\n  }\n\n  // eslint-disable-next-line complexity\n  // if only a single loader was provided (not as array), force its use\n  // TODO - Should this behavior be kept and documented?\n  if (loaders && !Array.isArray(loaders)) {\n    // TODO - remove support for legacy loaders\n    return normalizeLoader(loaders);\n  }\n\n  // Build list of candidate loaders that will be searched in order for a match\n  let candidateLoaders: Loader[] = [];\n  // First search supplied loaders\n  if (loaders) {\n    candidateLoaders = candidateLoaders.concat(loaders);\n  }\n  // Then fall back to registered loaders\n  if (!options?.ignoreRegisteredLoaders) {\n    candidateLoaders.push(...getRegisteredLoaders());\n  }\n\n  // TODO - remove support for legacy loaders\n  normalizeLoaders(candidateLoaders);\n\n  const loader = selectLoaderInternal(data, candidateLoaders, options, context);\n\n  // no loader available\n  if (!loader && !options?.nothrow) {\n    throw new Error(getNoValidLoaderMessage(data));\n  }\n\n  return loader;\n}\n\n/** Implements loaders selection logic */\n// eslint-disable-next-line complexity\nfunction selectLoaderInternal(\n  data: Response | Blob | ArrayBuffer | string,\n  loaders: Loader[],\n  options?: LoaderOptions,\n  context?: LoaderContext\n) {\n  const url = getResourceUrl(data);\n  const type = getResourceMIMEType(data);\n\n  const testUrl = stripQueryString(url) || context?.url;\n\n  let loader: Loader | null = null;\n  let reason: string = '';\n\n  // if options.mimeType is supplied, it takes precedence\n  if (options?.mimeType) {\n    loader = findLoaderByMIMEType(loaders, options?.mimeType);\n    reason = `match forced by supplied MIME type ${options?.mimeType}`;\n  }\n\n  // Look up loader by url\n  loader = loader || findLoaderByUrl(loaders, testUrl);\n  reason = reason || (loader ? `matched url ${testUrl}` : '');\n\n  // Look up loader by mime type\n  loader = loader || findLoaderByMIMEType(loaders, type);\n  reason = reason || (loader ? `matched MIME type ${type}` : '');\n\n  // Look for loader via initial bytes (Note: not always accessible (e.g. Response, stream, async iterator)\n  loader = loader || findLoaderByInitialBytes(loaders, data);\n  reason = reason || (loader ? `matched initial data ${getFirstCharacters(data)}` : '');\n\n  // Look up loader by fallback mime type\n  loader = loader || findLoaderByMIMEType(loaders, options?.fallbackMimeType);\n  reason = reason || (loader ? `matched fallback MIME type ${type}` : '');\n\n  if (reason) {\n    log.log(1, `selectLoader selected ${loader?.name}: ${reason}.`);\n  }\n\n  return loader;\n}\n\n/** Check HTTP Response */\nfunction validHTTPResponse(data: any): boolean {\n  // HANDLE HTTP status\n  if (data instanceof Response) {\n    // 204 - NO CONTENT. This handles cases where e.g. a tile server responds with 204 for a missing tile\n    if (data.status === 204) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/** Generate a helpful message to help explain why loader selection failed. */\nfunction getNoValidLoaderMessage(data): string {\n  const url = getResourceUrl(data);\n  const type = getResourceMIMEType(data);\n\n  let message = 'No valid loader found (';\n  message += url ? `${path.filename(url)}, ` : 'no url provided, ';\n  message += `MIME type: ${type ? `\"${type}\"` : 'not provided'}, `;\n  // First characters are only accessible when called on data (string or arrayBuffer).\n  const firstCharacters: string = data ? getFirstCharacters(data) : '';\n  message += firstCharacters ? ` first bytes: \"${firstCharacters}\"` : 'first bytes: not available';\n  message += ')';\n  return message;\n}\n\nfunction normalizeLoaders(loaders: Loader[]): void {\n  for (const loader of loaders) {\n    normalizeLoader(loader);\n  }\n}\n\n// TODO - Would be nice to support http://example.com/file.glb?parameter=1\n// E.g: x = new URL('http://example.com/file.glb?load=1'; x.pathname\nfunction findLoaderByUrl(loaders: Loader[], url?: string): Loader | null {\n  // Get extension\n  const match = url && EXT_PATTERN.exec(url);\n  const extension = match && match[1];\n  return extension ? findLoaderByExtension(loaders, extension) : null;\n}\n\nfunction findLoaderByExtension(loaders: Loader[], extension: string): Loader | null {\n  extension = extension.toLowerCase();\n\n  for (const loader of loaders) {\n    for (const loaderExtension of loader.extensions) {\n      if (loaderExtension.toLowerCase() === extension) {\n        return loader;\n      }\n    }\n  }\n  return null;\n}\n\nfunction findLoaderByMIMEType(loaders, mimeType) {\n  for (const loader of loaders) {\n    if (loader.mimeTypes && loader.mimeTypes.includes(mimeType)) {\n      return loader;\n    }\n\n    // Support referring to loaders using the \"unregistered tree\"\n    // https://en.wikipedia.org/wiki/Media_type#Unregistered_tree\n    if (mimeType === `application/x.${loader.id}`) {\n      return loader;\n    }\n  }\n  return null;\n}\n\nfunction findLoaderByInitialBytes(loaders, data) {\n  if (!data) {\n    return null;\n  }\n\n  for (const loader of loaders) {\n    if (typeof data === 'string') {\n      if (testDataAgainstText(data, loader)) {\n        return loader;\n      }\n    } else if (ArrayBuffer.isView(data)) {\n      // Typed Arrays can have offsets into underlying buffer\n      if (testDataAgainstBinary(data.buffer, data.byteOffset, loader)) {\n        return loader;\n      }\n    } else if (data instanceof ArrayBuffer) {\n      const byteOffset = 0;\n      if (testDataAgainstBinary(data, byteOffset, loader)) {\n        return loader;\n      }\n    }\n    // TODO Handle streaming case (requires creating a new AsyncIterator)\n  }\n  return null;\n}\n\nfunction testDataAgainstText(data, loader) {\n  if (loader.testText) {\n    return loader.testText(data);\n  }\n\n  const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];\n  return tests.some((test) => data.startsWith(test));\n}\n\nfunction testDataAgainstBinary(data, byteOffset, loader) {\n  const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];\n  return tests.some((test) => testBinary(data, byteOffset, loader, test));\n}\n\nfunction testBinary(data, byteOffset, loader, test) {\n  if (test instanceof ArrayBuffer) {\n    return compareArrayBuffers(test, data, test.byteLength);\n  }\n  switch (typeof test) {\n    case 'function':\n      return test(data, loader);\n\n    case 'string':\n      // Magic bytes check: If `test` is a string, check if binary data starts with that strings\n      const magic = getMagicString(data, byteOffset, test.length);\n      return test === magic;\n\n    default:\n      return false;\n  }\n}\n\nfunction getFirstCharacters(data, length: number = 5) {\n  if (typeof data === 'string') {\n    return data.slice(0, length);\n  } else if (ArrayBuffer.isView(data)) {\n    // Typed Arrays can have offsets into underlying buffer\n    return getMagicString(data.buffer, data.byteOffset, length);\n  } else if (data instanceof ArrayBuffer) {\n    const byteOffset = 0;\n    return getMagicString(data, byteOffset, length);\n  }\n  return '';\n}\n\nfunction getMagicString(arrayBuffer, byteOffset, length) {\n  if (arrayBuffer.byteLength < byteOffset + length) {\n    return '';\n  }\n  const dataView = new DataView(arrayBuffer);\n  let magic = '';\n  for (let i = 0; i < length; i++) {\n    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));\n  }\n  return magic;\n}\n", "import type {IteratorOptions} from './make-iterator';\n\nconst DEFAULT_CHUNK_SIZE = 256 * 1024;\n\n/**\n * Returns an iterator that breaks a big string into chunks and yields them one-by-one as ArrayBuffers\n * @param blob string to iterate over\n * @param options\n * @param options.chunkSize\n */\nexport function* makeStringIterator(\n  string: string,\n  options?: IteratorOptions\n): Iterable<ArrayBuffer> {\n  const chunkSize = options?.chunkSize || DEFAULT_CHUNK_SIZE;\n\n  let offset = 0;\n  const textEncoder = new TextEncoder();\n  while (offset < string.length) {\n    // Create a chunk of the right size\n    const chunkLength = Math.min(string.length - offset, chunkSize);\n    const chunk = string.slice(offset, offset + chunkLength);\n    offset += chunkLength;\n\n    // yield an ArrayBuffer chunk\n    yield textEncoder.encode(chunk);\n  }\n}\n", "import type {IteratorOptions} from './make-iterator';\n\nconst DEFAULT_CHUNK_SIZE = 256 * 1024;\n\n/**\n * Returns an iterator that breaks a big ArrayBuffer into chunks and yields them one-by-one\n * @param blob ArrayBuffer to iterate over\n * @param options\n * @param options.chunkSize\n */\nexport function* makeArrayBufferIterator(\n  arrayBuffer: ArrayBuffer,\n  options: IteratorOptions = {}\n): Iterable<ArrayBuffer> {\n  const {chunkSize = DEFAULT_CHUNK_SIZE} = options;\n\n  let byteOffset = 0;\n\n  while (byteOffset < arrayBuffer.byteLength) {\n    // Create a chunk of the right size\n    const chunkByteLength = Math.min(arrayBuffer.byteLength - byteOffset, chunkSize);\n    const chunk = new ArrayBuffer(chunkByteLength);\n\n    // Copy data from the big chunk\n    const sourceArray = new Uint8Array(arrayBuffer, byteOffset, chunkByteLength);\n    const chunkArray = new Uint8Array(chunk);\n    chunkArray.set(sourceArray);\n\n    // yield the chunk\n    byteOffset += chunkByteLength;\n    yield chunk;\n  }\n}\n", "import type {IteratorOptions} from './make-iterator';\n\nconst DEFAULT_CHUNK_SIZE = 1024 * 1024; // 1MB — biggest value that keeps UI responsive\n\n/**\n * Returns an iterator that breaks a big Blob into chunks and yields them one-by-one\n * @param blob Blob or File object\n * @param options\n * @param options.chunkSize\n */\nexport async function* makeBlobIterator(\n  blob: Blob,\n  options?: IteratorOptions\n): AsyncIterable<ArrayBuffer> {\n  const chunkSize = options?.chunkSize || DEFAULT_CHUNK_SIZE;\n\n  let offset = 0;\n  while (offset < blob.size) {\n    const end = offset + chunkSize;\n\n    const chunk = await blob.slice(offset, end).arrayBuffer();\n\n    offset = end;\n    yield chunk;\n  }\n}\n", "import type {Readable} from 'stream';\nimport {isBrowser, toArrayBuffer} from '@loaders.gl/loader-utils';\n\nexport type StreamIteratorOptions = {\n  _streamReadAhead?: boolean;\n};\n\n/**\n * Returns an async iterable that reads from a stream (works in both Node.js and browsers)\n * @param stream stream to iterator over\n */\nexport function makeStreamIterator(\n  stream: ReadableStream | Readable,\n  options?: StreamIteratorOptions\n): AsyncIterable<ArrayBuffer> {\n  return isBrowser\n    ? makeBrowserStreamIterator(stream as ReadableStream, options)\n    : makeNodeStreamIterator(stream as Readable, options);\n}\n\n/**\n * Returns an async iterable that reads from a DOM (browser) stream\n * @param stream stream to iterate from\n * @see https://jakearchibald.com/2017/async-iterators-and-generators/#making-streams-iterate\n */\nasync function* makeBrowserStreamIterator(\n  stream: ReadableStream,\n  options?: StreamIteratorOptions\n): AsyncIterable<ArrayBuffer> {\n  // WhatWG: stream is supposed to have a `getIterator` method\n  // if (typeof stream.getIterator === 'function') {\n  //   return stream.getIterator();\n  // }\n  // if (typeof stream[Symbol.asyncIterator] === 'function') {\n  //   return makeToArrayBufferIterator(stream);\n  // }\n\n  // In the browser, we first need to get a lock on the stream\n  const reader = stream.getReader();\n\n  let nextBatchPromise: Promise<{done?: boolean; value?: Uint8Array}> | undefined;\n\n  try {\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      const currentBatchPromise = nextBatchPromise || reader.read();\n      // Issue a read for an additional batch, while we await the next batch\n      // Idea is to make fetching happen in parallel with processing / parsing\n      if (options?._streamReadAhead) {\n        nextBatchPromise = reader.read();\n      }\n      // Read from the stream\n      // value is a Uint8Array\n      const {done, value} = await currentBatchPromise;\n      // Exit if we're done\n      if (done) {\n        return;\n      }\n      // Else yield the chunk\n      yield toArrayBuffer(value);\n    }\n  } catch (error) {\n    // TODO - examples makes it look like this should always be called,\n    // but that generates exceptions so only call it if we do not reach the end\n    reader.releaseLock();\n  }\n}\n\n/**\n * Returns an async iterable that reads from a DOM (browser) stream\n * @param stream stream to iterate from\n * @note Requires Node.js >= 10\n */\nasync function* makeNodeStreamIterator(\n  stream: Readable,\n  options?: StreamIteratorOptions\n): AsyncIterable<ArrayBuffer> {\n  // Hacky test for node version to ensure we don't call bad polyfills\n  // NODE 10+: stream is an asyncIterator\n  for await (const chunk of stream) {\n    yield toArrayBuffer(chunk); // Coerce each chunk to ArrayBuffer\n  }\n}\n/* TODO - remove NODE < 10\n * @see https://github.com/bustle/streaming-iterables, MIT license\n *\n  if (typeof stream[Symbol.asyncIterator] === 'function') {\n    return;\n  }\n\n  // TODO - check if is this ever used in Node 10+?\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const data = stream.read();\n    if (data !== null) {\n      yield toArrayBuffer(data);\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n    if (stream._readableState?.ended) {\n      return;\n    }\n    await onceReadable(stream);\n  }\n\nasync function onceReadable(stream: Readable): Promise<any> {\n  return new Promise((resolve) => {\n    stream.once('readable', resolve);\n  });\n}\n  */\n", "import type {ReadStream} from 'fs';\n\nimport {makeStringIterator} from './make-string-iterator';\nimport {makeArrayBufferIterator} from './make-array-buffer-iterator';\nimport {makeBlobIterator} from './make-blob-iterator';\nimport type {StreamIteratorOptions} from './make-stream-iterator';\nimport {makeStreamIterator} from './make-stream-iterator';\nimport {isBlob, isReadableStream, isResponse} from '../../javascript-utils/is-type';\n\n/**\n * @param [options.chunkSize]\n */\nexport type IteratorOptions = StreamIteratorOptions & {\n  chunkSize?: number;\n};\n\n/**\n * Returns an iterator that breaks its input into chunks and yields them one-by-one.\n * @param data\n * @param options\n * @returns\n * This function can e.g. be used to enable data sources that can only be read atomically\n * (such as `Blob` and `File` via `FileReader`) to still be parsed in batches.\n */\nexport function makeIterator(\n  data: ArrayBuffer | string | Blob | Response | ReadableStream | ReadStream,\n  options?: IteratorOptions\n): AsyncIterable<ArrayBuffer> | Iterable<ArrayBuffer> {\n  if (typeof data === 'string') {\n    // Note: Converts string chunks to binary\n    return makeStringIterator(data, options);\n  }\n  if (data instanceof ArrayBuffer) {\n    return makeArrayBufferIterator(data, options);\n  }\n  if (isBlob(data)) {\n    return makeBlobIterator(data as Blob, options);\n  }\n  if (isReadableStream(data)) {\n    return makeStreamIterator(data as ReadableStream, options);\n  }\n  if (isResponse(data)) {\n    const response = data as Response;\n    return makeStreamIterator(response.body as ReadableStream, options);\n  }\n  throw new Error('makeIterator');\n}\n", "import type {\n  DataType,\n  SyncDataType,\n  BatchableDataType,\n  Loader,\n  LoaderOptions\n} from '@loaders.gl/loader-utils';\nimport {concatenateArrayBuffersAsync} from '@loaders.gl/loader-utils';\nimport {\n  isResponse,\n  isReadableStream,\n  isAsyncIterable,\n  isIterable,\n  isIterator,\n  isBlob,\n  isBuffer\n} from '../../javascript-utils/is-type';\nimport {makeIterator} from '../../iterators/make-iterator/make-iterator';\nimport {checkResponse, makeResponse} from '../utils/response-utils';\n\nconst ERR_DATA = 'Cannot convert supplied data type';\n\n// eslint-disable-next-line complexity\nexport function getArrayBufferOrStringFromDataSync(\n  data: SyncDataType,\n  loader: Loader,\n  options: LoaderOptions\n): ArrayBuffer | string {\n  if (loader.text && typeof data === 'string') {\n    return data;\n  }\n\n  if (isBuffer(data)) {\n    // @ts-ignore\n    data = data.buffer;\n  }\n\n  if (data instanceof ArrayBuffer) {\n    const arrayBuffer = data;\n    if (loader.text && !loader.binary) {\n      const textDecoder = new TextDecoder('utf8');\n      return textDecoder.decode(arrayBuffer);\n    }\n    return arrayBuffer;\n  }\n\n  // We may need to handle offsets\n  if (ArrayBuffer.isView(data)) {\n    // TextDecoder is invoked on typed arrays and will handle offsets\n    if (loader.text && !loader.binary) {\n      const textDecoder = new TextDecoder('utf8');\n      return textDecoder.decode(data);\n    }\n\n    let arrayBuffer = data.buffer;\n\n    // Since we are returning the underlying arrayBuffer, we must create a new copy\n    // if this typed array / Buffer is a partial view into the ArryayBuffer\n    // TODO - this is a potentially unnecessary copy\n    const byteLength = data.byteLength || data.length;\n    if (data.byteOffset !== 0 || byteLength !== arrayBuffer.byteLength) {\n      // console.warn(`loaders.gl copying arraybuffer of length ${byteLength}`);\n      arrayBuffer = arrayBuffer.slice(data.byteOffset, data.byteOffset + byteLength);\n    }\n    return arrayBuffer;\n  }\n\n  throw new Error(ERR_DATA);\n}\n\n// Convert async iterator to a promise\nexport async function getArrayBufferOrStringFromData(\n  data: DataType,\n  loader: Loader,\n  options: LoaderOptions\n): Promise<ArrayBuffer | string> {\n  const isArrayBuffer = data instanceof ArrayBuffer || ArrayBuffer.isView(data);\n  if (typeof data === 'string' || isArrayBuffer) {\n    return getArrayBufferOrStringFromDataSync(data as string | ArrayBuffer, loader, options);\n  }\n\n  // Blobs and files are FileReader compatible\n  if (isBlob(data)) {\n    data = await makeResponse(data);\n  }\n\n  if (isResponse(data)) {\n    const response = data as Response;\n    await checkResponse(response);\n    return loader.binary ? await response.arrayBuffer() : await response.text();\n  }\n\n  if (isReadableStream(data)) {\n    // @ts-expect-error TS2559 options type\n    data = makeIterator(data as ReadableStream, options);\n  }\n\n  if (isIterable(data) || isAsyncIterable(data)) {\n    // Assume arrayBuffer iterator - attempt to concatenate\n    return concatenateArrayBuffersAsync(data as AsyncIterable<ArrayBuffer>);\n  }\n\n  throw new Error(ERR_DATA);\n}\n\nexport async function getAsyncIterableFromData(\n  data: BatchableDataType,\n  options: LoaderOptions\n): Promise<AsyncIterable<ArrayBuffer> | Iterable<ArrayBuffer>> {\n  if (isIterator(data)) {\n    return data as AsyncIterable<ArrayBuffer>;\n  }\n\n  if (isResponse(data)) {\n    const response = data as Response;\n    // Note Since this function is not async, we currently can't load error message, just status\n    await checkResponse(response);\n    // TODO - bug in polyfill, body can be a Promise under Node.js\n    // eslint-disable-next-line @typescript-eslint/await-thenable\n    const body = await response.body;\n    // TODO - body can be null?\n    return makeIterator(body as ReadableStream<Uint8Array>, options as any);\n  }\n\n  if (isBlob(data) || isReadableStream(data)) {\n    return makeIterator(data as Blob | ReadableStream, options as any);\n  }\n\n  if (isAsyncIterable(data)) {\n    return data[Symbol.asyncIterator]();\n  }\n\n  return getIterableFromData(data);\n}\n\nexport async function getReadableStream(data: BatchableDataType): Promise<ReadableStream> {\n  if (isReadableStream(data)) {\n    return data as ReadableStream;\n  }\n  if (isResponse(data)) {\n    // @ts-ignore\n    return data.body;\n  }\n  const response = await makeResponse(data);\n  // @ts-ignore\n  return response.body;\n}\n\n// HELPERS\n\nfunction getIterableFromData(data) {\n  // generate an iterator that emits a single chunk\n  if (ArrayBuffer.isView(data)) {\n    return (function* oneChunk() {\n      yield data.buffer;\n    })();\n  }\n\n  if (data instanceof ArrayBuffer) {\n    return (function* oneChunk() {\n      yield data;\n    })();\n  }\n\n  if (isIterator(data)) {\n    return data;\n  }\n\n  if (isIterable(data)) {\n    return data[Symbol.iterator]();\n  }\n\n  throw new Error(ERR_DATA);\n}\n", "// loaders.gl, MIT license\n\nimport type {LoaderContext, LoaderOptions} from '@loaders.gl/loader-utils';\nimport {isObject} from '../../javascript-utils/is-type';\nimport {fetchFile} from '../fetch/fetch-file';\nimport {getGlobalLoaderOptions} from './option-utils';\n\n/**\n * Gets the current fetch function from options and context\n * @param options\n * @param context\n */\nexport function getFetchFunction(\n  options?: LoaderOptions,\n  context?: Omit<LoaderContext, 'fetch'> & Partial<Pick<LoaderContext, 'fetch'>>\n) {\n  const globalOptions = getGlobalLoaderOptions();\n\n  const fetchOptions = options || globalOptions;\n\n  // options.fetch can be a function\n  if (typeof fetchOptions.fetch === 'function') {\n    return fetchOptions.fetch;\n  }\n\n  // options.fetch can be an options object\n  if (isObject(fetchOptions.fetch)) {\n    return (url) => fetchFile(url, fetchOptions as RequestInit);\n  }\n\n  // else refer to context (from parent loader) if available\n  if (context?.fetch) {\n    return context?.fetch;\n  }\n\n  // else return the default fetch function\n  return fetchFile;\n}\n", "import type {Loader, LoaderOptions, LoaderContext} from '@loaders.gl/loader-utils';\nimport {getFetchFunction} from './get-fetch-function';\nimport {extractQueryString, stripQueryString} from '../utils/url-utils';\nimport {path} from '@loaders.gl/loader-utils';\n\n/**\n * \"sub\" loaders invoked by other loaders get a \"context\" injected on `this`\n * The context will inject core methods like `parse` and contain information\n * about loaders and options passed in to the top-level `parse` call.\n *\n * @param context\n * @param options\n * @param previousContext\n */\nexport function getLoaderContext(\n  context: Omit<LoaderContext, 'fetch'> & Partial<Pick<LoaderContext, 'fetch'>>,\n  options: LoaderOptions,\n  parentContext: LoaderContext | null\n): LoaderContext {\n  // For recursive calls, we already have a context\n  // TODO - add any additional loaders to context?\n  if (parentContext) {\n    return parentContext;\n  }\n\n  const newContext: LoaderContext = {\n    fetch: getFetchFunction(options, context),\n    ...context\n  };\n\n  // Parse URLs so that subloaders can easily generate correct strings\n  if (newContext.url) {\n    const baseUrl = stripQueryString(newContext.url);\n    newContext.baseUrl = baseUrl;\n    newContext.queryString = extractQueryString(newContext.url);\n    newContext.filename = path.filename(baseUrl);\n    newContext.baseUrl = path.dirname(baseUrl);\n  }\n\n  // Recursive loading does not use single loader\n  if (!Array.isArray(newContext.loaders)) {\n    newContext.loaders = null;\n  }\n\n  return newContext;\n}\n\n// eslint-disable-next-line complexity\nexport function getLoadersFromContext(\n  loaders: Loader[] | Loader | undefined,\n  context?: LoaderContext\n) {\n  // A single non-array loader is force selected, but only on top-level (context === null)\n  if (!context && loaders && !Array.isArray(loaders)) {\n    return loaders;\n  }\n\n  // Create a merged list\n  let candidateLoaders;\n  if (loaders) {\n    candidateLoaders = Array.isArray(loaders) ? loaders : [loaders];\n  }\n  if (context && context.loaders) {\n    const contextLoaders = Array.isArray(context.loaders) ? context.loaders : [context.loaders];\n    candidateLoaders = candidateLoaders ? [...candidateLoaders, ...contextLoaders] : contextLoaders;\n  }\n  // If no loaders, return null to look in globally registered loaders\n  return candidateLoaders && candidateLoaders.length ? candidateLoaders : null;\n}\n", "import type {DataType, Loader, LoaderContext, LoaderOptions} from '@loaders.gl/loader-utils';\nimport {assert, validateWorkerVersion} from '@loaders.gl/worker-utils';\nimport {parseWithWorker, canParseWithWorker} from '@loaders.gl/loader-utils';\nimport {isLoaderObject} from '../loader-utils/normalize-loader';\nimport {isResponse} from '../../javascript-utils/is-type';\nimport {normalizeOptions} from '../loader-utils/option-utils';\nimport {getArrayBufferOrStringFromData} from '../loader-utils/get-data';\nimport {getLoaderContext, getLoadersFromContext} from '../loader-utils/loader-context';\nimport {getResourceUrl} from '../utils/resource-utils';\nimport {selectLoader} from './select-loader';\n\n/**\n * Parses `data` using a specified loader\n * @param data\n * @param loaders\n * @param options\n * @param context\n */\nexport async function parse(\n  data: DataType | Promise<DataType>,\n  loaders?: Loader | Loader[] | LoaderOptions,\n  options?: LoaderOptions,\n  context?: LoaderContext\n): Promise<any> {\n  assert(!context || typeof context === 'object'); // parse no longer accepts final url\n\n  // Signature: parse(data, options, context | url)\n  // Uses registered loaders\n  if (loaders && !Array.isArray(loaders) && !isLoaderObject(loaders)) {\n    context = undefined; // context not supported in short signature\n    options = loaders as LoaderOptions;\n    loaders = undefined;\n  }\n\n  data = await data; // Resolve any promise\n  options = options || {};\n\n  // Extract a url for auto detection\n  const url = getResourceUrl(data);\n\n  // Chooses a loader (and normalizes it)\n  // Also use any loaders in the context, new loaders take priority\n  const typedLoaders = loaders as Loader | Loader[] | undefined;\n  const candidateLoaders = getLoadersFromContext(typedLoaders, context);\n  // todo hacky type cast\n  const loader = await selectLoader(data as ArrayBuffer, candidateLoaders, options);\n  // Note: if no loader was found, if so just return null\n  if (!loader) {\n    return null;\n  }\n\n  // Normalize options\n  options = normalizeOptions(options, loader, candidateLoaders, url);\n\n  // Get a context (if already present, will be unchanged)\n  context = getLoaderContext({url, parse, loaders: candidateLoaders}, options, context || null);\n\n  return await parseWithLoader(loader, data, options, context);\n}\n\n// TODO: support progress and abort\n// TODO - should accept loader.parseAsyncIterator and concatenate.\nasync function parseWithLoader(loader, data, options, context) {\n  validateWorkerVersion(loader);\n\n  if (isResponse(data)) {\n    // Serialize to support passing the response to web worker\n    const response = data as Response;\n    const {ok, redirected, status, statusText, type, url} = response;\n    const headers = Object.fromEntries(response.headers.entries());\n    context.response = {headers, ok, redirected, status, statusText, type, url};\n  }\n\n  data = await getArrayBufferOrStringFromData(data, loader, options);\n\n  // First check for synchronous text parser, wrap results in promises\n  if (loader.parseTextSync && typeof data === 'string') {\n    options.dataType = 'text';\n    return loader.parseTextSync(data, options, context, loader);\n  }\n\n  // If we have a workerUrl and the loader can parse the given options efficiently in a worker\n  if (canParseWithWorker(loader, options)) {\n    return await parseWithWorker(loader, data, options, context, parse);\n  }\n\n  // Check for asynchronous parser\n  if (loader.parseText && typeof data === 'string') {\n    return await loader.parseText(data, options, context, loader);\n  }\n\n  if (loader.parse) {\n    return await loader.parse(data, options, context, loader);\n  }\n\n  // This should not happen, all sync loaders should also offer `parse` function\n  assert(!loader.parseSync);\n\n  // TBD - If asynchronous parser not available, return null\n  throw new Error(`${loader.id} loader - no parser found and worker is disabled`);\n}\n", "import type {\n  SyncDataType,\n  Loader,\n  LoaderWithParser,\n  LoaderContext,\n  LoaderOptions\n} from '@loaders.gl/loader-utils';\nimport {assert} from '@loaders.gl/loader-utils';\nimport {selectLoaderSync} from './select-loader';\nimport {isLoaderObject} from '../loader-utils/normalize-loader';\nimport {normalizeOptions} from '../loader-utils/option-utils';\nimport {getArrayBufferOrStringFromDataSync} from '../loader-utils/get-data';\nimport {getLoaderContext, getLoadersFromContext} from '../loader-utils/loader-context';\nimport {getResourceUrl} from '../utils/resource-utils';\n\n/**\n * Parses `data` synchronously using a specified loader\n * @param data\n * @param loaders\n * @param options\n * @param context\n */\nexport function parseSync(\n  data: SyncDataType,\n  loaders?: Loader | Loader[] | LoaderOptions,\n  options?: LoaderOptions,\n  context?: LoaderContext\n): any {\n  assert(!context || typeof context === 'object'); // parseSync no longer accepts final url\n\n  // Signature: parseSync(data, options)\n  // Uses registered loaders\n  if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {\n    context = undefined; // context not supported in short signature\n    options = loaders as LoaderOptions;\n    loaders = undefined;\n  }\n\n  options = options || {};\n\n  // Chooses a loader (and normalizes it)\n  // Also use any loaders in the context, new loaders take priority\n  const typedLoaders = loaders as Loader | Loader[] | undefined;\n  const candidateLoaders = getLoadersFromContext(typedLoaders, context);\n  const loader = selectLoaderSync(data, candidateLoaders, options);\n  // Note: if nothrow option was set, it is possible that no loader was found, if so just return null\n  if (!loader) {\n    return null;\n  }\n\n  // Normalize options\n  options = normalizeOptions(options, loader, candidateLoaders);\n\n  // Extract a url for auto detection\n  const url = getResourceUrl(data);\n\n  const parse = () => {\n    throw new Error('parseSync called parse (which is async');\n  };\n  context = getLoaderContext(\n    {url, parseSync, parse, loaders: loaders as Loader[]},\n    options,\n    context || null\n  );\n\n  return parseWithLoaderSync(loader as LoaderWithParser, data, options, context);\n}\n\n// TODO - should accept loader.parseSync/parse and generate 1 chunk asyncIterator\nfunction parseWithLoaderSync(\n  loader: LoaderWithParser,\n  data: SyncDataType,\n  options: LoaderOptions,\n  context: LoaderContext\n) {\n  data = getArrayBufferOrStringFromDataSync(data, loader, options);\n\n  if (loader.parseTextSync && typeof data === 'string') {\n    return loader.parseTextSync(data, options); // , context, loader);\n  }\n\n  if (loader.parseSync && data instanceof ArrayBuffer) {\n    return loader.parseSync(data, options, context); // , loader);\n  }\n\n  // TBD - If synchronous parser not available, return null\n  throw new Error(\n    `${loader.name} loader: 'parseSync' not supported by this loader, use 'parse' instead. ${\n      context.url || ''\n    }`\n  );\n}\n", "import type {Batch} from '@loaders.gl/schema';\nimport type {\n  BatchableDataType,\n  Loader,\n  LoaderWithParser,\n  LoaderContext,\n  LoaderOptions\n} from '@loaders.gl/loader-utils';\nimport {assert, concatenateArrayBuffersAsync} from '@loaders.gl/loader-utils';\nimport {isLoaderObject} from '../loader-utils/normalize-loader';\nimport {normalizeOptions} from '../loader-utils/option-utils';\nimport {getLoaderContext} from '../loader-utils/loader-context';\nimport {getAsyncIterableFromData} from '../loader-utils/get-data';\nimport {getResourceUrl} from '../utils/resource-utils';\nimport {selectLoader} from './select-loader';\n\n// Ensure `parse` is available in context if loader falls back to `parse`\nimport {parse} from './parse';\n\n/**\n * Parses `data` using a specified loader\n * @param data\n * @param loaders\n * @param options\n * @param context\n */\nexport async function parseInBatches(\n  data: BatchableDataType,\n  loaders?: Loader | Loader[] | LoaderOptions,\n  options?: LoaderOptions,\n  context?: LoaderContext\n): Promise<AsyncIterable<any>> {\n  assert(!context || typeof context === 'object'); // parseInBatches no longer accepts final url\n\n  const loaderArray = Array.isArray(loaders) ? loaders : undefined;\n\n  // Signature: parseInBatches(data, options, url) - Uses registered loaders\n  if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {\n    context = undefined; // context not supported in short signature\n    options = loaders as LoaderOptions;\n    loaders = undefined;\n  }\n\n  data = await data; // Resolve any promise\n  options = options || {};\n\n  // Extract a url for auto detection\n  const url = getResourceUrl(data);\n\n  // Chooses a loader and normalizes it\n  // Note - only uses URL and contentType for streams and iterator inputs\n  const loader = await selectLoader(data as ArrayBuffer, loaders as Loader | Loader[], options);\n  // Note: if options.nothrow was set, it is possible that no loader was found, if so just return null\n  if (!loader) {\n    // @ts-ignore\n    return null;\n  }\n\n  // Normalize options\n  options = normalizeOptions(options, loader, loaderArray, url);\n  context = getLoaderContext(\n    {url, parseInBatches, parse, loaders: loaderArray},\n    options,\n    context || null\n  );\n\n  return await parseWithLoaderInBatches(loader as LoaderWithParser, data, options, context);\n}\n\n/**\n * Loader has been selected and context has been prepared, see if we need to emit a metadata batch\n */\nasync function parseWithLoaderInBatches(\n  loader: LoaderWithParser,\n  data: BatchableDataType,\n  options: LoaderOptions,\n  context: LoaderContext\n): Promise<AsyncIterable<any>> {\n  const outputIterator = await parseToOutputIterator(loader, data, options, context);\n\n  // Generate metadata batch if requested\n  if (!options.metadata) {\n    return outputIterator;\n  }\n\n  const metadataBatch = {\n    batchType: 'metadata',\n    metadata: {\n      _loader: loader,\n      _context: context\n    },\n    // Populate with some default fields to avoid crashing\n    data: [],\n    bytesUsed: 0\n  };\n\n  async function* makeMetadataBatchIterator(iterator) {\n    yield metadataBatch;\n    yield* iterator;\n  }\n\n  return makeMetadataBatchIterator(outputIterator);\n}\n\n/**\n * Prep work is done, now it is time to start parsing into an output operator\n * The approach depends on which parse function the loader exposes\n * `parseInBatches` (preferred), `parse` (fallback)\n */\nasync function parseToOutputIterator(\n  loader: LoaderWithParser,\n  data: BatchableDataType,\n  options: LoaderOptions,\n  context: LoaderContext\n): Promise<AsyncIterable<any>> {\n  // Get an iterator from the input\n  const inputIterator = await getAsyncIterableFromData(data, options);\n\n  // Apply any iterator transforms (options.transforms)\n  const transformedIterator = await applyInputTransforms(inputIterator, options?.transforms || []);\n\n  // If loader supports parseInBatches, we are done\n  if (loader.parseInBatches) {\n    return loader.parseInBatches(transformedIterator, options, context);\n  }\n\n  // Fallback: load atomically using `parse` concatenating input iterator into single chunk\n  async function* parseChunkInBatches() {\n    const arrayBuffer = await concatenateArrayBuffersAsync(transformedIterator);\n    // Call `parse` instead of `loader.parse` to ensure we can call workers etc.\n    const parsedData = await parse(\n      arrayBuffer,\n      loader,\n      // TODO - Hack: supply loaders MIME type to ensure we match it\n      {...options, mimeType: loader.mimeTypes[0]},\n      context\n    );\n    // yield a single batch, the output from loader.parse()\n    // TODO - run through batch builder to apply options etc...\n    const batch: Batch = {\n      mimeType: loader.mimeTypes[0],\n      shape: Array.isArray(parsedData) ? 'row-table' : 'unknown',\n      batchType: 'data',\n      data: parsedData,\n      length: Array.isArray(parsedData) ? parsedData.length : 1\n    };\n    yield batch;\n  }\n\n  return parseChunkInBatches();\n}\n\ntype TransformBatches = (\n  asyncIterator: AsyncIterable<ArrayBuffer> | Iterable<ArrayBuffer>\n) => AsyncIterable<ArrayBuffer>;\n\n/**\n * Create an iterator chain with any transform iterators (crypto, decompression)\n * @param inputIterator\n * @param options\n */\nasync function applyInputTransforms(\n  inputIterator: AsyncIterable<ArrayBuffer> | Iterable<ArrayBuffer>,\n  transforms: TransformBatches[] = []\n): Promise<AsyncIterable<ArrayBuffer> | Iterable<ArrayBuffer>> {\n  let iteratorChain = inputIterator;\n  for await (const transformBatches of transforms) {\n    iteratorChain = transformBatches(iteratorChain);\n  }\n  return iteratorChain;\n}\n", "import type {DataType, Loader, LoaderContext, LoaderOptions} from '@loaders.gl/loader-utils';\nimport {isBlob} from '../../javascript-utils/is-type';\nimport {isLoaderObject} from '../loader-utils/normalize-loader';\nimport {getFetchFunction} from '../loader-utils/get-fetch-function';\n\nimport {parse} from './parse';\n\n/**\n * Parses `data` using a specified loader\n * Note: Load does duplicate a lot of parse.\n * it can also call fetchFile on string urls, which `parse` won't do.\n * @param data\n * @param loaders\n * @param options\n * @param context\n */\n// implementation signature\nexport async function load(\n  url: string | DataType,\n  loaders?: Loader | Loader[] | LoaderOptions,\n  options?: LoaderOptions,\n  context?: LoaderContext\n): Promise<any> {\n  // Signature: load(url, options)\n  if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {\n    context = undefined; // context not supported in short signature\n    options = loaders as LoaderOptions;\n    loaders = undefined;\n  }\n\n  // Select fetch function\n  const fetch = getFetchFunction(options);\n\n  // at this point, `url` could be already loaded binary data\n  let data = url;\n  // url is a string, fetch the url\n  if (typeof url === 'string') {\n    data = await fetch(url);\n    // URL is Blob or File, fetchFile handles it (alt: we could generate ObjectURL here)\n  }\n\n  if (isBlob(url)) {\n    // The fetch response object will contain blob.name\n    // @ts-expect-error TODO - This may not work for overridden fetch functions\n    data = await fetch(url);\n  }\n\n  // Data is loaded (at least we have a `Response` object) so time to hand over to `parse`\n  return await parse(data, loaders as Loader[], options);\n}\n", "import type {LoaderWithParser, LoaderOptions, LoaderContext} from '@loaders.gl/loader-utils';\nimport {isLoaderObject} from '../loader-utils/normalize-loader';\nimport {getFetchFunction} from '../loader-utils/get-fetch-function';\n\nimport {parseInBatches} from './parse-in-batches';\n\ntype FileType = string | File | Blob | Response | (string | File | Blob | Response)[] | FileList;\n\n/**\n * Parses `data` using a specified loader\n * @param data\n * @param loaders\n * @param options\n * @param context\n */\nexport function loadInBatches(\n  files: FileType,\n  loaders?: LoaderWithParser | LoaderWithParser[] | LoaderOptions,\n  options?: LoaderOptions,\n  context?: LoaderContext\n): Promise<AsyncIterable<any>>;\n\nexport function loadInBatches(\n  files: FileType[] | FileList,\n  loaders?: LoaderWithParser | LoaderWithParser[] | LoaderOptions,\n  options?: LoaderOptions,\n  context?: LoaderContext\n): Promise<AsyncIterable<any>>;\n\nexport function loadInBatches(files, loaders, options, context) {\n  // Signature: load(url, options)\n  if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {\n    context = undefined; // context not supported in short signature\n    options = loaders;\n    loaders = null;\n  }\n\n  // Select fetch function\n  const fetch = getFetchFunction(options || {});\n\n  // Single url/file\n  if (!Array.isArray(files)) {\n    return loadOneFileInBatches(files, loaders, options, fetch);\n  }\n\n  // Multiple URLs / files\n  const promises = files.map((file) => loadOneFileInBatches(file, loaders, options, fetch));\n\n  // No point in waiting here for all responses before starting to stream individual streams?\n  return promises;\n}\n\nasync function loadOneFileInBatches(file, loaders, options, fetch) {\n  if (typeof file === 'string') {\n    const url = file;\n    const response = await fetch(url);\n    return await parseInBatches(response, loaders, options);\n  }\n  return await parseInBatches(file, loaders, options);\n}\n", "import {Writer, WriterOptions, canEncodeWithWorker} from '@loaders.gl/loader-utils';\nimport {processOnWorker} from '@loaders.gl/worker-utils';\nimport {concatenateArrayBuffers, resolvePath} from '@loaders.gl/loader-utils';\nimport {isBrowser} from '@loaders.gl/loader-utils';\nimport {writeFile} from '../fetch/write-file';\nimport {fetchFile} from '../fetch/fetch-file';\nimport {getLoaderOptions} from './loader-options';\n\n/**\n * Encode loaded data into a binary ArrayBuffer using the specified Writer.\n */\nexport async function encode(\n  data: any,\n  writer: Writer,\n  options?: WriterOptions\n): Promise<ArrayBuffer> {\n  const globalOptions = getLoaderOptions() as WriterOptions;\n  // const globalOptions: WriterOptions = {}; // getWriterOptions();\n  options = {...globalOptions, ...options};\n  if (canEncodeWithWorker(writer, options)) {\n    return await processOnWorker(writer, data, options);\n  }\n\n  // TODO Merge default writer options with options argument like it is done in load module.\n  if (writer.encode) {\n    return await writer.encode(data, options);\n  }\n\n  if (writer.encodeSync) {\n    return writer.encodeSync(data, options);\n  }\n\n  if (writer.encodeText) {\n    return new TextEncoder().encode(await writer.encodeText(data, options));\n  }\n\n  if (writer.encodeInBatches) {\n    // Create an iterator representing the data\n    // TODO - Assumes this is a table\n    const batches = encodeInBatches(data, writer, options);\n\n    // Concatenate the output\n    const chunks: any[] = [];\n    for await (const batch of batches) {\n      chunks.push(batch);\n    }\n    // @ts-ignore\n    return concatenateArrayBuffers(...chunks);\n  }\n\n  if (!isBrowser && writer.encodeURLtoURL) {\n    // TODO - how to generate filenames with correct extensions?\n    const tmpInputFilename = getTemporaryFilename('input');\n    await writeFile(tmpInputFilename, data);\n\n    const tmpOutputFilename = getTemporaryFilename('output');\n\n    const outputFilename = await encodeURLtoURL(\n      tmpInputFilename,\n      tmpOutputFilename,\n      writer,\n      options\n    );\n\n    const response = await fetchFile(outputFilename);\n    return response.arrayBuffer();\n  }\n\n  throw new Error('Writer could not encode data');\n}\n\n/**\n * Encode loaded data into a binary ArrayBuffer using the specified Writer.\n */\nexport function encodeSync(data: any, writer: Writer, options?: WriterOptions): ArrayBuffer {\n  if (writer.encodeSync) {\n    return writer.encodeSync(data, options);\n  }\n  throw new Error('Writer could not synchronously encode data');\n}\n\n/**\n * Encode loaded data to text using the specified Writer\n * @note This is a convenience function not intended for production use on large input data.\n * It is not optimized for performance. Data maybe converted from text to binary and back.\n * @throws if the writer does not generate text output\n */\nexport async function encodeText(\n  data: any,\n  writer: Writer,\n  options?: WriterOptions\n): Promise<string> {\n  if (writer.text && writer.encodeText) {\n    return await writer.encodeText(data, options);\n  }\n\n  if (writer.text && (writer.encode || writer.encodeInBatches)) {\n    const arrayBuffer = await encode(data, writer, options);\n    return new TextDecoder().decode(arrayBuffer);\n  }\n\n  throw new Error('Writer could not encode data as text');\n}\n\n/**\n * Encode loaded data into a sequence (iterator) of binary ArrayBuffers using the specified Writer.\n */\nexport function encodeInBatches(\n  data: any,\n  writer: Writer,\n  options?: WriterOptions\n): AsyncIterable<ArrayBuffer> {\n  if (writer.encodeInBatches) {\n    const dataIterator = getIterator(data);\n    return writer.encodeInBatches(dataIterator, options);\n  }\n  // TODO -fall back to atomic encode?\n  throw new Error('Writer could not encode data in batches');\n}\n\n/**\n * Encode data stored in a file (on disk) to another file.\n * @note Node.js only. This function enables using command-line converters as \"writers\".\n */\nexport async function encodeURLtoURL(\n  inputUrl,\n  outputUrl,\n  writer: Writer,\n  options\n): Promise<string> {\n  inputUrl = resolvePath(inputUrl);\n  outputUrl = resolvePath(outputUrl);\n  if (isBrowser || !writer.encodeURLtoURL) {\n    throw new Error();\n  }\n  const outputFilename = await writer.encodeURLtoURL(inputUrl, outputUrl, options);\n  return outputFilename;\n}\n\n/**\n * @todo TODO - this is an unacceptable hack!!!\n */\nfunction getIterator(data) {\n  const dataIterator = [{table: data, start: 0, end: data.length}];\n  return dataIterator;\n}\n\n/**\n * @todo Move to utils\n */\nfunction getTemporaryFilename(filename: string): string {\n  return `/tmp/${filename}`;\n}\n", "import type {Writer, WriterOptions} from '@loaders.gl/loader-utils';\nimport {encode, encodeSync} from './encode';\nimport {writeFile, writeFileSync} from '../fetch/write-file';\n\nexport async function save(data, url, writer: Writer, options: WriterOptions) {\n  const encodedData = await encode(data, writer, options);\n  return await writeFile(url, encodedData);\n}\n\nexport function saveSync(data, url, writer, options) {\n  const encodedData = encodeSync(data, writer, options);\n  return writeFileSync(url, encodedData);\n}\n", "export type MakeStreamOptions = {\n  /** Stream allocates an arrayBuffer. Enables use of a default reader. */\n  autoAllocateChunkSize?: number;\n  /** Total number of chunks in queue before back pressure is applied */\n  highWaterMark?: number;\n};\n\n/**\n * Builds a DOM stream from an iterator\n * This stream is currently used in browsers only,\n * but note that Web stream support is present in Node from Node 16\n * https://nodejs.org/api/webstreams.html#webstreams_web_streams_api\n */\nexport function makeStream<ArrayBuffer>(\n  source: Iterable<ArrayBuffer> | AsyncIterable<ArrayBuffer>,\n  options?: MakeStreamOptions\n): ReadableStream {\n  const iterator = source[Symbol.asyncIterator]\n    ? (source as AsyncIterable<ArrayBuffer>)[Symbol.asyncIterator]()\n    : (source as Iterable<ArrayBuffer>)[Symbol.iterator]();\n\n  return new ReadableStream<Uint8Array>(\n    {\n      // Create a byte stream (enables `Response(stream).arrayBuffer()`)\n      // Only supported on Chrome\n      // See: https://developer.mozilla.org/en-US/docs/Web/API/ReadableByteStreamController\n      type: 'bytes',\n\n      async pull(controller) {\n        try {\n          const {done, value} = await iterator.next();\n          if (done) {\n            controller.close();\n          } else {\n            // TODO - ignores controller.desiredSize\n            // @ts-expect-error Unclear why value is not correctly typed\n            controller.enqueue(new Uint8Array(value));\n          }\n        } catch (error) {\n          controller.error(error);\n        }\n      },\n\n      async cancel() {\n        await iterator?.return?.();\n      }\n    },\n    // options: QueingStrategy<Uint8Array>\n    {\n      // This is bytes, not chunks\n      highWaterMark: 2 ** 24,\n      ...options\n    }\n  );\n}\n", "// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\n\nimport {Loader, LoaderWithParser} from '@loaders.gl/loader-utils';\n\n/**\n * Loads any data and returns null (or optionally passes through data unparsed)\n */\nexport const NullWorkerLoader: Loader = {\n  name: 'Null loader',\n  id: 'null',\n  module: 'core',\n  version: VERSION,\n  worker: true,\n  mimeTypes: ['application/x.empty'],\n  extensions: ['null'],\n  tests: [() => false],\n  options: {\n    null: {}\n  }\n};\n\n/**\n * Returns arguments passed to the parse API in a format that can be transfered to a\n * web worker. The `context` parameter is stripped using JSON.stringify & parse.\n */\nfunction parseSync(arrayBuffer, options, context) {\n  if (!options.null.echoParameters) return null;\n  context = context && JSON.parse(JSON.stringify(context));\n  return {arrayBuffer, options, context};\n}\n\n/**\n * Loads any data and returns null (or optionally passes through data unparsed)\n */\nexport const NullLoader: LoaderWithParser = {\n  name: 'Null loader',\n  id: 'null',\n  module: 'core',\n  version: VERSION,\n  mimeTypes: ['application/x.empty'],\n  extensions: ['null'],\n  parse: async (arrayBuffer, options, context) => parseSync(arrayBuffer, options, context),\n  parseSync,\n  parseInBatches: async function* generator(asyncIterator, options, context) {\n    for await (const batch of asyncIterator) {\n      yield parseSync(batch, options, context);\n    }\n  },\n  tests: [() => false],\n  options: {\n    null: {\n      echoParameters: false\n    }\n  }\n};\n", "// Forked from github AnthumChris/fetch-progress-indicators under MIT license\n\n/**\n * Intercepts the Response stream and creates a new Response\n */\nexport default async function fetchProgress(\n  response: Response | Promise<Response>,\n  onProgress: any, // TODO better callback types\n  onDone = () => {},\n  onError = () => {}\n) {\n  response = await response;\n  if (!response.ok) {\n    // ERROR checking needs to be done separately\n    return response;\n  }\n  const body = response.body;\n  if (!body) {\n    // 'ReadableStream not yet supported in this browser.\n    return response;\n  }\n  const contentLength = response.headers.get('content-length') || 0;\n  const totalBytes = contentLength ? parseInt(contentLength) : 0;\n  if (!(totalBytes > 0)) {\n    return response;\n  }\n  // Currently override only implemented in browser\n  if (typeof ReadableStream === 'undefined' || !body.getReader) {\n    return response;\n  }\n\n  // Create a new stream that invisbly wraps original stream\n  const progressStream = new ReadableStream({\n    async start(controller) {\n      const reader = body.getReader();\n      await read(controller, reader, 0, totalBytes, onProgress, onDone, onError);\n    }\n  });\n\n  return new Response(progressStream);\n}\n\n// Forward to original streams controller\n// TODO - this causes a crazy deep \"async stack\"... rewrite as async iterator?\n// eslint-disable-next-line max-params\nasync function read(controller, reader, loadedBytes, totalBytes, onProgress, onDone, onError) {\n  try {\n    const {done, value} = await reader.read();\n    if (done) {\n      onDone();\n      controller.close();\n      return;\n    }\n    loadedBytes += value.byteLength;\n    const percent = Math.round((loadedBytes / totalBytes) * 100);\n    onProgress(percent, {loadedBytes, totalBytes});\n    controller.enqueue(value);\n    await read(controller, reader, loadedBytes, totalBytes, onProgress, onDone, onError);\n  } catch (error) {\n    controller.error(error);\n    onError(error);\n  }\n}\n", "import type {FileSystem} from './filesystem';\n\ntype BrowserFileSystemOptions = {\n  fetch?: typeof fetch;\n};\n\n/**\n * FileSystem adapter for a browser FileList.\n * Holds a list of browser 'File' objects.\n */\nexport default class BrowserFileSystem implements FileSystem {\n  private _fetch: typeof fetch;\n  private files: {[filename: string]: File} = {};\n  private lowerCaseFiles: {[filename: string]: File} = {};\n  private usedFiles: {[filename: string]: boolean} = {};\n\n  /**\n   * A FileSystem API wrapper around a list of browser 'File' objects\n   * @param files\n   * @param options\n   */\n  constructor(files: FileList | File[], options?: BrowserFileSystemOptions) {\n    this._fetch = options?.fetch || fetch;\n\n    for (let i = 0; i < files.length; ++i) {\n      const file = files[i];\n      this.files[file.name] = file;\n      this.lowerCaseFiles[file.name.toLowerCase()] = file;\n      this.usedFiles[file.name] = false;\n    }\n\n    this.fetch = this.fetch.bind(this);\n  }\n\n  // implements IFileSystem\n\n  /**\n   * Implementation of fetch against this file system\n   * Delegates to global fetch for http{s}:// or data://\n   */\n  async fetch(path: string, options?: RequestInit): Promise<Response> {\n    // Fallback to handle https:/http:/data: etc fetches\n    if (path.includes('://')) {\n      return this._fetch(path, options);\n    }\n\n    // Local fetches are served from the list of files\n    const file = this.files[path];\n    if (!file) {\n      return new Response(path, {status: 400, statusText: 'NOT FOUND'});\n    }\n\n    const headers = new Headers(options?.headers);\n    const range = headers.get('Range');\n    const bytes = range && /bytes=($1)-($2)/.exec(range);\n\n    if (bytes) {\n      const start = parseInt(bytes[1]);\n      const end = parseInt(bytes[2]);\n      // The trick when reading File objects is to read successive \"slices\" of the File\n      // Per spec https://w3c.github.io/FileAPI/, slicing a File should only update the start and end fields\n      // Actually reading from file should happen in `readAsArrayBuffer` (and as far we can tell it does)\n      const data = await file.slice(start, end).arrayBuffer();\n      const response = new Response(data);\n      Object.defineProperty(response, 'url', {value: path});\n      return response;\n    }\n\n    // return makeResponse()\n    const response = new Response(file);\n    Object.defineProperty(response, 'url', {value: path});\n    return response;\n  }\n\n  /**\n   * List filenames in this filesystem\n   * @param dirname\n   * @returns\n   */\n  async readdir(dirname?: string): Promise<string[]> {\n    const files: string[] = [];\n    for (const path in this.files) {\n      files.push(path);\n    }\n    // TODO filter by dirname\n    return files;\n  }\n\n  /**\n   * Return information (size) about files in this file system\n   */\n  async stat(path: string, options?: object): Promise<{size: number}> {\n    const file = this.files[path];\n    if (!file) {\n      throw new Error(path);\n    }\n    return {size: file.size};\n  }\n\n  /**\n   * Just removes the file from the list\n   */\n  async unlink(path: string): Promise<void> {\n    delete this.files[path];\n    delete this.lowerCaseFiles[path];\n    this.usedFiles[path] = true;\n  }\n\n  // implements IRandomAccessFileSystem\n\n  // RANDOM ACCESS\n  async open(pathname: string, flags, mode?): Promise<any> {\n    return this.files[pathname];\n  }\n\n  /**\n   * Read a range into a buffer\n   * @todo - handle position memory\n   * @param buffer is the buffer that the data (read from the fd) will be written to.\n   * @param offset is the offset in the buffer to start writing at.\n   * @param length is an integer specifying the number of bytes to read.\n   * @param position is an argument specifying where to begin reading from in the file. If position is null, data will be read from the current file position, and the file position will be updated. If position is an integer, the file position will remain unchanged.\n   */\n  async read(\n    fd: any,\n    buffer: ArrayBuffer,\n    offset: number = 0,\n    length: number = buffer.byteLength,\n    position: number | null = null\n  ): Promise<{bytesRead: number; buffer: ArrayBuffer}> {\n    const file = fd as File;\n    const startPosition = 0; // position\n    const arrayBuffer = await file.slice(startPosition, startPosition + length).arrayBuffer();\n    // copy into target buffer\n    return {bytesRead: length, buffer: arrayBuffer};\n  }\n\n  async close(fd: number): Promise<void> {\n    // NO OP\n  }\n\n  // fstat(fd: number): Promise<object>; // Stat\n\n  // PRIVATE\n\n  // Supports case independent paths, and file usage tracking\n  _getFile(path, used) {\n    // Prefer case match, but fall back to case indepent.\n    const file = this.files[path] || this.lowerCaseFiles[path];\n    if (file && used) {\n      this.usedFiles[path] = true;\n    }\n    return file;\n  }\n}\n"],
  "mappings": "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",
  "names": ["assert", "condition", "message", "Error", "globals", "self", "window", "global", "document", "self_", "window_", "global_", "document_", "isBrowser", "Boolean", "process", "String", "browser", "isWorker", "importScripts", "matches", "version", "exec", "nodeVersion", "parseFloat", "VERSION", "DEFAULT_VERSION", "console", "error", "assert", "condition", "message", "Error", "globals", "self", "window", "global", "document", "self_", "window_", "global_", "document_", "isBrowser", "process", "String", "browser", "isMobile", "window", "orientation", "matches", "process", "version", "exec", "nodeVersion", "parseFloat", "WorkerJob", "constructor", "jobName", "workerThread", "_defineProperty", "name", "result", "Promise", "resolve", "reject", "_resolve", "_reject", "postMessage", "type", "payload", "source", "done", "value", "assert", "isRunning", "error", "Worker", "terminate", "workerURLCache", "Map", "getLoadableWorkerURL", "props", "assert", "source", "url", "workerURL", "get", "getLoadableWorkerURLFromURL", "set", "getLoadableWorkerURLFromSource", "startsWith", "workerSource", "buildScriptSource", "blob", "Blob", "type", "URL", "createObjectURL", "workerUrl", "concat", "getTransferList", "object", "recursive", "arguments", "length", "undefined", "transfers", "transfersSet", "Set", "isTransferable", "add", "buffer", "ArrayBuffer", "isView", "key", "Array", "from", "MessagePort", "ImageBitmap", "OffscreenCanvas", "getTransferListForWriter", "clone", "Object", "assign", "keys", "forEach", "RegExp", "NOOP", "WorkerThread", "isSupported", "Worker", "isBrowser", "NodeWorker", "constructor", "props", "_defineProperty", "name", "source", "url", "assert", "onMessage", "onError", "error", "console", "log", "worker", "_createBrowserWorker", "_createNodeWorker", "destroy", "terminate", "terminated", "isRunning", "Boolean", "postMessage", "data", "transferList", "getTransferList", "_getErrorFromErrorEvent", "event", "message", "concat", "lineno", "colno", "Error", "_loadableURL", "getLoadableWorkerURL", "onmessage", "onerror", "onmessageerror", "absolute", "includes", "startsWith", "eval", "on", "code", "WorkerPool", "isSupported", "WorkerThread", "constructor", "props", "_defineProperty", "source", "url", "setProps", "destroy", "idleQueue", "forEach", "worker", "isDestroyed", "name", "undefined", "maxConcurrency", "maxMobileConcurrency", "reuseWorkers", "onDebug", "startJob", "onMessage", "arguments", "length", "job", "type", "data", "done", "onError", "error", "startPromise", "Promise", "onStart", "jobQueue", "push", "_startQueuedJob", "workerThread", "_getAvailableWorker", "queuedJob", "shift", "message", "backlog", "WorkerJob", "payload", "result", "returnWorkerToQueue", "shouldDestroyWorker", "count", "_getMaxConcurrency", "concat", "toLowerCase", "isMobile", "DEFAULT_PROPS", "maxConcurrency", "maxMobileConcurrency", "reuseWorkers", "onDebug", "WorkerFarm", "isSupported", "WorkerThread", "getWorkerFarm", "props", "arguments", "length", "undefined", "_workerFarm", "setProps", "constructor", "_defineProperty", "Map", "workerPools", "destroy", "workerPool", "values", "_getWorkerPoolProps", "getWorkerPool", "options", "name", "source", "url", "get", "WorkerPool", "set", "getParentPort", "parentPort", "eval", "globalThis", "onMessageWrapperMap", "Map", "WorkerBody", "inWorkerThread", "self", "Boolean", "onmessage", "onMessage", "handleMessage", "message", "type", "payload", "data", "on", "console", "debug", "addEventListener", "onMessageWrapper", "get", "isKnownMessage", "error", "removeEventListener", "delete", "postMessage", "source", "transferList", "getTransferList", "startsWith", "NPM_TAG", "VERSION", "getWorkerName", "worker", "warning", "version", "concat", "name", "getWorkerURL", "options", "arguments", "length", "undefined", "workerOptions", "id", "workerFile", "url", "workerUrl", "_workerType", "module", "versionTag", "assert", "processOnWorker", "worker", "data", "options", "arguments", "length", "undefined", "context", "name", "getWorkerName", "workerFarm", "WorkerFarm", "getWorkerFarm", "source", "workerPoolProps", "url", "getWorkerURL", "workerPool", "getWorkerPool", "jobName", "job", "startJob", "onMessage", "bind", "transferableOptions", "getTransferListForWriter", "postMessage", "input", "result", "type", "payload", "done", "error", "Error", "id", "process", "message", "console", "warn", "concat", "Symbol", "asyncIterator", "AsyncQueue", "constructor", "_defineProperty", "_values", "_settlers", "_closed", "_Symbol$asyncIterator", "push", "value", "enqueue", "Error", "length", "settler", "shift", "reject", "resolve", "close", "done", "next", "Promise", "undefined", "validateWorkerVersion", "worker", "coreVersion", "arguments", "length", "undefined", "VERSION", "assert", "workerVersion", "version", "canParseWithWorker", "loader", "options", "WorkerFarm", "isSupported", "isBrowser", "_nodeWorkers", "worker", "parseWithWorker", "data", "context", "parseOnMainThread", "name", "id", "url", "getWorkerURL", "workerFarm", "getWorkerFarm", "workerPool", "getWorkerPool", "JSON", "parse", "stringify", "job", "startJob", "onMessage", "bind", "postMessage", "input", "result", "type", "payload", "done", "error", "Error", "message", "console", "warn", "concat", "canEncodeWithWorker", "writer", "options", "WorkerFarm", "isSupported", "isBrowser", "_nodeWorkers", "worker", "compareArrayBuffers", "arrayBuffer1", "arrayBuffer2", "byteLength", "array1", "Uint8Array", "array2", "i", "length", "concatenateArrayBuffers", "_len", "arguments", "sources", "Array", "_key", "sourceArrays", "map", "source2", "ArrayBuffer", "reduce", "typedArray", "result", "offset", "sourceArray", "set", "buffer", "makeTextDecoderIterator", "arrayBufferIterator", "options", "arguments", "length", "undefined", "textDecoder", "TextDecoder", "arrayBuffer", "decode", "stream", "e", "Promise", "reject", "makeTextEncoderIterator", "textIterator", "textEncoder", "TextEncoder", "text", "encode", "makeLineIterator", "previous", "textChunk", "eolIndex", "indexOf", "line", "slice", "makeNumberedLineIterator", "lineIterator", "counter", "forEach", "iterator", "visitor", "done", "value", "next", "return", "cancel", "concatenateArrayBuffersAsync", "asyncIterator", "arrayBuffers", "chunk", "push", "concatenateArrayBuffers", "timestamp", "window", "performance", "now", "process", "hrtime", "timeParts", "Date", "Stat", "constructor", "name", "type", "reset", "setSampleSize", "samples", "sampleSize", "incrementCount", "addCount", "decrementCount", "subtractCount", "value", "_count", "_samples", "_checkSampling", "addTime", "time", "_time", "lastTiming", "timeStart", "_startTime", "getHiResTimestamp", "_timerPending", "timeEnd", "getSampleAverageCount", "lastSampleCount", "getSampleAverageTime", "lastSampleTime", "getSampleHz", "getAverageCount", "count", "getAverageTime", "getHz", "Stats", "constructor", "options", "id", "stats", "_initializeStats", "Object", "seal", "get", "name", "type", "_getOrCreate", "size", "keys", "length", "reset", "key", "forEach", "fn", "getTable", "table", "stat", "time", "count", "average", "getAverageTime", "hz", "getHz", "Stat", "STAT_QUEUED_REQUESTS", "STAT_ACTIVE_REQUESTS", "STAT_CANCELLED_REQUESTS", "STAT_QUEUED_REQUESTS_EVER", "STAT_ACTIVE_REQUESTS_EVER", "DEFAULT_PROPS", "id", "throttleRequests", "maxRequests", "RequestScheduler", "constructor", "props", "arguments", "length", "undefined", "_defineProperty", "Map", "stats", "Stats", "get", "scheduleRequest", "handle", "getPriority", "Promise", "resolve", "done", "requestMap", "has", "request", "priority", "promise", "requestQueue", "push", "set", "_issueNewRequests", "_issueRequest", "isDone", "delete", "activeRequestCount", "deferredUpdate", "setTimeout", "_issueNewRequestsAsync", "freeSlots", "Math", "max", "_updateAllRequests", "i", "shift", "_updateRequest", "splice", "sort", "a", "b", "pathPrefix", "fileAliases", "setPathPrefix", "prefix", "getPathPrefix", "resolvePath", "filename", "alias", "fileAliases", "startsWith", "replacement", "replace", "concat", "pathPrefix", "VERSION", "JSONLoader", "name", "id", "module", "version", "extensions", "mimeTypes", "category", "text", "parseTextSync", "parse", "arrayBuffer", "TextDecoder", "decode", "options", "JSON", "toArrayBuffer", "buffer", "toBuffer", "binaryData", "Error", "isBuffer", "value", "toBuffer", "data", "toArrayBuffer", "ArrayBuffer", "isView", "byteOffset", "byteLength", "buffer", "slice", "text", "uint8Array", "TextEncoder", "encode", "_toArrayBuffer", "Error", "getCWD", "_window$location", "process", "cwd", "pathname", "window", "location", "slice", "lastIndexOf", "filename", "url", "slashIndex", "lastIndexOf", "substr", "dirname", "join", "_len", "arguments", "length", "parts", "Array", "_key", "separator", "map", "part", "index", "replace", "RegExp", "concat", "resolve", "paths", "_i", "undefined", "resolvedPath", "resolvedAbsolute", "cwd", "i", "path", "getCWD", "charCodeAt", "SLASH", "normalizeStringPosix", "DOT", "allowAboveRoot", "res", "lastSlash", "dots", "code", "isAboveRoot", "start", "j", "slice", "readdir", "stat", "readFile", "readFileSync", "writeFile", "writeFileSync", "open", "close", "read", "fstat", "createWriteStream", "_readToArrayBuffer", "isSupported", "isBoolean", "x", "isFunction", "isObject", "isPureObject", "constructor", "isPromise", "then", "isIterable", "Symbol", "iterator", "isAsyncIterable", "asyncIterator", "isIterator", "next", "isResponse", "Response", "arrayBuffer", "text", "json", "isBlob", "x", "Blob", "isBuffer", "isWritableDOMStream", "isObject", "isFunction", "abort", "getWriter", "isReadableDOMStream", "ReadableStream", "tee", "cancel", "getReader", "isWritableNodeStream", "end", "write", "isBoolean", "writable", "isReadableNodeStream", "read", "pipe", "readable", "isReadableStream", "isWritableStream", "DATA_URL_PATTERN", "MIME_TYPE_PATTERN", "parseMIMEType", "mimeString", "matches", "exec", "parseMIMETypeFromURL", "url", "QUERY_STRING_PATTERN", "extractQueryString", "url", "matches", "match", "stripQueryString", "replace", "getResourceUrl", "resource", "isResponse", "response", "url", "isBlob", "blob", "name", "getResourceMIMEType", "contentTypeHeader", "headers", "get", "noQueryUrl", "stripQueryString", "parseMIMEType", "parseMIMETypeFromURL", "type", "getResourceContentLength", "size", "length", "ArrayBuffer", "byteLength", "isView", "makeResponse", "resource", "isResponse", "headers", "contentLength", "getResourceContentLength", "String", "url", "getResourceUrl", "type", "getResourceMIMEType", "initialDataUrl", "getInitialDataUrl", "TextEncoder", "encode", "response", "Response", "Object", "defineProperty", "value", "checkResponse", "ok", "message", "getResponseError", "Error", "getResponseError", "response", "message", "concat", "url", "status", "contentType", "headers", "get", "text", "statusText", "includes", "length", "slice", "error", "getInitialDataUrl", "resource", "INITIAL_DATA_LENGTH", "Blob", "blobSlice", "Promise", "resolve", "reader", "FileReader", "onload", "event", "_event$target", "target", "result", "readAsDataURL", "ArrayBuffer", "base64", "arrayBufferToBase64", "buffer", "binary", "bytes", "Uint8Array", "i", "byteLength", "String", "fromCharCode", "btoa", "fetchFile", "url", "options", "resolvePath", "fetchOptions", "fetch", "makeResponse", "readArrayBuffer", "file", "start", "length", "fs", "_readToArrayBuffer", "Blob", "slice", "readBlob", "blob", "Promise", "resolve", "reject", "fileReader", "FileReader", "onload", "event", "_event$target", "target", "result", "onerror", "error", "readAsArrayBuffer", "readFileSync", "url", "options", "arguments", "length", "undefined", "resolvePath", "isBrowser", "buffer", "fs", "toArrayBuffer", "nothrow", "assert", "writeFile", "filePath", "arrayBufferOrString", "options", "resolvePath", "isBrowser", "fs", "toBuffer", "flag", "assert", "writeFileSync", "mockUserAgent", "window", "process", "type", "versions", "Boolean", "realUserAgent", "navigator", "userAgent", "indexOf", "isBrowser", "isNode", "process", "String", "browser", "isElectron", "globals", "self", "window", "global", "document", "process", "self_", "globals", "self", "window", "global", "window_", "document_", "document", "process_", "process", "VERSION", "__VERSION__", "isBrowser", "checkIfBrowser", "window", "globalThis", "mockUserAgent", "isBrowser", "isElectron", "navigator_", "navigator", "userAgent", "indexOf", "isMSIE", "isTrident", "window", "chrome", "safari", "mozInnerScreenX", "getStorage", "type", "storage", "window", "x", "setItem", "removeItem", "e", "LocalStorage", "constructor", "id", "defaultConfig", "config", "_loadConfiguration", "getConfiguration", "setConfiguration", "configuration", "Object", "assign", "serialized", "JSON", "stringify", "serializedConfiguration", "getItem", "parse", "formatTime", "ms", "formatted", "toFixed", "leftPad", "string", "length", "padLength", "Math", "max", "repeat", "formatImage", "image", "message", "scale", "maxWidth", "imageUrl", "src", "replace", "width", "Math", "min", "height", "style", "floor", "join", "COLOR", "getColor", "color", "toUpperCase", "WHITE", "addColor", "string", "background", "isBrowser", "autobind", "obj", "predefined", "proto", "Object", "getPrototypeOf", "propNames", "getOwnPropertyNames", "key", "find", "name", "bind", "assert", "condition", "message", "Error", "getHiResTimestamp", "timestamp", "isBrowser", "window", "performance", "now", "process", "timeParts", "hrtime", "Date", "originalConsole", "debug", "isBrowser", "console", "log", "info", "warn", "error", "DEFAULT_SETTINGS", "enabled", "level", "noop", "cache", "ONCE", "once", "Log", "constructor", "id", "VERSION", "getHiResTimestamp", "userData", "_storage", "LocalStorage", "timeStamp", "autobind", "Object", "seal", "newLevel", "setLevel", "getLevel", "isEnabled", "config", "getTotal", "Number", "_startTs", "toPrecision", "getDelta", "_deltaTs", "priority", "newPriority", "getPriority", "enable", "setConfiguration", "get", "setting", "set", "value", "settings", "table", "assert", "condition", "message", "_getLogFunction", "arguments", "deprecated", "oldUsage", "newUsage", "removed", "probe", "logLevel", "time", "args", "columns", "tag", "getTableHeader", "image", "scale", "_shouldLog", "logImageInBrowser", "logImageInNode", "timeEnd", "group", "opts", "collapsed", "options", "normalizeArguments", "method", "groupCollapsed", "assign", "groupEnd", "withGroup", "func", "trace", "normalizeLogLevel", "total", "delta", "decorateMessage", "bind", "resolvedLevel", "isFinite", "Array", "from", "length", "shift", "undefined", "unshift", "messageType", "leftPad", "formatTime", "addColor", "color", "background", "img", "Image", "onload", "formatImage", "src", "element", "nodeName", "toLowerCase", "toDataURL", "key", "title", "globalThis", "probe", "Log", "id", "probeLog", "Log", "id", "NullLog", "log", "info", "warn", "error", "ConsoleLog", "constructor", "_defineProperty", "console", "_len", "arguments", "length", "args", "Array", "_key", "bind", "_len2", "_key2", "_len3", "_key3", "_len4", "_key4", "DEFAULT_LOADER_OPTIONS", "fetch", "mimeType", "undefined", "nothrow", "log", "ConsoleLog", "CDN", "worker", "maxConcurrency", "maxMobileConcurrency", "reuseWorkers", "isBrowser", "_nodeWorkers", "_workerType", "limit", "_limitMB", "batchSize", "batchDebounceMs", "metadata", "transforms", "REMOVED_LOADER_OPTIONS", "throws", "dataType", "uri", "method", "headers", "body", "mode", "credentials", "cache", "redirect", "referrer", "referrerPolicy", "integrity", "keepalive", "signal", "getGlobalLoaderState", "globalThis", "loaders", "_state", "getGlobalLoaderOptions", "state", "globalOptions", "DEFAULT_LOADER_OPTIONS", "setGlobalOptions", "options", "normalizeOptionsInternal", "normalizeOptions", "loader", "url", "Array", "isArray", "validateOptions", "validateOptionsObject", "REMOVED_LOADER_OPTIONS", "idOptions", "id", "loaderOptions", "deprecatedOptions", "defaultOptions", "loaderName", "prefix", "concat", "key", "isSubOptions", "isObject", "isBaseUriOption", "isWorkerUrlOption", "probeLog", "warn", "suggestion", "findSimilarOption", "optionKey", "lowerCaseOptionKey", "toLowerCase", "bestSuggestion", "lowerCaseKey", "isPartialMatch", "startsWith", "loaderDefaultOptions", "mergedOptions", "addUrlOptions", "log", "NullLog", "mergeNestedFields", "value", "isPureObject", "baseUri", "isLoaderObject", "loader", "_loader", "Array", "isArray", "hasExtensions", "extensions", "normalizeLoader", "_loader2", "_loader3", "assert", "options", "parseTextSync", "parseText", "text", "binary", "getGlobalLoaderRegistry", "state", "getGlobalLoaderState", "loaderRegistry", "registerLoaders", "loaders", "Array", "isArray", "loader", "normalizedLoader", "normalizeLoader", "find", "registeredLoader", "unshift", "getRegisteredLoaders", "_unregisterLoaders", "log", "Log", "id", "EXT_PATTERN", "selectLoader", "data", "loaders", "arguments", "length", "undefined", "options", "context", "validHTTPResponse", "loader", "selectLoaderSync", "nothrow", "isBlob", "slice", "arrayBuffer", "Error", "getNoValidLoaderMessage", "Array", "isArray", "normalizeLoader", "candidateLoaders", "concat", "ignoreRegisteredLoaders", "push", "getRegisteredLoaders", "normalizeLoaders", "selectLoaderInternal", "url", "getResourceUrl", "type", "getResourceMIMEType", "testUrl", "stripQueryString", "reason", "mimeType", "findLoaderByMIMEType", "findLoaderByUrl", "findLoaderByInitialBytes", "getFirstCharacters", "fallbackMimeType", "_loader", "log", "name", "Response", "status", "message", "path", "filename", "firstCharacters", "match", "exec", "extension", "findLoaderByExtension", "toLowerCase", "loaderExtension", "extensions", "mimeTypes", "includes", "id", "testDataAgainstText", "ArrayBuffer", "isView", "testDataAgainstBinary", "buffer", "byteOffset", "testText", "tests", "some", "test", "startsWith", "testBinary", "compareArrayBuffers", "byteLength", "magic", "getMagicString", "dataView", "DataView", "i", "String", "fromCharCode", "getUint8", "DEFAULT_CHUNK_SIZE", "makeStringIterator", "string", "options", "chunkSize", "offset", "textEncoder", "TextEncoder", "length", "chunkLength", "Math", "min", "chunk", "slice", "encode", "DEFAULT_CHUNK_SIZE", "makeArrayBufferIterator", "arrayBuffer", "options", "arguments", "length", "undefined", "chunkSize", "byteOffset", "byteLength", "chunkByteLength", "Math", "min", "chunk", "ArrayBuffer", "sourceArray", "Uint8Array", "chunkArray", "set", "DEFAULT_CHUNK_SIZE", "makeBlobIterator", "blob", "options", "chunkSize", "offset", "size", "end", "chunk", "slice", "arrayBuffer", "makeStreamIterator", "stream", "options", "isBrowser", "makeBrowserStreamIterator", "makeNodeStreamIterator", "reader", "getReader", "nextBatchPromise", "currentBatchPromise", "read", "_streamReadAhead", "done", "value", "toArrayBuffer", "error", "releaseLock", "chunk", "makeIterator", "data", "options", "makeStringIterator", "ArrayBuffer", "makeArrayBufferIterator", "isBlob", "makeBlobIterator", "isReadableStream", "makeStreamIterator", "isResponse", "response", "body", "Error", "ERR_DATA", "getArrayBufferOrStringFromDataSync", "data", "loader", "options", "text", "isBuffer", "buffer", "ArrayBuffer", "arrayBuffer", "binary", "textDecoder", "TextDecoder", "decode", "isView", "byteLength", "length", "byteOffset", "slice", "Error", "getArrayBufferOrStringFromData", "isArrayBuffer", "isBlob", "makeResponse", "isResponse", "response", "checkResponse", "isReadableStream", "makeIterator", "isIterable", "isAsyncIterable", "concatenateArrayBuffersAsync", "getAsyncIterableFromData", "isIterator", "body", "Symbol", "asyncIterator", "getIterableFromData", "getIterableFromData", "data", "ArrayBuffer", "isView", "oneChunk", "buffer", "isIterator", "isIterable", "Symbol", "iterator", "Error", "ERR_DATA", "getFetchFunction", "options", "context", "globalOptions", "getGlobalLoaderOptions", "fetchOptions", "fetch", "isObject", "url", "fetchFile", "getLoaderContext", "context", "options", "parentContext", "newContext", "fetch", "getFetchFunction", "url", "baseUrl", "stripQueryString", "queryString", "extractQueryString", "filename", "path", "dirname", "Array", "isArray", "loaders", "getLoadersFromContext", "candidateLoaders", "contextLoaders", "length", "parse", "data", "loaders", "options", "context", "assert", "Array", "isArray", "isLoaderObject", "undefined", "url", "getResourceUrl", "typedLoaders", "candidateLoaders", "getLoadersFromContext", "loader", "selectLoader", "normalizeOptions", "getLoaderContext", "parseWithLoader", "validateWorkerVersion", "isResponse", "response", "ok", "redirected", "status", "statusText", "type", "headers", "Object", "fromEntries", "entries", "getArrayBufferOrStringFromData", "parseTextSync", "dataType", "canParseWithWorker", "parseWithWorker", "parseText", "parseSync", "Error", "concat", "id", "parseSync", "data", "loaders", "options", "context", "assert", "Array", "isArray", "isLoaderObject", "undefined", "typedLoaders", "candidateLoaders", "getLoadersFromContext", "loader", "selectLoaderSync", "normalizeOptions", "url", "getResourceUrl", "parse", "Error", "getLoaderContext", "parseWithLoaderSync", "getArrayBufferOrStringFromDataSync", "parseTextSync", "ArrayBuffer", "concat", "name", "parseInBatches", "data", "loaders", "options", "context", "assert", "loaderArray", "Array", "isArray", "undefined", "isLoaderObject", "url", "getResourceUrl", "loader", "selectLoader", "normalizeOptions", "getLoaderContext", "parse", "parseWithLoaderInBatches", "outputIterator", "parseToOutputIterator", "metadata", "metadataBatch", "batchType", "_loader", "_context", "bytesUsed", "makeMetadataBatchIterator", "iterator", "inputIterator", "getAsyncIterableFromData", "transformedIterator", "applyInputTransforms", "transforms", "parseChunkInBatches", "arrayBuffer", "concatenateArrayBuffersAsync", "parsedData", "mimeType", "mimeTypes", "batch", "shape", "length", "arguments", "iteratorChain", "transformBatches", "load", "url", "loaders", "options", "context", "Array", "isArray", "isLoaderObject", "undefined", "fetch", "getFetchFunction", "data", "isBlob", "parse", "loadInBatches", "files", "loaders", "options", "context", "Array", "isArray", "isLoaderObject", "undefined", "fetch", "getFetchFunction", "loadOneFileInBatches", "promises", "map", "file", "url", "response", "parseInBatches", "encode", "data", "writer", "options", "globalOptions", "getLoaderOptions", "canEncodeWithWorker", "processOnWorker", "encodeSync", "encodeText", "TextEncoder", "encodeInBatches", "batches", "chunks", "batch", "push", "concatenateArrayBuffers", "isBrowser", "encodeURLtoURL", "tmpInputFilename", "getTemporaryFilename", "writeFile", "tmpOutputFilename", "outputFilename", "response", "fetchFile", "arrayBuffer", "Error", "text", "TextDecoder", "decode", "dataIterator", "getIterator", "inputUrl", "outputUrl", "resolvePath", "table", "start", "end", "length", "filename", "concat", "save", "data", "url", "writer", "options", "encodedData", "encode", "writeFile", "saveSync", "encodeSync", "writeFileSync", "makeStream", "source", "options", "iterator", "Symbol", "asyncIterator", "ReadableStream", "type", "pull", "controller", "done", "value", "next", "close", "enqueue", "Uint8Array", "error", "cancel", "_iterator$return", "return", "call", "highWaterMark", "VERSION", "NullWorkerLoader", "name", "id", "module", "version", "worker", "mimeTypes", "extensions", "tests", "options", "null", "parseSync", "arrayBuffer", "context", "echoParameters", "JSON", "parse", "stringify", "NullLoader", "parseInBatches", "generator", "asyncIterator", "batch", "response", "onProgress", "onDone", "arguments", "length", "undefined", "onError", "ok", "body", "contentLength", "headers", "get", "totalBytes", "parseInt", "ReadableStream", "getReader", "progressStream", "start", "controller", "reader", "read", "Response", "loadedBytes", "done", "value", "close", "byteLength", "percent", "Math", "round", "enqueue", "error", "BrowserFileSystem", "constructor", "files", "options", "_defineProperty", "_fetch", "fetch", "i", "length", "file", "name", "lowerCaseFiles", "toLowerCase", "usedFiles", "bind", "path", "includes", "Response", "status", "statusText", "headers", "Headers", "range", "get", "bytes", "exec", "start", "parseInt", "end", "data", "slice", "arrayBuffer", "response", "Object", "defineProperty", "value", "readdir", "dirname", "push", "stat", "Error", "size", "unlink", "open", "pathname", "flags", "mode", "read", "fd", "buffer", "offset", "arguments", "undefined", "byteLength", "position", "startPosition", "bytesRead", "close", "_getFile", "used"]
}
