import {
  earcut,
  getPolygonSignedArea
} from "./chunk-VVNUQXBC.js";
import "./chunk-5NDAMBYK.js";

// ../node_modules/@loaders.gl/gis/dist/esm/lib/flat-geojson-to-binary.js
function flatGeojsonToBinary(features, geometryInfo, options) {
  const propArrayTypes = extractNumericPropTypes(features);
  const numericPropKeys = Object.keys(propArrayTypes).filter((k) => propArrayTypes[k] !== Array);
  return fillArrays(features, {
    propArrayTypes,
    ...geometryInfo
  }, {
    numericPropKeys: options && options.numericPropKeys || numericPropKeys,
    PositionDataType: options ? options.PositionDataType : Float32Array,
    triangulate: options ? options.triangulate : true
  });
}
function extractNumericPropTypes(features) {
  const propArrayTypes = {};
  for (const feature of features) {
    if (feature.properties) {
      for (const key in feature.properties) {
        const val = feature.properties[key];
        propArrayTypes[key] = deduceArrayType(val, propArrayTypes[key]);
      }
    }
  }
  return propArrayTypes;
}
function fillArrays(features, geometryInfo, options) {
  const {
    pointPositionsCount,
    pointFeaturesCount,
    linePositionsCount,
    linePathsCount,
    lineFeaturesCount,
    polygonPositionsCount,
    polygonObjectsCount,
    polygonRingsCount,
    polygonFeaturesCount,
    propArrayTypes,
    coordLength
  } = geometryInfo;
  const {
    numericPropKeys = [],
    PositionDataType = Float32Array,
    triangulate = true
  } = options;
  const hasGlobalId = features[0] && "id" in features[0];
  const GlobalFeatureIdsDataType = features.length > 65535 ? Uint32Array : Uint16Array;
  const points = {
    type: "Point",
    positions: new PositionDataType(pointPositionsCount * coordLength),
    globalFeatureIds: new GlobalFeatureIdsDataType(pointPositionsCount),
    featureIds: pointFeaturesCount > 65535 ? new Uint32Array(pointPositionsCount) : new Uint16Array(pointPositionsCount),
    numericProps: {},
    properties: [],
    fields: []
  };
  const lines = {
    type: "LineString",
    pathIndices: linePositionsCount > 65535 ? new Uint32Array(linePathsCount + 1) : new Uint16Array(linePathsCount + 1),
    positions: new PositionDataType(linePositionsCount * coordLength),
    globalFeatureIds: new GlobalFeatureIdsDataType(linePositionsCount),
    featureIds: lineFeaturesCount > 65535 ? new Uint32Array(linePositionsCount) : new Uint16Array(linePositionsCount),
    numericProps: {},
    properties: [],
    fields: []
  };
  const polygons = {
    type: "Polygon",
    polygonIndices: polygonPositionsCount > 65535 ? new Uint32Array(polygonObjectsCount + 1) : new Uint16Array(polygonObjectsCount + 1),
    primitivePolygonIndices: polygonPositionsCount > 65535 ? new Uint32Array(polygonRingsCount + 1) : new Uint16Array(polygonRingsCount + 1),
    positions: new PositionDataType(polygonPositionsCount * coordLength),
    globalFeatureIds: new GlobalFeatureIdsDataType(polygonPositionsCount),
    featureIds: polygonFeaturesCount > 65535 ? new Uint32Array(polygonPositionsCount) : new Uint16Array(polygonPositionsCount),
    numericProps: {},
    properties: [],
    fields: []
  };
  if (triangulate) {
    polygons.triangles = [];
  }
  for (const object of [points, lines, polygons]) {
    for (const propName of numericPropKeys) {
      const T = propArrayTypes[propName];
      object.numericProps[propName] = new T(object.positions.length / coordLength);
    }
  }
  lines.pathIndices[linePathsCount] = linePositionsCount;
  polygons.polygonIndices[polygonObjectsCount] = polygonPositionsCount;
  polygons.primitivePolygonIndices[polygonRingsCount] = polygonPositionsCount;
  const indexMap = {
    pointPosition: 0,
    pointFeature: 0,
    linePosition: 0,
    linePath: 0,
    lineFeature: 0,
    polygonPosition: 0,
    polygonObject: 0,
    polygonRing: 0,
    polygonFeature: 0,
    feature: 0
  };
  for (const feature of features) {
    const geometry = feature.geometry;
    const properties = feature.properties || {};
    switch (geometry.type) {
      case "Point":
        handlePoint(geometry, points, indexMap, coordLength, properties);
        points.properties.push(keepStringProperties(properties, numericPropKeys));
        if (hasGlobalId) {
          points.fields.push({
            id: feature.id
          });
        }
        indexMap.pointFeature++;
        break;
      case "LineString":
        handleLineString(geometry, lines, indexMap, coordLength, properties);
        lines.properties.push(keepStringProperties(properties, numericPropKeys));
        if (hasGlobalId) {
          lines.fields.push({
            id: feature.id
          });
        }
        indexMap.lineFeature++;
        break;
      case "Polygon":
        handlePolygon(geometry, polygons, indexMap, coordLength, properties);
        polygons.properties.push(keepStringProperties(properties, numericPropKeys));
        if (hasGlobalId) {
          polygons.fields.push({
            id: feature.id
          });
        }
        indexMap.polygonFeature++;
        break;
      default:
        throw new Error("Invalid geometry type");
    }
    indexMap.feature++;
  }
  return makeAccessorObjects(points, lines, polygons, coordLength);
}
function handlePoint(geometry, points, indexMap, coordLength, properties) {
  points.positions.set(geometry.data, indexMap.pointPosition * coordLength);
  const nPositions = geometry.data.length / coordLength;
  fillNumericProperties(points, properties, indexMap.pointPosition, nPositions);
  points.globalFeatureIds.fill(indexMap.feature, indexMap.pointPosition, indexMap.pointPosition + nPositions);
  points.featureIds.fill(indexMap.pointFeature, indexMap.pointPosition, indexMap.pointPosition + nPositions);
  indexMap.pointPosition += nPositions;
}
function handleLineString(geometry, lines, indexMap, coordLength, properties) {
  lines.positions.set(geometry.data, indexMap.linePosition * coordLength);
  const nPositions = geometry.data.length / coordLength;
  fillNumericProperties(lines, properties, indexMap.linePosition, nPositions);
  lines.globalFeatureIds.fill(indexMap.feature, indexMap.linePosition, indexMap.linePosition + nPositions);
  lines.featureIds.fill(indexMap.lineFeature, indexMap.linePosition, indexMap.linePosition + nPositions);
  for (let i = 0, il = geometry.indices.length; i < il; ++i) {
    const start = geometry.indices[i];
    const end = i === il - 1 ? geometry.data.length : geometry.indices[i + 1];
    lines.pathIndices[indexMap.linePath++] = indexMap.linePosition;
    indexMap.linePosition += (end - start) / coordLength;
  }
}
function handlePolygon(geometry, polygons, indexMap, coordLength, properties) {
  polygons.positions.set(geometry.data, indexMap.polygonPosition * coordLength);
  const nPositions = geometry.data.length / coordLength;
  fillNumericProperties(polygons, properties, indexMap.polygonPosition, nPositions);
  polygons.globalFeatureIds.fill(indexMap.feature, indexMap.polygonPosition, indexMap.polygonPosition + nPositions);
  polygons.featureIds.fill(indexMap.polygonFeature, indexMap.polygonPosition, indexMap.polygonPosition + nPositions);
  for (let l = 0, ll = geometry.indices.length; l < ll; ++l) {
    const startPosition = indexMap.polygonPosition;
    polygons.polygonIndices[indexMap.polygonObject++] = startPosition;
    const areas = geometry.areas[l];
    const indices = geometry.indices[l];
    const nextIndices = geometry.indices[l + 1];
    for (let i = 0, il = indices.length; i < il; ++i) {
      const start = indices[i];
      const end = i === il - 1 ? nextIndices === void 0 ? geometry.data.length : nextIndices[0] : indices[i + 1];
      polygons.primitivePolygonIndices[indexMap.polygonRing++] = indexMap.polygonPosition;
      indexMap.polygonPosition += (end - start) / coordLength;
    }
    const endPosition = indexMap.polygonPosition;
    triangulatePolygon(polygons, areas, indices, {
      startPosition,
      endPosition,
      coordLength
    });
  }
}
function triangulatePolygon(polygons, areas, indices, _ref) {
  let {
    startPosition,
    endPosition,
    coordLength
  } = _ref;
  if (!polygons.triangles) {
    return;
  }
  const start = startPosition * coordLength;
  const end = endPosition * coordLength;
  const polygonPositions = polygons.positions.subarray(start, end);
  const offset = indices[0];
  const holes = indices.slice(1).map((n) => (n - offset) / coordLength);
  const triangles = earcut(polygonPositions, holes, coordLength, areas);
  for (let t = 0, tl = triangles.length; t < tl; ++t) {
    polygons.triangles.push(startPosition + triangles[t]);
  }
}
function wrapProps(obj, size) {
  const returnObj = {};
  for (const key in obj) {
    returnObj[key] = {
      value: obj[key],
      size
    };
  }
  return returnObj;
}
function makeAccessorObjects(points, lines, polygons, coordLength) {
  const binaryFeatures = {
    points: {
      ...points,
      positions: {
        value: points.positions,
        size: coordLength
      },
      globalFeatureIds: {
        value: points.globalFeatureIds,
        size: 1
      },
      featureIds: {
        value: points.featureIds,
        size: 1
      },
      numericProps: wrapProps(points.numericProps, 1)
    },
    lines: {
      ...lines,
      positions: {
        value: lines.positions,
        size: coordLength
      },
      pathIndices: {
        value: lines.pathIndices,
        size: 1
      },
      globalFeatureIds: {
        value: lines.globalFeatureIds,
        size: 1
      },
      featureIds: {
        value: lines.featureIds,
        size: 1
      },
      numericProps: wrapProps(lines.numericProps, 1)
    },
    polygons: {
      ...polygons,
      positions: {
        value: polygons.positions,
        size: coordLength
      },
      polygonIndices: {
        value: polygons.polygonIndices,
        size: 1
      },
      primitivePolygonIndices: {
        value: polygons.primitivePolygonIndices,
        size: 1
      },
      globalFeatureIds: {
        value: polygons.globalFeatureIds,
        size: 1
      },
      featureIds: {
        value: polygons.featureIds,
        size: 1
      },
      numericProps: wrapProps(polygons.numericProps, 1)
    }
  };
  if (polygons.triangles) {
    binaryFeatures.polygons.triangles = {
      value: new Uint32Array(polygons.triangles),
      size: 1
    };
  }
  return binaryFeatures;
}
function fillNumericProperties(object, properties, index, length) {
  for (const numericPropName in object.numericProps) {
    if (numericPropName in properties) {
      const value = properties[numericPropName];
      object.numericProps[numericPropName].fill(value, index, index + length);
    }
  }
}
function keepStringProperties(properties, numericKeys) {
  const props = {};
  for (const key in properties) {
    if (!numericKeys.includes(key)) {
      props[key] = properties[key];
    }
  }
  return props;
}
function deduceArrayType(x, constructor) {
  if (constructor === Array || !Number.isFinite(x)) {
    return Array;
  }
  return constructor === Float64Array || Math.fround(x) !== x ? Float64Array : Float32Array;
}

// ../node_modules/@loaders.gl/gis/dist/esm/lib/extract-geometry-info.js
function extractGeometryInfo(features) {
  let pointPositionsCount = 0;
  let pointFeaturesCount = 0;
  let linePositionsCount = 0;
  let linePathsCount = 0;
  let lineFeaturesCount = 0;
  let polygonPositionsCount = 0;
  let polygonObjectsCount = 0;
  let polygonRingsCount = 0;
  let polygonFeaturesCount = 0;
  const coordLengths = /* @__PURE__ */ new Set();
  for (const feature of features) {
    const geometry = feature.geometry;
    switch (geometry.type) {
      case "Point":
        pointFeaturesCount++;
        pointPositionsCount++;
        coordLengths.add(geometry.coordinates.length);
        break;
      case "MultiPoint":
        pointFeaturesCount++;
        pointPositionsCount += geometry.coordinates.length;
        for (const point of geometry.coordinates) {
          coordLengths.add(point.length);
        }
        break;
      case "LineString":
        lineFeaturesCount++;
        linePositionsCount += geometry.coordinates.length;
        linePathsCount++;
        for (const coord2 of geometry.coordinates) {
          coordLengths.add(coord2.length);
        }
        break;
      case "MultiLineString":
        lineFeaturesCount++;
        for (const line of geometry.coordinates) {
          linePositionsCount += line.length;
          linePathsCount++;
          for (const coord2 of line) {
            coordLengths.add(coord2.length);
          }
        }
        break;
      case "Polygon":
        polygonFeaturesCount++;
        polygonObjectsCount++;
        polygonRingsCount += geometry.coordinates.length;
        const flattened = geometry.coordinates.flat();
        polygonPositionsCount += flattened.length;
        for (const coord2 of flattened) {
          coordLengths.add(coord2.length);
        }
        break;
      case "MultiPolygon":
        polygonFeaturesCount++;
        for (const polygon of geometry.coordinates) {
          polygonObjectsCount++;
          polygonRingsCount += polygon.length;
          const flattened2 = polygon.flat();
          polygonPositionsCount += flattened2.length;
          for (const coord2 of flattened2) {
            coordLengths.add(coord2.length);
          }
        }
        break;
      default:
        throw new Error("Unsupported geometry type: ".concat(geometry.type));
    }
  }
  return {
    coordLength: coordLengths.size > 0 ? Math.max(...coordLengths) : 2,
    pointPositionsCount,
    pointFeaturesCount,
    linePositionsCount,
    linePathsCount,
    lineFeaturesCount,
    polygonPositionsCount,
    polygonObjectsCount,
    polygonRingsCount,
    polygonFeaturesCount
  };
}

// ../node_modules/@loaders.gl/gis/dist/esm/lib/geojson-to-flat-geojson.js
function geojsonToFlatGeojson(features) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    coordLength: 2,
    fixRingWinding: true
  };
  return features.map((feature) => flattenFeature(feature, options));
}
function flattenPoint(coordinates, data, indices, options) {
  indices.push(data.length);
  data.push(...coordinates);
  for (let i = coordinates.length; i < options.coordLength; i++) {
    data.push(0);
  }
}
function flattenLineString(coordinates, data, indices, options) {
  indices.push(data.length);
  for (const c of coordinates) {
    data.push(...c);
    for (let i = c.length; i < options.coordLength; i++) {
      data.push(0);
    }
  }
}
function flattenPolygon(coordinates, data, indices, areas, options) {
  let count = 0;
  const ringAreas = [];
  const polygons = [];
  for (const lineString of coordinates) {
    const lineString2d = lineString.map((p) => p.slice(0, 2));
    let area = getPolygonSignedArea(lineString2d.flat());
    const ccw = area < 0;
    if (options.fixRingWinding && (count === 0 && !ccw || count > 0 && ccw)) {
      lineString.reverse();
      area = -area;
    }
    ringAreas.push(area);
    flattenLineString(lineString, data, polygons, options);
    count++;
  }
  if (count > 0) {
    areas.push(ringAreas);
    indices.push(polygons);
  }
}
function flattenFeature(feature, options) {
  const {
    geometry
  } = feature;
  if (geometry.type === "GeometryCollection") {
    throw new Error("GeometryCollection type not supported");
  }
  const data = [];
  const indices = [];
  let areas;
  let type;
  switch (geometry.type) {
    case "Point":
      type = "Point";
      flattenPoint(geometry.coordinates, data, indices, options);
      break;
    case "MultiPoint":
      type = "Point";
      geometry.coordinates.map((c) => flattenPoint(c, data, indices, options));
      break;
    case "LineString":
      type = "LineString";
      flattenLineString(geometry.coordinates, data, indices, options);
      break;
    case "MultiLineString":
      type = "LineString";
      geometry.coordinates.map((c) => flattenLineString(c, data, indices, options));
      break;
    case "Polygon":
      type = "Polygon";
      areas = [];
      flattenPolygon(geometry.coordinates, data, indices, areas, options);
      break;
    case "MultiPolygon":
      type = "Polygon";
      areas = [];
      geometry.coordinates.map((c) => flattenPolygon(c, data, indices, areas, options));
      break;
    default:
      throw new Error("Unknown type: ".concat(type));
  }
  return {
    ...feature,
    geometry: {
      type,
      indices,
      data,
      areas
    }
  };
}

// ../node_modules/@loaders.gl/gis/dist/esm/lib/geojson-to-binary.js
function geojsonToBinary(features) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    fixRingWinding: true,
    triangulate: true
  };
  const geometryInfo = extractGeometryInfo(features);
  const coordLength = geometryInfo.coordLength;
  const {
    fixRingWinding
  } = options;
  const flatFeatures = geojsonToFlatGeojson(features, {
    coordLength,
    fixRingWinding
  });
  return flatGeojsonToBinary(flatFeatures, geometryInfo, {
    numericPropKeys: options.numericPropKeys,
    PositionDataType: options.PositionDataType || Float32Array,
    triangulate: options.triangulate
  });
}

// ../node_modules/@tmcw/togeojson/dist/togeojson.es.js
function nodeVal(x) {
  if (x && x.normalize) {
    x.normalize();
  }
  return x && x.textContent || "";
}
function get1(x, y) {
  const n = x.getElementsByTagName(y);
  return n.length ? n[0] : null;
}
function getLineStyle(extensions) {
  const style = {};
  if (extensions) {
    const lineStyle = get1(extensions, "line");
    if (lineStyle) {
      const color = nodeVal(get1(lineStyle, "color")), opacity = parseFloat(nodeVal(get1(lineStyle, "opacity"))), width = parseFloat(nodeVal(get1(lineStyle, "width")));
      if (color) style.stroke = color;
      if (!isNaN(opacity)) style["stroke-opacity"] = opacity;
      if (!isNaN(width)) style["stroke-width"] = width * 96 / 25.4;
    }
  }
  return style;
}
function getExtensions(node) {
  let values = [];
  if (node !== null) {
    for (let i = 0; i < node.childNodes.length; i++) {
      const child = node.childNodes[i];
      if (child.nodeType !== 1) continue;
      const name = ["heart", "gpxtpx:hr", "hr"].includes(child.nodeName) ? "heart" : child.nodeName;
      if (name === "gpxtpx:TrackPointExtension") {
        values = values.concat(getExtensions(child));
      } else {
        const val = nodeVal(child);
        values.push([name, isNaN(val) ? val : parseFloat(val)]);
      }
    }
  }
  return values;
}
function getMulti(x, ys) {
  const o = {};
  let n;
  let k;
  for (k = 0; k < ys.length; k++) {
    n = get1(x, ys[k]);
    if (n) o[ys[k]] = nodeVal(n);
  }
  return o;
}
function getProperties$1(node) {
  const prop = getMulti(node, [
    "name",
    "cmt",
    "desc",
    "type",
    "time",
    "keywords"
  ]);
  const extensions = node.getElementsByTagNameNS(
    "http://www.garmin.com/xmlschemas/GpxExtensions/v3",
    "*"
  );
  for (let i = 0; i < extensions.length; i++) {
    const extension = extensions[i];
    if (extension.parentNode.parentNode === node) {
      prop[extension.tagName.replace(":", "_")] = nodeVal(extension);
    }
  }
  const links = node.getElementsByTagName("link");
  if (links.length) prop.links = [];
  for (let i = 0; i < links.length; i++) {
    prop.links.push(
      Object.assign(
        { href: links[i].getAttribute("href") },
        getMulti(links[i], ["text", "type"])
      )
    );
  }
  return prop;
}
function coordPair$1(x) {
  const ll = [
    parseFloat(x.getAttribute("lon")),
    parseFloat(x.getAttribute("lat"))
  ];
  const ele = get1(x, "ele");
  const time = get1(x, "time");
  if (ele) {
    const e = parseFloat(nodeVal(ele));
    if (!isNaN(e)) {
      ll.push(e);
    }
  }
  return {
    coordinates: ll,
    time: time ? nodeVal(time) : null,
    extendedValues: getExtensions(get1(x, "extensions"))
  };
}
function getRoute(node) {
  const line = getPoints$1(node, "rtept");
  if (!line) return;
  return {
    type: "Feature",
    properties: Object.assign(
      getProperties$1(node),
      getLineStyle(get1(node, "extensions")),
      { _gpxType: "rte" }
    ),
    geometry: {
      type: "LineString",
      coordinates: line.line
    }
  };
}
function getPoints$1(node, pointname) {
  const pts = node.getElementsByTagName(pointname);
  if (pts.length < 2) return;
  const line = [];
  const times = [];
  const extendedValues = {};
  for (let i = 0; i < pts.length; i++) {
    const c = coordPair$1(pts[i]);
    line.push(c.coordinates);
    if (c.time) times.push(c.time);
    for (let j = 0; j < c.extendedValues.length; j++) {
      const [name, val] = c.extendedValues[j];
      const plural = name === "heart" ? name : name.replace("gpxtpx:", "") + "s";
      if (!extendedValues[plural]) {
        extendedValues[plural] = Array(pts.length).fill(null);
      }
      extendedValues[plural][i] = val;
    }
  }
  return {
    line,
    times,
    extendedValues
  };
}
function getTrack(node) {
  const segments = node.getElementsByTagName("trkseg");
  const track = [];
  const times = [];
  const extractedLines = [];
  for (let i = 0; i < segments.length; i++) {
    const line = getPoints$1(segments[i], "trkpt");
    if (line) {
      extractedLines.push(line);
      if (line.times && line.times.length) times.push(line.times);
    }
  }
  if (extractedLines.length === 0) return;
  const multi = extractedLines.length > 1;
  const properties = Object.assign(
    getProperties$1(node),
    getLineStyle(get1(node, "extensions")),
    { _gpxType: "trk" },
    times.length ? {
      coordinateProperties: {
        times: multi ? times : times[0]
      }
    } : {}
  );
  for (let i = 0; i < extractedLines.length; i++) {
    const line = extractedLines[i];
    track.push(line.line);
    for (const [name, val] of Object.entries(line.extendedValues)) {
      if (!properties.coordinateProperties) {
        properties.coordinateProperties = {};
      }
      const props = properties.coordinateProperties;
      if (multi) {
        if (!props[name])
          props[name] = extractedLines.map(
            (line2) => new Array(line2.line.length).fill(null)
          );
        props[name][i] = val;
      } else {
        props[name] = val;
      }
    }
  }
  return {
    type: "Feature",
    properties,
    geometry: multi ? {
      type: "MultiLineString",
      coordinates: track
    } : {
      type: "LineString",
      coordinates: track[0]
    }
  };
}
function getPoint(node) {
  return {
    type: "Feature",
    properties: Object.assign(getProperties$1(node), getMulti(node, ["sym"])),
    geometry: {
      type: "Point",
      coordinates: coordPair$1(node).coordinates
    }
  };
}
function* gpxGen(doc) {
  const tracks = doc.getElementsByTagName("trk");
  const routes = doc.getElementsByTagName("rte");
  const waypoints = doc.getElementsByTagName("wpt");
  for (let i = 0; i < tracks.length; i++) {
    const feature = getTrack(tracks[i]);
    if (feature) yield feature;
  }
  for (let i = 0; i < routes.length; i++) {
    const feature = getRoute(routes[i]);
    if (feature) yield feature;
  }
  for (let i = 0; i < waypoints.length; i++) {
    yield getPoint(waypoints[i]);
  }
}
function gpx(doc) {
  return {
    type: "FeatureCollection",
    features: Array.from(gpxGen(doc))
  };
}
var EXTENSIONS_NS = "http://www.garmin.com/xmlschemas/ActivityExtension/v2";
var TRACKPOINT_ATTRIBUTES = [
  ["heartRate", "heartRates"],
  ["Cadence", "cadences"],
  // Extended Trackpoint attributes
  ["Speed", "speeds"],
  ["Watts", "watts"]
];
var LAP_ATTRIBUTES = [
  ["TotalTimeSeconds", "totalTimeSeconds"],
  ["DistanceMeters", "distanceMeters"],
  ["MaximumSpeed", "maxSpeed"],
  ["AverageHeartRateBpm", "avgHeartRate"],
  ["MaximumHeartRateBpm", "maxHeartRate"],
  // Extended Lap attributes
  ["AvgSpeed", "avgSpeed"],
  ["AvgWatts", "avgWatts"],
  ["MaxWatts", "maxWatts"]
];
function fromEntries(arr) {
  const obj = {};
  for (const [key, value] of arr) {
    obj[key] = value;
  }
  return obj;
}
function getProperties(node, attributeNames) {
  const properties = [];
  for (const [tag, alias] of attributeNames) {
    let elem = get1(node, tag);
    if (!elem) {
      const elements = node.getElementsByTagNameNS(EXTENSIONS_NS, tag);
      if (elements.length) {
        elem = elements[0];
      }
    }
    const val = parseFloat(nodeVal(elem));
    if (!isNaN(val)) {
      properties.push([alias, val]);
    }
  }
  return properties;
}
function coordPair(x) {
  const lon = nodeVal(get1(x, "LongitudeDegrees"));
  const lat = nodeVal(get1(x, "LatitudeDegrees"));
  if (!lon.length || !lat.length) {
    return null;
  }
  const ll = [parseFloat(lon), parseFloat(lat)];
  const alt = get1(x, "AltitudeMeters");
  const heartRate = get1(x, "HeartRateBpm");
  const time = get1(x, "Time");
  let a;
  if (alt) {
    a = parseFloat(nodeVal(alt));
    if (!isNaN(a)) {
      ll.push(a);
    }
  }
  return {
    coordinates: ll,
    time: time ? nodeVal(time) : null,
    heartRate: heartRate ? parseFloat(nodeVal(heartRate)) : null,
    extensions: getProperties(x, TRACKPOINT_ATTRIBUTES)
  };
}
function getPoints(node, pointname) {
  const pts = node.getElementsByTagName(pointname);
  const line = [];
  const times = [];
  const heartRates = [];
  if (pts.length < 2) return null;
  const result = { extendedProperties: {} };
  for (let i = 0; i < pts.length; i++) {
    const c = coordPair(pts[i]);
    if (c === null) continue;
    line.push(c.coordinates);
    if (c.time) times.push(c.time);
    if (c.heartRate) heartRates.push(c.heartRate);
    for (const [alias, value] of c.extensions) {
      if (!result.extendedProperties[alias]) {
        result.extendedProperties[alias] = Array(pts.length).fill(null);
      }
      result.extendedProperties[alias][i] = value;
    }
  }
  return Object.assign(result, {
    line,
    times,
    heartRates
  });
}
function getLap(node) {
  const segments = node.getElementsByTagName("Track");
  const track = [];
  const times = [];
  const heartRates = [];
  const allExtendedProperties = [];
  let line;
  const properties = fromEntries(getProperties(node, LAP_ATTRIBUTES));
  const nameElement = get1(node, "Name");
  if (nameElement) {
    properties.name = nodeVal(nameElement);
  }
  for (let i = 0; i < segments.length; i++) {
    line = getPoints(segments[i], "Trackpoint");
    if (line) {
      track.push(line.line);
      if (line.times.length) times.push(line.times);
      if (line.heartRates.length) heartRates.push(line.heartRates);
      allExtendedProperties.push(line.extendedProperties);
    }
  }
  for (let i = 0; i < allExtendedProperties.length; i++) {
    const extendedProperties = allExtendedProperties[i];
    for (const property in extendedProperties) {
      if (segments.length === 1) {
        properties[property] = line.extendedProperties[property];
      } else {
        if (!properties[property]) {
          properties[property] = track.map(
            (track2) => Array(track2.length).fill(null)
          );
        }
        properties[property][i] = extendedProperties[property];
      }
    }
  }
  if (track.length === 0) return;
  if (times.length || heartRates.length) {
    properties.coordinateProperties = Object.assign(
      times.length ? {
        times: track.length === 1 ? times[0] : times
      } : {},
      heartRates.length ? {
        heart: track.length === 1 ? heartRates[0] : heartRates
      } : {}
    );
  }
  return {
    type: "Feature",
    properties,
    geometry: {
      type: track.length === 1 ? "LineString" : "MultiLineString",
      coordinates: track.length === 1 ? track[0] : track
    }
  };
}
function* tcxGen(doc) {
  const laps = doc.getElementsByTagName("Lap");
  for (let i = 0; i < laps.length; i++) {
    const feature = getLap(laps[i]);
    if (feature) yield feature;
  }
  const courses = doc.getElementsByTagName("Courses");
  for (let i = 0; i < courses.length; i++) {
    const feature = getLap(courses[i]);
    if (feature) yield feature;
  }
}
function tcx(doc) {
  return {
    type: "FeatureCollection",
    features: Array.from(tcxGen(doc))
  };
}
var removeSpace = /\s*/g;
var trimSpace = /^\s*|\s*$/g;
var splitSpace = /\s+/;
function okhash(x) {
  if (!x || !x.length) return 0;
  let h = 0;
  for (let i = 0; i < x.length; i++) {
    h = (h << 5) - h + x.charCodeAt(i) | 0;
  }
  return h;
}
function coord1(v) {
  return v.replace(removeSpace, "").split(",").map(parseFloat);
}
function coord(v) {
  return v.replace(trimSpace, "").split(splitSpace).map(coord1);
}
function xml2str(node) {
  if (node.xml !== void 0) return node.xml;
  if (node.tagName) {
    let output = node.tagName;
    for (let i = 0; i < node.attributes.length; i++) {
      output += node.attributes[i].name + node.attributes[i].value;
    }
    for (let i = 0; i < node.childNodes.length; i++) {
      output += xml2str(node.childNodes[i]);
    }
    return output;
  }
  if (node.nodeName === "#text") {
    return (node.nodeValue || node.value || "").trim();
  }
  if (node.nodeName === "#cdata-section") {
    return node.nodeValue;
  }
  return "";
}
var geotypes = ["Polygon", "LineString", "Point", "Track", "gx:Track"];
function kmlColor(properties, elem, prefix) {
  let v = nodeVal(get1(elem, "color")) || "";
  const colorProp = prefix == "stroke" || prefix === "fill" ? prefix : prefix + "-color";
  if (v.substr(0, 1) === "#") {
    v = v.substr(1);
  }
  if (v.length === 6 || v.length === 3) {
    properties[colorProp] = v;
  } else if (v.length === 8) {
    properties[prefix + "-opacity"] = parseInt(v.substr(0, 2), 16) / 255;
    properties[colorProp] = "#" + v.substr(6, 2) + v.substr(4, 2) + v.substr(2, 2);
  }
}
function numericProperty(properties, elem, source, target) {
  const val = parseFloat(nodeVal(get1(elem, source)));
  if (!isNaN(val)) properties[target] = val;
}
function gxCoords(root) {
  let elems = root.getElementsByTagName("coord");
  const coords = [];
  const times = [];
  if (elems.length === 0) elems = root.getElementsByTagName("gx:coord");
  for (let i = 0; i < elems.length; i++) {
    coords.push(nodeVal(elems[i]).split(" ").map(parseFloat));
  }
  const timeElems = root.getElementsByTagName("when");
  for (let j = 0; j < timeElems.length; j++) times.push(nodeVal(timeElems[j]));
  return {
    coords,
    times
  };
}
function getGeometry(root) {
  let geomNode;
  let geomNodes;
  let i;
  let j;
  let k;
  const geoms = [];
  const coordTimes = [];
  if (get1(root, "MultiGeometry")) {
    return getGeometry(get1(root, "MultiGeometry"));
  }
  if (get1(root, "MultiTrack")) {
    return getGeometry(get1(root, "MultiTrack"));
  }
  if (get1(root, "gx:MultiTrack")) {
    return getGeometry(get1(root, "gx:MultiTrack"));
  }
  for (i = 0; i < geotypes.length; i++) {
    geomNodes = root.getElementsByTagName(geotypes[i]);
    if (geomNodes) {
      for (j = 0; j < geomNodes.length; j++) {
        geomNode = geomNodes[j];
        if (geotypes[i] === "Point") {
          geoms.push({
            type: "Point",
            coordinates: coord1(nodeVal(get1(geomNode, "coordinates")))
          });
        } else if (geotypes[i] === "LineString") {
          geoms.push({
            type: "LineString",
            coordinates: coord(nodeVal(get1(geomNode, "coordinates")))
          });
        } else if (geotypes[i] === "Polygon") {
          const rings = geomNode.getElementsByTagName("LinearRing"), coords = [];
          for (k = 0; k < rings.length; k++) {
            coords.push(coord(nodeVal(get1(rings[k], "coordinates"))));
          }
          geoms.push({
            type: "Polygon",
            coordinates: coords
          });
        } else if (geotypes[i] === "Track" || geotypes[i] === "gx:Track") {
          const track = gxCoords(geomNode);
          geoms.push({
            type: "LineString",
            coordinates: track.coords
          });
          if (track.times.length) coordTimes.push(track.times);
        }
      }
    }
  }
  return {
    geoms,
    coordTimes
  };
}
function getPlacemark(root, styleIndex, styleMapIndex, styleByHash) {
  const geomsAndTimes = getGeometry(root);
  let i;
  const properties = {};
  const name = nodeVal(get1(root, "name"));
  const address = nodeVal(get1(root, "address"));
  let styleUrl = nodeVal(get1(root, "styleUrl"));
  const description = nodeVal(get1(root, "description"));
  const timeSpan = get1(root, "TimeSpan");
  const timeStamp = get1(root, "TimeStamp");
  const extendedData = get1(root, "ExtendedData");
  let iconStyle = get1(root, "IconStyle");
  let labelStyle = get1(root, "LabelStyle");
  let lineStyle = get1(root, "LineStyle");
  let polyStyle = get1(root, "PolyStyle");
  const visibility = get1(root, "visibility");
  if (name) properties.name = name;
  if (address) properties.address = address;
  if (styleUrl) {
    if (styleUrl[0] !== "#") {
      styleUrl = "#" + styleUrl;
    }
    properties.styleUrl = styleUrl;
    if (styleIndex[styleUrl]) {
      properties.styleHash = styleIndex[styleUrl];
    }
    if (styleMapIndex[styleUrl]) {
      properties.styleMapHash = styleMapIndex[styleUrl];
      properties.styleHash = styleIndex[styleMapIndex[styleUrl].normal];
    }
    const style = styleByHash[properties.styleHash];
    if (style) {
      if (!iconStyle) iconStyle = get1(style, "IconStyle");
      if (!labelStyle) labelStyle = get1(style, "LabelStyle");
      if (!lineStyle) lineStyle = get1(style, "LineStyle");
      if (!polyStyle) polyStyle = get1(style, "PolyStyle");
    }
  }
  if (description) properties.description = description;
  if (timeSpan) {
    const begin = nodeVal(get1(timeSpan, "begin"));
    const end = nodeVal(get1(timeSpan, "end"));
    properties.timespan = { begin, end };
  }
  if (timeStamp) {
    properties.timestamp = nodeVal(get1(timeStamp, "when"));
  }
  if (iconStyle) {
    kmlColor(properties, iconStyle, "icon");
    numericProperty(properties, iconStyle, "scale", "icon-scale");
    numericProperty(properties, iconStyle, "heading", "icon-heading");
    const hotspot = get1(iconStyle, "hotSpot");
    if (hotspot) {
      const left = parseFloat(hotspot.getAttribute("x"));
      const top = parseFloat(hotspot.getAttribute("y"));
      if (!isNaN(left) && !isNaN(top)) properties["icon-offset"] = [left, top];
    }
    const icon = get1(iconStyle, "Icon");
    if (icon) {
      const href = nodeVal(get1(icon, "href"));
      if (href) properties.icon = href;
    }
  }
  if (labelStyle) {
    kmlColor(properties, labelStyle, "label");
    numericProperty(properties, labelStyle, "scale", "label-scale");
  }
  if (lineStyle) {
    kmlColor(properties, lineStyle, "stroke");
    numericProperty(properties, lineStyle, "width", "stroke-width");
  }
  if (polyStyle) {
    kmlColor(properties, polyStyle, "fill");
    const fill = nodeVal(get1(polyStyle, "fill"));
    const outline = nodeVal(get1(polyStyle, "outline"));
    if (fill)
      properties["fill-opacity"] = fill === "1" ? properties["fill-opacity"] || 1 : 0;
    if (outline)
      properties["stroke-opacity"] = outline === "1" ? properties["stroke-opacity"] || 1 : 0;
  }
  if (extendedData) {
    const datas = extendedData.getElementsByTagName("Data"), simpleDatas = extendedData.getElementsByTagName("SimpleData");
    for (i = 0; i < datas.length; i++) {
      properties[datas[i].getAttribute("name")] = nodeVal(
        get1(datas[i], "value")
      );
    }
    for (i = 0; i < simpleDatas.length; i++) {
      properties[simpleDatas[i].getAttribute("name")] = nodeVal(simpleDatas[i]);
    }
  }
  if (visibility) {
    properties.visibility = nodeVal(visibility);
  }
  if (geomsAndTimes.coordTimes.length) {
    properties.coordinateProperties = {
      times: geomsAndTimes.coordTimes.length === 1 ? geomsAndTimes.coordTimes[0] : geomsAndTimes.coordTimes
    };
  }
  const feature = {
    type: "Feature",
    geometry: geomsAndTimes.geoms.length === 0 ? null : geomsAndTimes.geoms.length === 1 ? geomsAndTimes.geoms[0] : {
      type: "GeometryCollection",
      geometries: geomsAndTimes.geoms
    },
    properties
  };
  if (root.getAttribute("id")) feature.id = root.getAttribute("id");
  return feature;
}
function* kmlGen(doc) {
  const styleIndex = {};
  const styleByHash = {};
  const styleMapIndex = {};
  const placemarks = doc.getElementsByTagName("Placemark");
  const styles = doc.getElementsByTagName("Style");
  const styleMaps = doc.getElementsByTagName("StyleMap");
  for (let k = 0; k < styles.length; k++) {
    const style = styles[k];
    const hash = okhash(xml2str(style)).toString(16);
    let id = style.getAttribute("id");
    if (!id && style.parentNode.tagName.replace("gx:", "") === "CascadingStyle") {
      id = style.parentNode.getAttribute("kml:id") || style.parentNode.getAttribute("id");
    }
    styleIndex["#" + id] = hash;
    styleByHash[hash] = style;
  }
  for (let l = 0; l < styleMaps.length; l++) {
    styleIndex["#" + styleMaps[l].getAttribute("id")] = okhash(
      xml2str(styleMaps[l])
    ).toString(16);
    const pairs = styleMaps[l].getElementsByTagName("Pair");
    const pairsMap = {};
    for (let m = 0; m < pairs.length; m++) {
      pairsMap[nodeVal(get1(pairs[m], "key"))] = nodeVal(
        get1(pairs[m], "styleUrl")
      );
    }
    styleMapIndex["#" + styleMaps[l].getAttribute("id")] = pairsMap;
  }
  for (let j = 0; j < placemarks.length; j++) {
    const feature = getPlacemark(
      placemarks[j],
      styleIndex,
      styleMapIndex,
      styleByHash
    );
    if (feature) yield feature;
  }
}
function kml(doc) {
  return {
    type: "FeatureCollection",
    features: Array.from(kmlGen(doc))
  };
}

// ../node_modules/@loaders.gl/kml/dist/esm/gpx-loader.js
var VERSION = true ? "3.4.15" : "latest";
var GPX_HEADER = '<?xml version="1.0" encoding="UTF-8"?>\n<gpx';
var GPXLoader = {
  name: "GPX (GPS exchange format)",
  id: "gpx",
  module: "kml",
  version: VERSION,
  extensions: ["gpx"],
  mimeTypes: ["application/gpx+xml"],
  text: true,
  tests: [GPX_HEADER],
  parse: async (arrayBuffer, options) => parseTextSync(new TextDecoder().decode(arrayBuffer), options),
  parseTextSync,
  options: {
    gpx: {},
    gis: {}
  }
};
function parseTextSync(text, options) {
  var _options$gis, _options$gpx, _options$gpx2;
  const doc = new DOMParser().parseFromString(text, "text/xml");
  const geojson = gpx(doc);
  const shape = (options === null || options === void 0 ? void 0 : (_options$gis = options.gis) === null || _options$gis === void 0 ? void 0 : _options$gis.format) || (options === null || options === void 0 ? void 0 : (_options$gpx = options.gpx) === null || _options$gpx === void 0 ? void 0 : _options$gpx.type) || (options === null || options === void 0 ? void 0 : (_options$gpx2 = options.gpx) === null || _options$gpx2 === void 0 ? void 0 : _options$gpx2.shape);
  switch (shape) {
    case "object-row-table": {
      const table = {
        shape: "object-row-table",
        data: geojson.features
      };
      return table;
    }
    case "geojson-row-table": {
      const table = {
        shape: "geojson-row-table",
        data: geojson.features
      };
      return table;
    }
    case "geojson":
      return geojson;
    case "binary":
      return geojsonToBinary(geojson.features);
    case "raw":
      return doc;
    default:
      return geojson;
  }
}

// ../node_modules/@loaders.gl/kml/dist/esm/kml-loader.js
var VERSION2 = true ? "3.4.15" : "latest";
var KML_HEADER = '<?xml version="1.0" encoding="UTF-8"?>\n<kml xmlns="http://www.opengis.net/kml/2.2">';
var KMLLoader = {
  name: "KML (Keyhole Markup Language)",
  id: "kml",
  module: "kml",
  version: VERSION2,
  extensions: ["kml"],
  mimeTypes: ["application/vnd.google-earth.kml+xml"],
  text: true,
  tests: [KML_HEADER],
  parse: async (arrayBuffer, options) => parseTextSync2(new TextDecoder().decode(arrayBuffer), options),
  parseTextSync: parseTextSync2,
  options: {
    kml: {},
    gis: {}
  }
};
function parseTextSync2(text, options) {
  var _options$gis, _options$kml, _options$kml2;
  const doc = new DOMParser().parseFromString(text, "text/xml");
  const geojson = kml(doc);
  const shape = (options === null || options === void 0 ? void 0 : (_options$gis = options.gis) === null || _options$gis === void 0 ? void 0 : _options$gis.format) || (options === null || options === void 0 ? void 0 : (_options$kml = options.kml) === null || _options$kml === void 0 ? void 0 : _options$kml.type) || (options === null || options === void 0 ? void 0 : (_options$kml2 = options.kml) === null || _options$kml2 === void 0 ? void 0 : _options$kml2.shape);
  switch (shape) {
    case "object-row-table": {
      const table = {
        shape: "object-row-table",
        data: geojson.features
      };
      return table;
    }
    case "geojson-row-table": {
      const table = {
        shape: "geojson-row-table",
        data: geojson.features
      };
      return table;
    }
    case "geojson":
      return geojson;
    case "binary":
      return geojsonToBinary(geojson.features);
    case "raw":
      return doc;
    default:
      return geojson;
  }
}

// ../node_modules/@loaders.gl/kml/dist/esm/tcx-loader.js
var VERSION3 = true ? "3.4.15" : "latest";
var TCX_HEADER = '<?xml version="1.0" encoding="UTF-8"?>\n<TrainingCenterDatabase';
var TCXLoader = {
  name: "TCX (Training Center XML)",
  id: "tcx",
  module: "kml",
  version: VERSION3,
  extensions: ["tcx"],
  mimeTypes: ["application/vnd.garmin.tcx+xml"],
  text: true,
  tests: [TCX_HEADER],
  parse: async (arrayBuffer, options) => parseTextSync3(new TextDecoder().decode(arrayBuffer), options),
  parseTextSync: parseTextSync3,
  options: {
    tcx: {},
    gis: {}
  }
};
function parseTextSync3(text, options) {
  var _options$gis, _options$tcx, _options$tcx2;
  const doc = new DOMParser().parseFromString(text, "text/xml");
  const geojson = tcx(doc);
  const shape = (options === null || options === void 0 ? void 0 : (_options$gis = options.gis) === null || _options$gis === void 0 ? void 0 : _options$gis.format) || (options === null || options === void 0 ? void 0 : (_options$tcx = options.tcx) === null || _options$tcx === void 0 ? void 0 : _options$tcx.type) || (options === null || options === void 0 ? void 0 : (_options$tcx2 = options.tcx) === null || _options$tcx2 === void 0 ? void 0 : _options$tcx2.shape);
  switch (shape) {
    case "object-row-table": {
      const table = {
        shape: "object-row-table",
        data: geojson.features
      };
      return table;
    }
    case "geojson-row-table": {
      const table = {
        shape: "geojson-row-table",
        data: geojson.features
      };
      return table;
    }
    case "geojson":
      return geojson;
    case "binary":
      return geojsonToBinary(geojson.features);
    case "raw":
      return doc;
    default:
      return geojson;
  }
}
export {
  GPXLoader,
  KMLLoader,
  TCXLoader
};
//# sourceMappingURL=@loaders__gl_kml.js.map
