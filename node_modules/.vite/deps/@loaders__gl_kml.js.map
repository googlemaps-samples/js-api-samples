{
  "version": 3,
  "sources": ["../../@loaders.gl/gis/src/lib/flat-geojson-to-binary.ts", "../../@loaders.gl/gis/src/lib/extract-geometry-info.ts", "../../@loaders.gl/gis/src/lib/geojson-to-flat-geojson.ts", "../../@loaders.gl/gis/src/lib/geojson-to-binary.ts", "../../@tmcw/togeojson/lib/shared.js", "../../@tmcw/togeojson/lib/gpx.js", "../../@tmcw/togeojson/lib/tcx.js", "../../@tmcw/togeojson/lib/kml.js", "../../@loaders.gl/kml/src/gpx-loader.ts", "../../@loaders.gl/kml/src/kml-loader.ts", "../../@loaders.gl/kml/src/tcx-loader.ts"],
  "sourcesContent": ["/* eslint-disable indent */\nimport {earcut} from '@math.gl/polygon';\nimport type {\n  BinaryAttribute,\n  BinaryFeatures,\n  BinaryPolygonFeatures,\n  FlatFeature,\n  FlatPoint,\n  FlatLineString,\n  FlatPolygon,\n  GeojsonGeometryInfo,\n  TypedArray\n} from '@loaders.gl/schema';\nimport {PropArrayConstructor, Lines, Points, Polygons} from './flat-geojson-to-binary-types';\n\n/**\n * Convert binary features to flat binary arrays. Similar to\n * `geojsonToBinary` helper function, except that it expects\n * a binary representation of the feature data, which enables\n * 2X-3X speed increase in parse speed, compared to using\n * geoJSON. See `binary-vector-tile/VectorTileFeature` for\n * data format detais\n *\n * @param features\n * @param geometryInfo\n * @param options\n * @returns filled arrays\n */\nexport function flatGeojsonToBinary(\n  features: FlatFeature[],\n  geometryInfo: GeojsonGeometryInfo,\n  options?: FlatGeojsonToBinaryOptions\n) {\n  const propArrayTypes = extractNumericPropTypes(features);\n  const numericPropKeys = Object.keys(propArrayTypes).filter((k) => propArrayTypes[k] !== Array);\n  return fillArrays(\n    features,\n    {\n      propArrayTypes,\n      ...geometryInfo\n    },\n    {\n      numericPropKeys: (options && options.numericPropKeys) || numericPropKeys,\n      PositionDataType: options ? options.PositionDataType : Float32Array,\n      triangulate: options ? options.triangulate : true\n    }\n  );\n}\n\n/**\n * Options for `flatGeojsonToBinary`\n */\nexport type FlatGeojsonToBinaryOptions = {\n  numericPropKeys?: string[];\n  PositionDataType?: Float32ArrayConstructor | Float64ArrayConstructor;\n  triangulate?: boolean;\n};\n\nexport const TEST_EXPORTS = {\n  extractNumericPropTypes\n};\n\n/**\n * Extracts properties that are always numeric\n *\n * @param features\n * @returns object with numeric types\n */\nfunction extractNumericPropTypes(features: FlatFeature[]): {\n  [key: string]: PropArrayConstructor;\n} {\n  const propArrayTypes = {};\n  for (const feature of features) {\n    if (feature.properties) {\n      for (const key in feature.properties) {\n        // If property has not been seen before, or if property has been numeric\n        // in all previous features, check if numeric in this feature\n        // If not numeric, Array is stored to prevent rechecking in the future\n        // Additionally, detects if 64 bit precision is required\n        const val = feature.properties[key];\n        propArrayTypes[key] = deduceArrayType(val, propArrayTypes[key]);\n      }\n    }\n  }\n\n  return propArrayTypes;\n}\n\n/**\n * Fills coordinates into pre-allocated typed arrays\n *\n * @param features\n * @param geometryInfo\n * @param options\n * @returns an accessor object with value and size keys\n */\n// eslint-disable-next-line complexity\nfunction fillArrays(\n  features: FlatFeature[],\n  geometryInfo: GeojsonGeometryInfo & {\n    propArrayTypes: {[key: string]: PropArrayConstructor};\n  },\n  options: FlatGeojsonToBinaryOptions\n) {\n  const {\n    pointPositionsCount,\n    pointFeaturesCount,\n    linePositionsCount,\n    linePathsCount,\n    lineFeaturesCount,\n    polygonPositionsCount,\n    polygonObjectsCount,\n    polygonRingsCount,\n    polygonFeaturesCount,\n    propArrayTypes,\n    coordLength\n  } = geometryInfo;\n  const {numericPropKeys = [], PositionDataType = Float32Array, triangulate = true} = options;\n  const hasGlobalId = features[0] && 'id' in features[0];\n  const GlobalFeatureIdsDataType = features.length > 65535 ? Uint32Array : Uint16Array;\n  const points: Points = {\n    type: 'Point',\n    positions: new PositionDataType(pointPositionsCount * coordLength),\n    globalFeatureIds: new GlobalFeatureIdsDataType(pointPositionsCount),\n    featureIds:\n      pointFeaturesCount > 65535\n        ? new Uint32Array(pointPositionsCount)\n        : new Uint16Array(pointPositionsCount),\n    numericProps: {},\n    properties: [],\n    fields: []\n  };\n  const lines: Lines = {\n    type: 'LineString',\n    pathIndices:\n      linePositionsCount > 65535\n        ? new Uint32Array(linePathsCount + 1)\n        : new Uint16Array(linePathsCount + 1),\n    positions: new PositionDataType(linePositionsCount * coordLength),\n    globalFeatureIds: new GlobalFeatureIdsDataType(linePositionsCount),\n    featureIds:\n      lineFeaturesCount > 65535\n        ? new Uint32Array(linePositionsCount)\n        : new Uint16Array(linePositionsCount),\n    numericProps: {},\n    properties: [],\n    fields: []\n  };\n  const polygons: Polygons = {\n    type: 'Polygon',\n    polygonIndices:\n      polygonPositionsCount > 65535\n        ? new Uint32Array(polygonObjectsCount + 1)\n        : new Uint16Array(polygonObjectsCount + 1),\n    primitivePolygonIndices:\n      polygonPositionsCount > 65535\n        ? new Uint32Array(polygonRingsCount + 1)\n        : new Uint16Array(polygonRingsCount + 1),\n    positions: new PositionDataType(polygonPositionsCount * coordLength),\n    globalFeatureIds: new GlobalFeatureIdsDataType(polygonPositionsCount),\n    featureIds:\n      polygonFeaturesCount > 65535\n        ? new Uint32Array(polygonPositionsCount)\n        : new Uint16Array(polygonPositionsCount),\n    numericProps: {},\n    properties: [],\n    fields: []\n  };\n\n  if (triangulate) {\n    polygons.triangles = [];\n  }\n\n  // Instantiate numeric properties arrays; one value per vertex\n  for (const object of [points, lines, polygons]) {\n    for (const propName of numericPropKeys) {\n      // If property has been numeric in all previous features in which the property existed, check\n      // if numeric in this feature\n      const T = propArrayTypes[propName];\n      object.numericProps[propName] = new T(object.positions.length / coordLength) as TypedArray;\n    }\n  }\n\n  // Set last element of path/polygon indices as positions length\n  lines.pathIndices[linePathsCount] = linePositionsCount;\n  polygons.polygonIndices[polygonObjectsCount] = polygonPositionsCount;\n  polygons.primitivePolygonIndices[polygonRingsCount] = polygonPositionsCount;\n\n  const indexMap = {\n    pointPosition: 0,\n    pointFeature: 0,\n    linePosition: 0,\n    linePath: 0,\n    lineFeature: 0,\n    polygonPosition: 0,\n    polygonObject: 0,\n    polygonRing: 0,\n    polygonFeature: 0,\n    feature: 0\n  };\n\n  for (const feature of features) {\n    const geometry = feature.geometry;\n    const properties = feature.properties || {};\n\n    switch (geometry.type) {\n      case 'Point':\n        handlePoint(geometry, points, indexMap, coordLength, properties);\n        points.properties.push(keepStringProperties(properties, numericPropKeys));\n        if (hasGlobalId) {\n          points.fields.push({id: feature.id});\n        }\n        indexMap.pointFeature++;\n        break;\n      case 'LineString':\n        handleLineString(geometry, lines, indexMap, coordLength, properties);\n        lines.properties.push(keepStringProperties(properties, numericPropKeys));\n        if (hasGlobalId) {\n          lines.fields.push({id: feature.id});\n        }\n        indexMap.lineFeature++;\n        break;\n      case 'Polygon':\n        handlePolygon(geometry, polygons, indexMap, coordLength, properties);\n        polygons.properties.push(keepStringProperties(properties, numericPropKeys));\n        if (hasGlobalId) {\n          polygons.fields.push({id: feature.id});\n        }\n        indexMap.polygonFeature++;\n        break;\n      default:\n        throw new Error('Invalid geometry type');\n    }\n\n    indexMap.feature++;\n  }\n\n  // Wrap each array in an accessor object with value and size keys\n  return makeAccessorObjects(points, lines, polygons, coordLength);\n}\n\n/**\n * Fills (Multi)Point coordinates into points object of arrays\n *\n * @param geometry\n * @param points\n * @param indexMap\n * @param coordLength\n * @param properties\n */\nfunction handlePoint(\n  geometry: FlatPoint,\n  points: Points,\n  indexMap: {\n    pointPosition: number;\n    pointFeature: number;\n    linePosition?: number;\n    linePath?: number;\n    lineFeature?: number;\n    polygonPosition?: number;\n    polygonObject?: number;\n    polygonRing?: number;\n    polygonFeature?: number;\n    feature: number;\n  },\n  coordLength: number,\n  properties: {[x: string]: string | number | boolean | null}\n): void {\n  points.positions.set(geometry.data, indexMap.pointPosition * coordLength);\n\n  const nPositions = geometry.data.length / coordLength;\n  fillNumericProperties(points, properties, indexMap.pointPosition, nPositions);\n  points.globalFeatureIds.fill(\n    indexMap.feature,\n    indexMap.pointPosition,\n    indexMap.pointPosition + nPositions\n  );\n  points.featureIds.fill(\n    indexMap.pointFeature,\n    indexMap.pointPosition,\n    indexMap.pointPosition + nPositions\n  );\n\n  indexMap.pointPosition += nPositions;\n}\n\n/**\n * Fills (Multi)LineString coordinates into lines object of arrays\n *\n * @param geometry\n * @param lines\n * @param indexMap\n * @param coordLength\n * @param properties\n */\nfunction handleLineString(\n  geometry: FlatLineString,\n  lines: Lines,\n  indexMap: {\n    pointPosition?: number;\n    pointFeature?: number;\n    linePosition: number;\n    linePath: number;\n    lineFeature: number;\n    polygonPosition?: number;\n    polygonObject?: number;\n    polygonRing?: number;\n    polygonFeature?: number;\n    feature: number;\n  },\n  coordLength: number,\n  properties: {[x: string]: string | number | boolean | null}\n): void {\n  lines.positions.set(geometry.data, indexMap.linePosition * coordLength);\n\n  const nPositions = geometry.data.length / coordLength;\n  fillNumericProperties(lines, properties, indexMap.linePosition, nPositions);\n\n  lines.globalFeatureIds.fill(\n    indexMap.feature,\n    indexMap.linePosition,\n    indexMap.linePosition + nPositions\n  );\n  lines.featureIds.fill(\n    indexMap.lineFeature,\n    indexMap.linePosition,\n    indexMap.linePosition + nPositions\n  );\n\n  for (let i = 0, il = geometry.indices.length; i < il; ++i) {\n    // Extract range of data we are working with, defined by start\n    // and end indices (these index into the geometry.data array)\n    const start = geometry.indices[i];\n    const end =\n      i === il - 1\n        ? geometry.data.length // last line, so read to end of data\n        : geometry.indices[i + 1]; // start index for next line\n\n    lines.pathIndices[indexMap.linePath++] = indexMap.linePosition;\n    indexMap.linePosition += (end - start) / coordLength;\n  }\n}\n\n/**\n * Fills (Multi)Polygon coordinates into polygons object of arrays\n *\n * @param geometry\n * @param polygons\n * @param indexMap\n * @param coordLength\n * @param properties\n */\nfunction handlePolygon(\n  geometry: FlatPolygon,\n  polygons: Polygons,\n  indexMap: {\n    pointPosition?: number;\n    pointFeature?: number;\n    linePosition?: number;\n    linePath?: number;\n    lineFeature?: number;\n    polygonPosition: number;\n    polygonObject: number;\n    polygonRing: number;\n    polygonFeature: number;\n    feature: number;\n  },\n  coordLength: number,\n  properties: {[x: string]: string | number | boolean | null}\n): void {\n  polygons.positions.set(geometry.data, indexMap.polygonPosition * coordLength);\n\n  const nPositions = geometry.data.length / coordLength;\n  fillNumericProperties(polygons, properties, indexMap.polygonPosition, nPositions);\n  polygons.globalFeatureIds.fill(\n    indexMap.feature,\n    indexMap.polygonPosition,\n    indexMap.polygonPosition + nPositions\n  );\n  polygons.featureIds.fill(\n    indexMap.polygonFeature,\n    indexMap.polygonPosition,\n    indexMap.polygonPosition + nPositions\n  );\n\n  // Unlike Point & LineString geometry.indices is a 2D array\n  for (let l = 0, ll = geometry.indices.length; l < ll; ++l) {\n    const startPosition = indexMap.polygonPosition;\n    polygons.polygonIndices[indexMap.polygonObject++] = startPosition;\n\n    const areas = geometry.areas[l];\n    const indices = geometry.indices[l];\n    const nextIndices = geometry.indices[l + 1];\n\n    for (let i = 0, il = indices.length; i < il; ++i) {\n      const start = indices[i];\n      const end =\n        i === il - 1\n          ? // last line, so either read to:\n            nextIndices === undefined\n            ? geometry.data.length // end of data (no next indices)\n            : nextIndices[0] // start of first line in nextIndices\n          : indices[i + 1]; // start index for next line\n\n      polygons.primitivePolygonIndices[indexMap.polygonRing++] = indexMap.polygonPosition;\n      indexMap.polygonPosition += (end - start) / coordLength;\n    }\n\n    const endPosition = indexMap.polygonPosition;\n    triangulatePolygon(polygons, areas, indices, {startPosition, endPosition, coordLength});\n  }\n}\n\n/**\n * Triangulate polygon using earcut\n *\n * @param polygons\n * @param areas\n * @param indices\n * @param param3\n */\nfunction triangulatePolygon(\n  polygons: Polygons,\n  areas: number[],\n  indices: number[],\n  {\n    startPosition,\n    endPosition,\n    coordLength\n  }: {startPosition: number; endPosition: number; coordLength: number}\n): void {\n  if (!polygons.triangles) {\n    return;\n  }\n\n  const start = startPosition * coordLength;\n  const end = endPosition * coordLength;\n\n  // Extract positions and holes for just this polygon\n  const polygonPositions = polygons.positions.subarray(start, end);\n\n  // Holes are referenced relative to outer polygon\n  const offset = indices[0];\n  const holes = indices.slice(1).map((n: number) => (n - offset) / coordLength);\n\n  // Compute triangulation\n  // @ts-expect-error TODO can earcut handle binary arrays? Add tests?\n  const triangles = earcut(polygonPositions, holes, coordLength, areas);\n\n  // Indices returned by triangulation are relative to start\n  // of polygon, so we need to offset\n  for (let t = 0, tl = triangles.length; t < tl; ++t) {\n    polygons.triangles.push(startPosition + triangles[t]);\n  }\n}\n\n/**\n * Wraps an object containing array into accessors\n *\n * @param obj\n * @param size\n */\nfunction wrapProps(\n  obj: {[key: string]: TypedArray},\n  size: number\n): {[key: string]: BinaryAttribute} {\n  const returnObj = {};\n  for (const key in obj) {\n    returnObj[key] = {value: obj[key], size};\n  }\n  return returnObj;\n}\n\n/**\n * Wrap each array in an accessor object with value and size keys\n *\n * @param points\n * @param lines\n * @param polygons\n * @param coordLength\n * @returns object\n */\nfunction makeAccessorObjects(\n  points: Points,\n  lines: Lines,\n  polygons: Polygons,\n  coordLength: number\n): BinaryFeatures {\n  const binaryFeatures = {\n    points: {\n      ...points,\n      positions: {value: points.positions, size: coordLength},\n      globalFeatureIds: {value: points.globalFeatureIds, size: 1},\n      featureIds: {value: points.featureIds, size: 1},\n      numericProps: wrapProps(points.numericProps, 1)\n    },\n    lines: {\n      ...lines,\n      positions: {value: lines.positions, size: coordLength},\n      pathIndices: {value: lines.pathIndices, size: 1},\n      globalFeatureIds: {value: lines.globalFeatureIds, size: 1},\n      featureIds: {value: lines.featureIds, size: 1},\n      numericProps: wrapProps(lines.numericProps, 1)\n    },\n    polygons: {\n      ...polygons,\n      positions: {value: polygons.positions, size: coordLength},\n      polygonIndices: {value: polygons.polygonIndices, size: 1},\n      primitivePolygonIndices: {value: polygons.primitivePolygonIndices, size: 1},\n      globalFeatureIds: {value: polygons.globalFeatureIds, size: 1},\n      featureIds: {value: polygons.featureIds, size: 1},\n      numericProps: wrapProps(polygons.numericProps, 1)\n    } as BinaryPolygonFeatures\n  };\n\n  if (polygons.triangles) {\n    binaryFeatures.polygons.triangles = {value: new Uint32Array(polygons.triangles), size: 1};\n  }\n\n  return binaryFeatures;\n}\n\n/**\n * Add numeric properties to object\n *\n * @param object\n * @param properties\n * @param index\n * @param length\n */\nfunction fillNumericProperties(\n  object: Points | Lines | Polygons,\n  properties: {[x: string]: string | number | boolean | null},\n  index: number,\n  length: number\n): void {\n  for (const numericPropName in object.numericProps) {\n    if (numericPropName in properties) {\n      const value = properties[numericPropName] as number;\n      object.numericProps[numericPropName].fill(value, index, index + length);\n    }\n  }\n}\n\n/**\n * Keep string properties in object\n *\n * @param properties\n * @param numericKeys\n * @returns object\n */\nfunction keepStringProperties(\n  properties: {[x: string]: string | number | boolean | null},\n  numericKeys: string[]\n) {\n  const props = {};\n  for (const key in properties) {\n    if (!numericKeys.includes(key)) {\n      props[key] = properties[key];\n    }\n  }\n  return props;\n}\n\n/**\n *\n * Deduce correct array constructor to use for a given value\n *\n * @param x value to test\n * @param constructor previous constructor deduced\n * @returns PropArrayConstructor\n */\nfunction deduceArrayType(x: any, constructor: PropArrayConstructor): PropArrayConstructor {\n  if (constructor === Array || !Number.isFinite(x)) {\n    return Array;\n  }\n\n  // If this or previous value required 64bits use Float64Array\n  return constructor === Float64Array || Math.fround(x) !== x ? Float64Array : Float32Array;\n}\n", "import {Feature, GeojsonGeometryInfo} from '@loaders.gl/schema';\n\n/**\n *  Initial scan over GeoJSON features\n *  Counts number of coordinates of each geometry type and\n *  keeps track of the max coordinate dimensions\n */\n// eslint-disable-next-line complexity, max-statements\nexport function extractGeometryInfo(features: Feature[]): GeojsonGeometryInfo {\n  // Counts the number of _positions_, so [x, y, z] counts as one\n  let pointPositionsCount = 0;\n  let pointFeaturesCount = 0;\n  let linePositionsCount = 0;\n  let linePathsCount = 0;\n  let lineFeaturesCount = 0;\n  let polygonPositionsCount = 0;\n  let polygonObjectsCount = 0;\n  let polygonRingsCount = 0;\n  let polygonFeaturesCount = 0;\n  const coordLengths = new Set<number>();\n\n  for (const feature of features) {\n    const geometry = feature.geometry;\n    switch (geometry.type) {\n      case 'Point':\n        pointFeaturesCount++;\n        pointPositionsCount++;\n        coordLengths.add(geometry.coordinates.length);\n        break;\n      case 'MultiPoint':\n        pointFeaturesCount++;\n        pointPositionsCount += geometry.coordinates.length;\n        for (const point of geometry.coordinates) {\n          coordLengths.add(point.length);\n        }\n        break;\n      case 'LineString':\n        lineFeaturesCount++;\n        linePositionsCount += geometry.coordinates.length;\n        linePathsCount++;\n\n        for (const coord of geometry.coordinates) {\n          coordLengths.add(coord.length);\n        }\n        break;\n      case 'MultiLineString':\n        lineFeaturesCount++;\n        for (const line of geometry.coordinates) {\n          linePositionsCount += line.length;\n          linePathsCount++;\n\n          // eslint-disable-next-line max-depth\n          for (const coord of line) {\n            coordLengths.add(coord.length);\n          }\n        }\n        break;\n      case 'Polygon':\n        polygonFeaturesCount++;\n        polygonObjectsCount++;\n        polygonRingsCount += geometry.coordinates.length;\n        const flattened = geometry.coordinates.flat();\n        polygonPositionsCount += flattened.length;\n\n        for (const coord of flattened) {\n          coordLengths.add(coord.length);\n        }\n        break;\n      case 'MultiPolygon':\n        polygonFeaturesCount++;\n        for (const polygon of geometry.coordinates) {\n          polygonObjectsCount++;\n          polygonRingsCount += polygon.length;\n          const flattened = polygon.flat();\n          polygonPositionsCount += flattened.length;\n\n          // eslint-disable-next-line max-depth\n          for (const coord of flattened) {\n            coordLengths.add(coord.length);\n          }\n        }\n        break;\n      default:\n        throw new Error(`Unsupported geometry type: ${geometry.type}`);\n    }\n  }\n\n  return {\n    coordLength: coordLengths.size > 0 ? Math.max(...coordLengths) : 2,\n\n    pointPositionsCount,\n    pointFeaturesCount,\n    linePositionsCount,\n    linePathsCount,\n    lineFeaturesCount,\n    polygonPositionsCount,\n    polygonObjectsCount,\n    polygonRingsCount,\n    polygonFeaturesCount\n  };\n}\n", "import {getPolygonSignedArea} from '@math.gl/polygon';\n\nimport {Feature, Position, FlatFeature} from '@loaders.gl/schema';\n\n/**\n * Options for `geojsonToFlatGeojson`\n */\nexport type GeojsonToFlatGeojsonOptions = {\n  coordLength: number;\n  fixRingWinding: boolean;\n};\n\n// Coordinates defining a Point\ntype PointCoordinates = Position;\n// Coordinates defining a LineString\ntype LineStringCoordinates = Position[];\n// Coordinates defining a Polygon\ntype PolygonCoordinates = Position[][];\n\n/**\n * Convert GeoJSON features to Flat GeoJSON features\n *\n * @param features\n * @param options\n * @returns an Array of Flat GeoJSON features\n */\nexport function geojsonToFlatGeojson(\n  features: Feature[],\n  options: GeojsonToFlatGeojsonOptions = {coordLength: 2, fixRingWinding: true}\n): FlatFeature[] {\n  return features.map((feature) => flattenFeature(feature, options));\n}\n\n/**\n * Helper function to copy Point values from `coordinates` into `data` & `indices`\n *\n * @param coordinates\n * @param data\n * @param indices\n * @param options\n */\nfunction flattenPoint(\n  coordinates: PointCoordinates,\n  data: number[],\n  indices: number[],\n  options: GeojsonToFlatGeojsonOptions\n) {\n  indices.push(data.length);\n  data.push(...coordinates);\n\n  // Pad up to coordLength\n  for (let i = coordinates.length; i < options.coordLength; i++) {\n    data.push(0);\n  }\n}\n\n/**\n * Helper function to copy LineString values from `coordinates` into `data` & `indices`\n *\n * @param coordinates\n * @param data\n * @param indices\n * @param options\n */\nfunction flattenLineString(\n  coordinates: LineStringCoordinates,\n  data: number[],\n  indices: number[],\n  options: GeojsonToFlatGeojsonOptions\n) {\n  indices.push(data.length);\n  for (const c of coordinates) {\n    data.push(...c);\n\n    // Pad up to coordLength\n    for (let i = c.length; i < options.coordLength; i++) {\n      data.push(0);\n    }\n  }\n}\n\n/**\n * Helper function to copy Polygon values from `coordinates` into `data` & `indices` & `areas`\n *\n * @param coordinates\n * @param data\n * @param indices\n * @param areas\n * @param options\n */\nfunction flattenPolygon(\n  coordinates: PolygonCoordinates,\n  data: number[],\n  indices: number[][],\n  areas: number[][],\n  options: GeojsonToFlatGeojsonOptions\n) {\n  let count = 0;\n  const ringAreas: number[] = [];\n  const polygons: number[] = [];\n  for (const lineString of coordinates) {\n    const lineString2d = lineString.map((p) => p.slice(0, 2));\n    let area = getPolygonSignedArea(lineString2d.flat());\n    const ccw = area < 0;\n\n    // Exterior ring must be CCW and interior rings CW\n    if (options.fixRingWinding && ((count === 0 && !ccw) || (count > 0 && ccw))) {\n      lineString.reverse();\n      area = -area;\n    }\n    ringAreas.push(area);\n    flattenLineString(lineString, data, polygons, options);\n    count++;\n  }\n\n  if (count > 0) {\n    areas.push(ringAreas);\n    indices.push(polygons);\n  }\n}\n\n/**\n * Flatten single GeoJSON feature into Flat GeoJSON\n *\n * @param feature\n * @param options\n * @returns A Flat GeoJSON feature\n */\nfunction flattenFeature(feature: Feature, options: GeojsonToFlatGeojsonOptions): FlatFeature {\n  const {geometry} = feature;\n  if (geometry.type === 'GeometryCollection') {\n    throw new Error('GeometryCollection type not supported');\n  }\n  const data = [];\n  const indices = [];\n  let areas;\n  let type;\n\n  switch (geometry.type) {\n    case 'Point':\n      type = 'Point';\n      flattenPoint(geometry.coordinates, data, indices, options);\n      break;\n    case 'MultiPoint':\n      type = 'Point';\n      geometry.coordinates.map((c) => flattenPoint(c, data, indices, options));\n      break;\n    case 'LineString':\n      type = 'LineString';\n      flattenLineString(geometry.coordinates, data, indices, options);\n      break;\n    case 'MultiLineString':\n      type = 'LineString';\n      geometry.coordinates.map((c) => flattenLineString(c, data, indices, options));\n      break;\n    case 'Polygon':\n      type = 'Polygon';\n      areas = [];\n      flattenPolygon(geometry.coordinates, data, indices, areas, options);\n      break;\n    case 'MultiPolygon':\n      type = 'Polygon';\n      areas = [];\n      geometry.coordinates.map((c) => flattenPolygon(c, data, indices, areas, options));\n      break;\n    default:\n      throw new Error(`Unknown type: ${type}`);\n  }\n\n  return {...feature, geometry: {type, indices, data, areas}};\n}\n", "import type {Feature} from '@loaders.gl/schema';\nimport type {BinaryFeatures} from '@loaders.gl/schema';\n\nimport {extractGeometryInfo} from './extract-geometry-info';\nimport {geojsonToFlatGeojson} from './geojson-to-flat-geojson';\nimport {flatGeojsonToBinary} from './flat-geojson-to-binary';\n\n/**\n * Options for `geojsonToBinary`\n */\nexport type GeojsonToBinaryOptions = {\n  fixRingWinding: boolean;\n  numericPropKeys?: string[];\n  PositionDataType?: Float32ArrayConstructor | Float64ArrayConstructor;\n  triangulate?: boolean;\n};\n\n/**\n * Convert GeoJSON features to flat binary arrays\n *\n * @param features\n * @param options\n * @returns features in binary format, grouped by geometry type\n */\nexport function geojsonToBinary(\n  features: Feature[],\n  options: GeojsonToBinaryOptions = {fixRingWinding: true, triangulate: true}\n): BinaryFeatures {\n  const geometryInfo = extractGeometryInfo(features);\n  const coordLength = geometryInfo.coordLength;\n  const {fixRingWinding} = options;\n  const flatFeatures = geojsonToFlatGeojson(features, {coordLength, fixRingWinding});\n  return flatGeojsonToBinary(flatFeatures, geometryInfo, {\n    numericPropKeys: options.numericPropKeys,\n    PositionDataType: options.PositionDataType || Float32Array,\n    triangulate: options.triangulate\n  });\n}\n", "// cast array x into numbers\n// get the content of a text node, if any\nexport function nodeVal(x) {\n  if (x && x.normalize) {\n    x.normalize();\n  }\n  return (x && x.textContent) || \"\";\n}\n\n// one Y child of X, if any, otherwise null\nexport function get1(x, y) {\n  const n = x.getElementsByTagName(y);\n  return n.length ? n[0] : null;\n}", "import { nodeVal, get1 } from \"./shared.js\";\n\nfunction getLineStyle(extensions) {\n  const style = {};\n  if (extensions) {\n    const lineStyle = get1(extensions, \"line\");\n    if (lineStyle) {\n      const color = nodeVal(get1(lineStyle, \"color\")),\n        opacity = parseFloat(nodeVal(get1(lineStyle, \"opacity\"))),\n        width = parseFloat(nodeVal(get1(lineStyle, \"width\")));\n      if (color) style.stroke = color;\n      if (!isNaN(opacity)) style[\"stroke-opacity\"] = opacity;\n      // GPX width is in mm, convert to px with 96 px per inch\n      if (!isNaN(width)) style[\"stroke-width\"] = (width * 96) / 25.4;\n    }\n  }\n  return style;\n}\n\nfunction getExtensions(node) {\n  let values = [];\n  if (node !== null) {\n    for (let i = 0; i < node.childNodes.length; i++) {\n      const child = node.childNodes[i];\n      if (child.nodeType !== 1) continue;\n      const name = [\"heart\", \"gpxtpx:hr\", \"hr\"].includes(child.nodeName)\n        ? \"heart\"\n        : child.nodeName;\n      if (name === \"gpxtpx:TrackPointExtension\") {\n        // loop again for nested garmin extensions (eg. \"gpxtpx:hr\")\n        values = values.concat(getExtensions(child));\n      } else {\n        // push custom extension (eg. \"power\")\n        const val = nodeVal(child);\n        values.push([name, isNaN(val) ? val : parseFloat(val)]);\n      }\n    }\n  }\n  return values;\n}\n\nfunction getMulti(x, ys) {\n  const o = {};\n  let n;\n  let k;\n  for (k = 0; k < ys.length; k++) {\n    n = get1(x, ys[k]);\n    if (n) o[ys[k]] = nodeVal(n);\n  }\n  return o;\n}\nfunction getProperties(node) {\n  const prop = getMulti(node, [\n    \"name\",\n    \"cmt\",\n    \"desc\",\n    \"type\",\n    \"time\",\n    \"keywords\",\n  ]);\n  // Parse additional data from our Garmin extension(s)\n  const extensions = node.getElementsByTagNameNS(\n    \"http://www.garmin.com/xmlschemas/GpxExtensions/v3\",\n    \"*\"\n  );\n  for (let i = 0; i < extensions.length; i++) {\n    const extension = extensions[i];\n    // Ignore nested extensions, like those on routepoints or trackpoints\n    if (extension.parentNode.parentNode === node) {\n      prop[extension.tagName.replace(\":\", \"_\")] = nodeVal(extension);\n    }\n  }\n  const links = node.getElementsByTagName(\"link\");\n  if (links.length) prop.links = [];\n  for (let i = 0; i < links.length; i++) {\n    prop.links.push(\n      Object.assign(\n        { href: links[i].getAttribute(\"href\") },\n        getMulti(links[i], [\"text\", \"type\"])\n      )\n    );\n  }\n  return prop;\n}\n\nfunction coordPair(x) {\n  const ll = [\n    parseFloat(x.getAttribute(\"lon\")),\n    parseFloat(x.getAttribute(\"lat\")),\n  ];\n  const ele = get1(x, \"ele\");\n  const time = get1(x, \"time\");\n  if (ele) {\n    const e = parseFloat(nodeVal(ele));\n    if (!isNaN(e)) {\n      ll.push(e);\n    }\n  }\n\n  return {\n    coordinates: ll,\n    time: time ? nodeVal(time) : null,\n    extendedValues: getExtensions(get1(x, \"extensions\")),\n  };\n}\nfunction getRoute(node) {\n  const line = getPoints(node, \"rtept\");\n  if (!line) return;\n  return {\n    type: \"Feature\",\n    properties: Object.assign(\n      getProperties(node),\n      getLineStyle(get1(node, \"extensions\")),\n      { _gpxType: \"rte\" }\n    ),\n    geometry: {\n      type: \"LineString\",\n      coordinates: line.line,\n    },\n  };\n}\n\nfunction getPoints(node, pointname) {\n  const pts = node.getElementsByTagName(pointname);\n  if (pts.length < 2) return; // Invalid line in GeoJSON\n\n  const line = [];\n  const times = [];\n  const extendedValues = {};\n  for (let i = 0; i < pts.length; i++) {\n    const c = coordPair(pts[i]);\n    line.push(c.coordinates);\n    if (c.time) times.push(c.time);\n    for (let j = 0; j < c.extendedValues.length; j++) {\n      const [name, val] = c.extendedValues[j];\n      const plural =\n        name === \"heart\" ? name : name.replace(\"gpxtpx:\", \"\") + \"s\";\n      if (!extendedValues[plural]) {\n        extendedValues[plural] = Array(pts.length).fill(null);\n      }\n      extendedValues[plural][i] = val;\n    }\n  }\n  return {\n    line: line,\n    times: times,\n    extendedValues: extendedValues,\n  };\n}\n\nfunction getTrack(node) {\n  const segments = node.getElementsByTagName(\"trkseg\");\n  const track = [];\n  const times = [];\n  const extractedLines = [];\n\n  for (let i = 0; i < segments.length; i++) {\n    const line = getPoints(segments[i], \"trkpt\");\n    if (line) {\n      extractedLines.push(line);\n      if (line.times && line.times.length) times.push(line.times);\n    }\n  }\n\n  if (extractedLines.length === 0) return;\n\n  const multi = extractedLines.length > 1;\n\n  const properties = Object.assign(\n    getProperties(node),\n    getLineStyle(get1(node, \"extensions\")),\n    { _gpxType: \"trk\" },\n    times.length\n      ? {\n          coordinateProperties: {\n            times: multi ? times : times[0],\n          },\n        }\n      : {}\n  );\n\n  for (let i = 0; i < extractedLines.length; i++) {\n    const line = extractedLines[i];\n    track.push(line.line);\n    for (const [name, val] of Object.entries(line.extendedValues)) {\n      if (!properties.coordinateProperties) {\n        properties.coordinateProperties = {};\n      }\n      const props = properties.coordinateProperties;\n      if (multi) {\n        if (!props[name])\n          props[name] = extractedLines.map((line) =>\n            new Array(line.line.length).fill(null)\n          );\n        props[name][i] = val;\n      } else {\n        props[name] = val;\n      }\n    }\n  }\n\n  return {\n    type: \"Feature\",\n    properties: properties,\n    geometry: multi\n      ? {\n          type: \"MultiLineString\",\n          coordinates: track,\n        }\n      : {\n          type: \"LineString\",\n          coordinates: track[0],\n        },\n  };\n}\n\nfunction getPoint(node) {\n  return {\n    type: \"Feature\",\n    properties: Object.assign(getProperties(node), getMulti(node, [\"sym\"])),\n    geometry: {\n      type: \"Point\",\n      coordinates: coordPair(node).coordinates,\n    },\n  };\n}\n\nexport function* gpxGen(doc) {\n  const tracks = doc.getElementsByTagName(\"trk\");\n  const routes = doc.getElementsByTagName(\"rte\");\n  const waypoints = doc.getElementsByTagName(\"wpt\");\n\n  for (let i = 0; i < tracks.length; i++) {\n    const feature = getTrack(tracks[i]);\n    if (feature) yield feature;\n  }\n  for (let i = 0; i < routes.length; i++) {\n    const feature = getRoute(routes[i]);\n    if (feature) yield feature;\n  }\n  for (let i = 0; i < waypoints.length; i++) {\n    yield getPoint(waypoints[i]);\n  }\n}\n\nexport function gpx(doc) {\n  return {\n    type: \"FeatureCollection\",\n    features: Array.from(gpxGen(doc)),\n  };\n}\n", "import { nodeVal, get1 } from \"./shared.js\";\n\nconst EXTENSIONS_NS = \"http://www.garmin.com/xmlschemas/ActivityExtension/v2\";\n\nconst TRACKPOINT_ATTRIBUTES = [\n  [\"heartRate\", \"heartRates\"],\n  [\"Cadence\", \"cadences\"],\n  // Extended Trackpoint attributes\n  [\"Speed\", \"speeds\"],\n  [\"Watts\", \"watts\"],\n];\n\nconst LAP_ATTRIBUTES = [\n  [\"TotalTimeSeconds\", \"totalTimeSeconds\"],\n  [\"DistanceMeters\", \"distanceMeters\"],\n  [\"MaximumSpeed\", \"maxSpeed\"],\n  [\"AverageHeartRateBpm\", \"avgHeartRate\"],\n  [\"MaximumHeartRateBpm\", \"maxHeartRate\"],\n\n  // Extended Lap attributes\n  [\"AvgSpeed\", \"avgSpeed\"],\n  [\"AvgWatts\", \"avgWatts\"],\n  [\"MaxWatts\", \"maxWatts\"],\n];\n\nfunction fromEntries(arr) {\n  const obj = {};\n  for (const [key, value] of arr) {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nfunction getProperties(node, attributeNames) {\n  const properties = [];\n\n  for (const [tag, alias] of attributeNames) {\n    let elem = get1(node, tag);\n    if (!elem) {\n      const elements = node.getElementsByTagNameNS(EXTENSIONS_NS, tag);\n      if (elements.length) {\n        elem = elements[0];\n      }\n    }\n    const val = parseFloat(nodeVal(elem));\n    if (!isNaN(val)) {\n      properties.push([alias, val]);\n    }\n  }\n\n  return properties;\n}\n\nfunction coordPair(x) {\n  const lon = nodeVal(get1(x, \"LongitudeDegrees\"));\n  const lat = nodeVal(get1(x, \"LatitudeDegrees\"));\n  if (!lon.length || !lat.length) {\n    return null;\n  }\n  const ll = [parseFloat(lon), parseFloat(lat)];\n  const alt = get1(x, \"AltitudeMeters\");\n  const heartRate = get1(x, \"HeartRateBpm\");\n  const time = get1(x, \"Time\");\n  let a;\n  if (alt) {\n    a = parseFloat(nodeVal(alt));\n    if (!isNaN(a)) {\n      ll.push(a);\n    }\n  }\n  return {\n    coordinates: ll,\n    time: time ? nodeVal(time) : null,\n    heartRate: heartRate ? parseFloat(nodeVal(heartRate)) : null,\n    extensions: getProperties(x, TRACKPOINT_ATTRIBUTES),\n  };\n}\n\nfunction getPoints(node, pointname) {\n  const pts = node.getElementsByTagName(pointname);\n  const line = [];\n  const times = [];\n  const heartRates = [];\n  if (pts.length < 2) return null; // Invalid line in GeoJSON\n  const result = { extendedProperties: {} };\n  for (let i = 0; i < pts.length; i++) {\n    const c = coordPair(pts[i]);\n    if (c === null) continue;\n    line.push(c.coordinates);\n    if (c.time) times.push(c.time);\n    if (c.heartRate) heartRates.push(c.heartRate);\n    for (const [alias, value] of c.extensions) {\n      if (!result.extendedProperties[alias]) {\n        result.extendedProperties[alias] = Array(pts.length).fill(null);\n      }\n      result.extendedProperties[alias][i] = value;\n    }\n  }\n  return Object.assign(result, {\n    line: line,\n    times: times,\n    heartRates: heartRates,\n  });\n}\n\nfunction getLap(node) {\n  const segments = node.getElementsByTagName(\"Track\");\n  const track = [];\n  const times = [];\n  const heartRates = [];\n  const allExtendedProperties = [];\n  let line;\n  const properties = fromEntries(getProperties(node, LAP_ATTRIBUTES));\n\n  const nameElement = get1(node, \"Name\");\n  if (nameElement) {\n    properties.name = nodeVal(nameElement);\n  }\n\n  for (let i = 0; i < segments.length; i++) {\n    line = getPoints(segments[i], \"Trackpoint\");\n    if (line) {\n      track.push(line.line);\n      if (line.times.length) times.push(line.times);\n      if (line.heartRates.length) heartRates.push(line.heartRates);\n      allExtendedProperties.push(line.extendedProperties);\n    }\n  }\n  for (let i = 0; i < allExtendedProperties.length; i++) {\n    const extendedProperties = allExtendedProperties[i];\n    for (const property in extendedProperties) {\n      if (segments.length === 1) {\n        properties[property] = line.extendedProperties[property];\n      } else {\n        if (!properties[property]) {\n          properties[property] = track.map((track) =>\n            Array(track.length).fill(null)\n          );\n        }\n        properties[property][i] = extendedProperties[property];\n      }\n    }\n  }\n  if (track.length === 0) return;\n\n  if (times.length || heartRates.length) {\n    properties.coordinateProperties = Object.assign(\n      times.length\n        ? {\n            times: track.length === 1 ? times[0] : times,\n          }\n        : {},\n      heartRates.length\n        ? {\n            heart: track.length === 1 ? heartRates[0] : heartRates,\n          }\n        : {}\n    );\n  }\n\n  return {\n    type: \"Feature\",\n    properties: properties,\n    geometry: {\n      type: track.length === 1 ? \"LineString\" : \"MultiLineString\",\n      coordinates: track.length === 1 ? track[0] : track,\n    },\n  };\n}\n\nexport function* tcxGen(doc) {\n  const laps = doc.getElementsByTagName(\"Lap\");\n\n  for (let i = 0; i < laps.length; i++) {\n    const feature = getLap(laps[i]);\n    if (feature) yield feature;\n  }\n\n  const courses = doc.getElementsByTagName(\"Courses\");\n\n  for (let i = 0; i < courses.length; i++) {\n    const feature = getLap(courses[i]);\n    if (feature) yield feature;\n  }\n}\n\nexport function tcx(doc) {\n  return {\n    type: \"FeatureCollection\",\n    features: Array.from(tcxGen(doc)),\n  };\n}\n", "import { nodeVal, get1 } from \"./shared.js\";\n\nconst removeSpace = /\\s*/g;\nconst trimSpace = /^\\s*|\\s*$/g;\nconst splitSpace = /\\s+/;\n\n// generate a short, numeric hash of a string\nfunction okhash(x) {\n  if (!x || !x.length) return 0;\n  let h = 0;\n  for (let i = 0; i < x.length; i++) {\n    h = ((h << 5) - h + x.charCodeAt(i)) | 0;\n  }\n  return h;\n}\n\n// get one coordinate from a coordinate array, if any\nfunction coord1(v) {\n  return v.replace(removeSpace, \"\").split(\",\").map(parseFloat);\n}\n\n// get all coordinates from a coordinate array as [[],[]]\nfunction coord(v) {\n  return v.replace(trimSpace, \"\").split(splitSpace).map(coord1);\n}\n\nfunction xml2str(node) {\n  if (node.xml !== undefined) return node.xml;\n  if (node.tagName) {\n    let output = node.tagName;\n    for (let i = 0; i < node.attributes.length; i++) {\n      output += node.attributes[i].name + node.attributes[i].value;\n    }\n    for (let i = 0; i < node.childNodes.length; i++) {\n      output += xml2str(node.childNodes[i]);\n    }\n    return output;\n  }\n  if (node.nodeName === \"#text\") {\n    return (node.nodeValue || node.value || \"\").trim();\n  }\n  if (node.nodeName === \"#cdata-section\") {\n    return node.nodeValue;\n  }\n  return \"\";\n}\n\nconst geotypes = [\"Polygon\", \"LineString\", \"Point\", \"Track\", \"gx:Track\"];\n\nfunction kmlColor(properties, elem, prefix) {\n  let v = nodeVal(get1(elem, \"color\")) || \"\";\n  const colorProp =\n    prefix == \"stroke\" || prefix === \"fill\" ? prefix : prefix + \"-color\";\n  if (v.substr(0, 1) === \"#\") {\n    v = v.substr(1);\n  }\n  if (v.length === 6 || v.length === 3) {\n    properties[colorProp] = v;\n  } else if (v.length === 8) {\n    properties[prefix + \"-opacity\"] = parseInt(v.substr(0, 2), 16) / 255;\n    properties[colorProp] =\n      \"#\" + v.substr(6, 2) + v.substr(4, 2) + v.substr(2, 2);\n  }\n}\n\nfunction numericProperty(properties, elem, source, target) {\n  const val = parseFloat(nodeVal(get1(elem, source)));\n  if (!isNaN(val)) properties[target] = val;\n}\n\nfunction gxCoords(root) {\n  let elems = root.getElementsByTagName(\"coord\");\n  const coords = [];\n  const times = [];\n  if (elems.length === 0) elems = root.getElementsByTagName(\"gx:coord\");\n  for (let i = 0; i < elems.length; i++) {\n    coords.push(nodeVal(elems[i]).split(\" \").map(parseFloat));\n  }\n  const timeElems = root.getElementsByTagName(\"when\");\n  for (let j = 0; j < timeElems.length; j++) times.push(nodeVal(timeElems[j]));\n  return {\n    coords: coords,\n    times: times,\n  };\n}\n\nfunction getGeometry(root) {\n  let geomNode;\n  let geomNodes;\n  let i;\n  let j;\n  let k;\n  const geoms = [];\n  const coordTimes = [];\n  if (get1(root, \"MultiGeometry\")) {\n    return getGeometry(get1(root, \"MultiGeometry\"));\n  }\n  if (get1(root, \"MultiTrack\")) {\n    return getGeometry(get1(root, \"MultiTrack\"));\n  }\n  if (get1(root, \"gx:MultiTrack\")) {\n    return getGeometry(get1(root, \"gx:MultiTrack\"));\n  }\n  for (i = 0; i < geotypes.length; i++) {\n    geomNodes = root.getElementsByTagName(geotypes[i]);\n    if (geomNodes) {\n      for (j = 0; j < geomNodes.length; j++) {\n        geomNode = geomNodes[j];\n        if (geotypes[i] === \"Point\") {\n          geoms.push({\n            type: \"Point\",\n            coordinates: coord1(nodeVal(get1(geomNode, \"coordinates\"))),\n          });\n        } else if (geotypes[i] === \"LineString\") {\n          geoms.push({\n            type: \"LineString\",\n            coordinates: coord(nodeVal(get1(geomNode, \"coordinates\"))),\n          });\n        } else if (geotypes[i] === \"Polygon\") {\n          const rings = geomNode.getElementsByTagName(\"LinearRing\"),\n            coords = [];\n          for (k = 0; k < rings.length; k++) {\n            coords.push(coord(nodeVal(get1(rings[k], \"coordinates\"))));\n          }\n          geoms.push({\n            type: \"Polygon\",\n            coordinates: coords,\n          });\n        } else if (geotypes[i] === \"Track\" || geotypes[i] === \"gx:Track\") {\n          const track = gxCoords(geomNode);\n          geoms.push({\n            type: \"LineString\",\n            coordinates: track.coords,\n          });\n          if (track.times.length) coordTimes.push(track.times);\n        }\n      }\n    }\n  }\n  return {\n    geoms: geoms,\n    coordTimes: coordTimes,\n  };\n}\n\nfunction getPlacemark(root, styleIndex, styleMapIndex, styleByHash) {\n  const geomsAndTimes = getGeometry(root);\n  let i;\n  const properties = {};\n  const name = nodeVal(get1(root, \"name\"));\n  const address = nodeVal(get1(root, \"address\"));\n  let styleUrl = nodeVal(get1(root, \"styleUrl\"));\n  const description = nodeVal(get1(root, \"description\"));\n  const timeSpan = get1(root, \"TimeSpan\");\n  const timeStamp = get1(root, \"TimeStamp\");\n  const extendedData = get1(root, \"ExtendedData\");\n  let iconStyle = get1(root, \"IconStyle\");\n  let labelStyle = get1(root, \"LabelStyle\");\n  let lineStyle = get1(root, \"LineStyle\");\n  let polyStyle = get1(root, \"PolyStyle\");\n  const visibility = get1(root, \"visibility\");\n\n  if (name) properties.name = name;\n  if (address) properties.address = address;\n  if (styleUrl) {\n    if (styleUrl[0] !== \"#\") {\n      styleUrl = \"#\" + styleUrl;\n    }\n\n    properties.styleUrl = styleUrl;\n    if (styleIndex[styleUrl]) {\n      properties.styleHash = styleIndex[styleUrl];\n    }\n    if (styleMapIndex[styleUrl]) {\n      properties.styleMapHash = styleMapIndex[styleUrl];\n      properties.styleHash = styleIndex[styleMapIndex[styleUrl].normal];\n    }\n    // Try to populate the lineStyle or polyStyle since we got the style hash\n    const style = styleByHash[properties.styleHash];\n    if (style) {\n      if (!iconStyle) iconStyle = get1(style, \"IconStyle\");\n      if (!labelStyle) labelStyle = get1(style, \"LabelStyle\");\n      if (!lineStyle) lineStyle = get1(style, \"LineStyle\");\n      if (!polyStyle) polyStyle = get1(style, \"PolyStyle\");\n    }\n  }\n  if (description) properties.description = description;\n  if (timeSpan) {\n    const begin = nodeVal(get1(timeSpan, \"begin\"));\n    const end = nodeVal(get1(timeSpan, \"end\"));\n    properties.timespan = { begin: begin, end: end };\n  }\n  if (timeStamp) {\n    properties.timestamp = nodeVal(get1(timeStamp, \"when\"));\n  }\n  if (iconStyle) {\n    kmlColor(properties, iconStyle, \"icon\");\n    numericProperty(properties, iconStyle, \"scale\", \"icon-scale\");\n    numericProperty(properties, iconStyle, \"heading\", \"icon-heading\");\n\n    const hotspot = get1(iconStyle, \"hotSpot\");\n    if (hotspot) {\n      const left = parseFloat(hotspot.getAttribute(\"x\"));\n      const top = parseFloat(hotspot.getAttribute(\"y\"));\n      if (!isNaN(left) && !isNaN(top)) properties[\"icon-offset\"] = [left, top];\n    }\n    const icon = get1(iconStyle, \"Icon\");\n    if (icon) {\n      const href = nodeVal(get1(icon, \"href\"));\n      if (href) properties.icon = href;\n    }\n  }\n  if (labelStyle) {\n    kmlColor(properties, labelStyle, \"label\");\n    numericProperty(properties, labelStyle, \"scale\", \"label-scale\");\n  }\n  if (lineStyle) {\n    kmlColor(properties, lineStyle, \"stroke\");\n    numericProperty(properties, lineStyle, \"width\", \"stroke-width\");\n  }\n  if (polyStyle) {\n    kmlColor(properties, polyStyle, \"fill\");\n    const fill = nodeVal(get1(polyStyle, \"fill\"));\n    const outline = nodeVal(get1(polyStyle, \"outline\"));\n    if (fill)\n      properties[\"fill-opacity\"] =\n        fill === \"1\" ? properties[\"fill-opacity\"] || 1 : 0;\n    if (outline)\n      properties[\"stroke-opacity\"] =\n        outline === \"1\" ? properties[\"stroke-opacity\"] || 1 : 0;\n  }\n  if (extendedData) {\n    const datas = extendedData.getElementsByTagName(\"Data\"),\n      simpleDatas = extendedData.getElementsByTagName(\"SimpleData\");\n\n    for (i = 0; i < datas.length; i++) {\n      properties[datas[i].getAttribute(\"name\")] = nodeVal(\n        get1(datas[i], \"value\")\n      );\n    }\n    for (i = 0; i < simpleDatas.length; i++) {\n      properties[simpleDatas[i].getAttribute(\"name\")] = nodeVal(simpleDatas[i]);\n    }\n  }\n  if (visibility) {\n    properties.visibility = nodeVal(visibility);\n  }\n  if (geomsAndTimes.coordTimes.length) {\n    properties.coordinateProperties = {\n      times:\n        geomsAndTimes.coordTimes.length === 1\n          ? geomsAndTimes.coordTimes[0]\n          : geomsAndTimes.coordTimes,\n    };\n  }\n  const feature = {\n    type: \"Feature\",\n    geometry:\n      geomsAndTimes.geoms.length === 0\n        ? null\n        : geomsAndTimes.geoms.length === 1\n        ? geomsAndTimes.geoms[0]\n        : {\n            type: \"GeometryCollection\",\n            geometries: geomsAndTimes.geoms,\n          },\n    properties: properties,\n  };\n  if (root.getAttribute(\"id\")) feature.id = root.getAttribute(\"id\");\n  return feature;\n}\n\nexport function* kmlGen(doc) {\n  // styleindex keeps track of hashed styles in order to match feature\n  const styleIndex = {};\n  const styleByHash = {};\n  // stylemapindex keeps track of style maps to expose in properties\n  const styleMapIndex = {};\n  // atomic geospatial types supported by KML - MultiGeometry is\n  // handled separately\n  // all root placemarks in the file\n  const placemarks = doc.getElementsByTagName(\"Placemark\");\n  const styles = doc.getElementsByTagName(\"Style\");\n  const styleMaps = doc.getElementsByTagName(\"StyleMap\");\n\n  for (let k = 0; k < styles.length; k++) {\n    const style = styles[k];\n    const hash = okhash(xml2str(style)).toString(16);\n    let id = style.getAttribute(\"id\");\n    if (\n      !id &&\n      style.parentNode.tagName.replace(\"gx:\", \"\") === \"CascadingStyle\"\n    ) {\n      id =\n        style.parentNode.getAttribute(\"kml:id\") ||\n        style.parentNode.getAttribute(\"id\");\n    }\n    styleIndex[\"#\" + id] = hash;\n    styleByHash[hash] = style;\n  }\n  for (let l = 0; l < styleMaps.length; l++) {\n    styleIndex[\"#\" + styleMaps[l].getAttribute(\"id\")] = okhash(\n      xml2str(styleMaps[l])\n    ).toString(16);\n    const pairs = styleMaps[l].getElementsByTagName(\"Pair\");\n    const pairsMap = {};\n    for (let m = 0; m < pairs.length; m++) {\n      pairsMap[nodeVal(get1(pairs[m], \"key\"))] = nodeVal(\n        get1(pairs[m], \"styleUrl\")\n      );\n    }\n    styleMapIndex[\"#\" + styleMaps[l].getAttribute(\"id\")] = pairsMap;\n  }\n  for (let j = 0; j < placemarks.length; j++) {\n    const feature = getPlacemark(\n      placemarks[j],\n      styleIndex,\n      styleMapIndex,\n      styleByHash\n    );\n    if (feature) yield feature;\n  }\n}\n\nexport function kml(doc) {\n  return {\n    type: \"FeatureCollection\",\n    features: Array.from(kmlGen(doc)),\n  };\n}\n", "import type {LoaderOptions, LoaderWithParser} from '@loaders.gl/loader-utils';\nimport {geojsonToBinary} from '@loaders.gl/gis';\nimport {gpx} from '@tmcw/togeojson';\nimport type {GeoJSONRowTable, FeatureCollection, ObjectRowTable} from '@loaders.gl/schema';\n\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\n\nexport type GPXLoaderOptions = LoaderOptions & {\n  gpx?: {\n    shape?: 'object-row-table' | 'geojson-row-table' | 'geojson' | 'binary' | 'raw';\n    /** @deprecated. Use options.gpx.shape */\n    type?: 'object-row-table' | 'geojson-row-table' | 'geojson' | 'binary' | 'raw';\n  };\n  gis?: {\n    /** @deprecated. Use options.gpx.shape */\n    format?: 'object-row-table' | 'geojson-row-table' | 'geojson' | 'binary' | 'raw';\n  };\n};\n\nconst GPX_HEADER = `\\\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<gpx`;\n\n/**\n * Loader for GPX (GPS exchange format)\n */\nexport const GPXLoader = {\n  name: 'GPX (GPS exchange format)',\n  id: 'gpx',\n  module: 'kml',\n  version: VERSION,\n  extensions: ['gpx'],\n  mimeTypes: ['application/gpx+xml'],\n  text: true,\n  tests: [GPX_HEADER],\n  parse: async (arrayBuffer, options?: GPXLoaderOptions) =>\n    parseTextSync(new TextDecoder().decode(arrayBuffer), options),\n  parseTextSync,\n  options: {\n    gpx: {},\n    gis: {}\n  }\n};\n\nfunction parseTextSync(text: string, options?: GPXLoaderOptions) {\n  const doc = new DOMParser().parseFromString(text, 'text/xml');\n  const geojson: FeatureCollection = gpx(doc);\n\n  const shape = options?.gis?.format || options?.gpx?.type || options?.gpx?.shape;\n\n  switch (shape) {\n    case 'object-row-table': {\n      const table: ObjectRowTable = {\n        shape: 'object-row-table',\n        data: geojson.features\n      };\n      return table;\n    }\n    case 'geojson-row-table': {\n      const table: GeoJSONRowTable = {\n        shape: 'geojson-row-table',\n        data: geojson.features\n      };\n      return table;\n    }\n    case 'geojson':\n      return geojson;\n    case 'binary':\n      return geojsonToBinary(geojson.features);\n    case 'raw':\n      return doc;\n    default:\n      // Default to geojson for backwards compatibility\n      return geojson;\n  }\n}\n\nexport const _typecheckGPXLoader: LoaderWithParser = GPXLoader;\n", "import type {LoaderWithParser, LoaderOptions} from '@loaders.gl/loader-utils';\nimport {geojsonToBinary} from '@loaders.gl/gis';\nimport {kml} from '@tmcw/togeojson';\nimport {GeoJSONRowTable, FeatureCollection, ObjectRowTable} from '@loaders.gl/schema';\n\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\n\nexport type KMLLoaderOptions = LoaderOptions & {\n  kml?: {\n    shape?: 'object-row-table' | 'geojson-row-table' | 'geojson' | 'binary' | 'raw';\n    /** @deprecated. Use options.kml.shape */\n    type?: 'object-row-table' | 'geojson-row-table' | 'geojson' | 'binary' | 'raw';\n  };\n  gis?: {\n    /** @deprecated. Use options.kml.shape */\n    format?: 'object-row-table' | 'geojson-row-table' | 'geojson' | 'binary' | 'raw';\n  };\n};\n\nconst KML_HEADER = `\\\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<kml xmlns=\"http://www.opengis.net/kml/2.2\">`;\n\n/**\n * Loader for KML (Keyhole Markup Language)\n */\nexport const KMLLoader = {\n  name: 'KML (Keyhole Markup Language)',\n  id: 'kml',\n  module: 'kml',\n  version: VERSION,\n  extensions: ['kml'],\n  mimeTypes: ['application/vnd.google-earth.kml+xml'],\n  text: true,\n  tests: [KML_HEADER],\n  parse: async (arrayBuffer, options?: KMLLoaderOptions) =>\n    parseTextSync(new TextDecoder().decode(arrayBuffer), options),\n  parseTextSync,\n  options: {\n    kml: {},\n    gis: {}\n  }\n};\n\nfunction parseTextSync(text: string, options?: KMLLoaderOptions) {\n  const doc = new DOMParser().parseFromString(text, 'text/xml');\n  const geojson: FeatureCollection = kml(doc);\n\n  // backwards compatibility\n  const shape = options?.gis?.format || options?.kml?.type || options?.kml?.shape;\n  switch (shape) {\n    case 'object-row-table': {\n      const table: ObjectRowTable = {\n        shape: 'object-row-table',\n        data: geojson.features\n      };\n      return table;\n    }\n    case 'geojson-row-table': {\n      const table: GeoJSONRowTable = {\n        shape: 'geojson-row-table',\n        data: geojson.features\n      };\n      return table;\n    }\n    case 'geojson':\n      return geojson;\n    case 'binary':\n      return geojsonToBinary(geojson.features);\n    case 'raw':\n      return doc;\n    default:\n      // Default to geojson for backwards compatibility\n      return geojson;\n  }\n}\n\nexport const _typecheckKMLLoader: LoaderWithParser = KMLLoader;\n", "import type {LoaderWithParser, LoaderOptions} from '@loaders.gl/loader-utils';\nimport {geojsonToBinary} from '@loaders.gl/gis';\nimport {tcx} from '@tmcw/togeojson';\nimport type {GeoJSONRowTable, FeatureCollection, ObjectRowTable} from '@loaders.gl/schema';\n\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\n\nexport type TCXLoaderOptions = LoaderOptions & {\n  tcx?: {\n    shape?: 'object-row-table' | 'geojson-row-table' | 'geojson' | 'binary' | 'raw';\n    /** @deprecated. Use options.tcx.shape */\n    type?: 'object-row-table' | 'geojson-row-table' | 'geojson' | 'binary' | 'raw';\n  };\n  gis?: {\n    /** @deprecated. Use options.tcx.shape */\n    format?: 'object-row-table' | 'geojson-row-table' | 'geojson' | 'binary' | 'raw';\n  };\n};\n\nconst TCX_HEADER = `\\\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<TrainingCenterDatabase`;\n\n/**\n * Loader for TCX (Training Center XML) - Garmin GPS track format\n */\nexport const TCXLoader = {\n  name: 'TCX (Training Center XML)',\n  id: 'tcx',\n  module: 'kml',\n  version: VERSION,\n  extensions: ['tcx'],\n  mimeTypes: ['application/vnd.garmin.tcx+xml'],\n  text: true,\n  tests: [TCX_HEADER],\n  parse: async (arrayBuffer, options?: TCXLoaderOptions) =>\n    parseTextSync(new TextDecoder().decode(arrayBuffer), options),\n  parseTextSync,\n  options: {\n    tcx: {},\n    gis: {}\n  }\n};\n\nfunction parseTextSync(text: string, options?: TCXLoaderOptions) {\n  const doc = new DOMParser().parseFromString(text, 'text/xml');\n  const geojson: FeatureCollection = tcx(doc);\n\n  // backwards compatibility\n  const shape = options?.gis?.format || options?.tcx?.type || options?.tcx?.shape;\n\n  switch (shape) {\n    case 'object-row-table': {\n      const table: ObjectRowTable = {\n        shape: 'object-row-table',\n        data: geojson.features\n      };\n      return table;\n    }\n    case 'geojson-row-table': {\n      const table: GeoJSONRowTable = {\n        shape: 'geojson-row-table',\n        data: geojson.features\n      };\n      return table;\n    }\n    case 'geojson':\n      return geojson;\n    case 'binary':\n      return geojsonToBinary(geojson.features);\n    case 'raw':\n      return doc;\n    default:\n      // Default to geojson for backwards compatibility\n      return geojson;\n  }\n}\n\nexport const _typecheckTCXLoader: LoaderWithParser = TCXLoader;\n"],
  "mappings": "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",
  "names": ["flatGeojsonToBinary", "features", "geometryInfo", "options", "propArrayTypes", "extractNumericPropTypes", "numericPropKeys", "Object", "keys", "filter", "k", "Array", "fillArrays", "PositionDataType", "Float32Array", "triangulate", "extractNumericPropTypes", "features", "propArrayTypes", "feature", "properties", "key", "val", "deduceArrayType", "fillArrays", "geometryInfo", "options", "pointPositionsCount", "pointFeaturesCount", "linePositionsCount", "linePathsCount", "lineFeaturesCount", "polygonPositionsCount", "polygonObjectsCount", "polygonRingsCount", "polygonFeaturesCount", "coordLength", "numericPropKeys", "PositionDataType", "Float32Array", "triangulate", "hasGlobalId", "GlobalFeatureIdsDataType", "length", "Uint32Array", "Uint16Array", "points", "type", "positions", "globalFeatureIds", "featureIds", "numericProps", "fields", "lines", "pathIndices", "polygons", "polygonIndices", "primitivePolygonIndices", "triangles", "object", "propName", "T", "indexMap", "pointPosition", "pointFeature", "linePosition", "linePath", "lineFeature", "polygonPosition", "polygonObject", "polygonRing", "polygonFeature", "geometry", "handlePoint", "push", "keepStringProperties", "id", "handleLineString", "handlePolygon", "Error", "makeAccessorObjects", "set", "data", "nPositions", "fillNumericProperties", "fill", "i", "il", "indices", "start", "end", "l", "ll", "startPosition", "areas", "nextIndices", "undefined", "endPosition", "triangulatePolygon", "_ref", "polygonPositions", "subarray", "offset", "holes", "slice", "map", "n", "earcut", "t", "tl", "wrapProps", "obj", "size", "returnObj", "value", "binaryFeatures", "index", "numericPropName", "numericKeys", "props", "includes", "x", "constructor", "Array", "Number", "isFinite", "Float64Array", "Math", "fround", "extractGeometryInfo", "features", "pointPositionsCount", "pointFeaturesCount", "linePositionsCount", "linePathsCount", "lineFeaturesCount", "polygonPositionsCount", "polygonObjectsCount", "polygonRingsCount", "polygonFeaturesCount", "coordLengths", "Set", "feature", "geometry", "type", "add", "coordinates", "length", "point", "coord", "line", "flattened", "flat", "polygon", "Error", "concat", "coordLength", "size", "Math", "max", "geojsonToFlatGeojson", "features", "options", "arguments", "length", "undefined", "coordLength", "fixRingWinding", "map", "feature", "flattenFeature", "flattenPoint", "coordinates", "data", "indices", "push", "i", "flattenLineString", "c", "flattenPolygon", "areas", "count", "ringAreas", "polygons", "lineString", "lineString2d", "p", "slice", "area", "getPolygonSignedArea", "flat", "ccw", "reverse", "geometry", "type", "Error", "concat", "geojsonToBinary", "features", "options", "arguments", "length", "undefined", "fixRingWinding", "triangulate", "geometryInfo", "extractGeometryInfo", "coordLength", "flatFeatures", "geojsonToFlatGeojson", "flatGeojsonToBinary", "numericPropKeys", "PositionDataType", "Float32Array", "getProperties", "coordPair", "getPoints", "line", "track", "VERSION", "GPX_HEADER", "GPXLoader", "name", "id", "module", "version", "extensions", "mimeTypes", "text", "tests", "parse", "arrayBuffer", "options", "parseTextSync", "TextDecoder", "decode", "gpx", "gis", "_options$gis", "_options$gpx", "_options$gpx2", "doc", "DOMParser", "parseFromString", "geojson", "shape", "format", "type", "table", "data", "features", "geojsonToBinary", "VERSION", "KML_HEADER", "KMLLoader", "name", "id", "module", "version", "extensions", "mimeTypes", "text", "tests", "parse", "arrayBuffer", "options", "parseTextSync", "TextDecoder", "decode", "kml", "gis", "_options$gis", "_options$kml", "_options$kml2", "doc", "DOMParser", "parseFromString", "geojson", "shape", "format", "type", "table", "data", "features", "geojsonToBinary", "VERSION", "TCX_HEADER", "TCXLoader", "name", "id", "module", "version", "extensions", "mimeTypes", "text", "tests", "parse", "arrayBuffer", "options", "parseTextSync", "TextDecoder", "decode", "tcx", "gis", "_options$gis", "_options$tcx", "_options$tcx2", "doc", "DOMParser", "parseFromString", "geojson", "shape", "format", "type", "table", "data", "features", "geojsonToBinary"]
}
